\documentclass[nofonts]{uebung}
%\setmainfont{NewCM10-Book}[ItalicFont={NewCM10-BookItalic}, BoldFont={NewCM10-Bold}]
%\setmathfont{NewCMMath-Book}
\usepackage[margin=3cm]{geometry}
\setmainfont{Latin Modern Roman}
\usepackage{unicode-math}
\setmathfont{Latin Modern Math}
\setmathfont[version=lm,range={\setminus}, Scale=MatchUppercase]{STIX Two Math}

\setmainlanguage{german}


\usepackage{amsthm}
\usepackage{amsmath}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Behauptung}
\newtheorem{corollary}[theorem]{Korollar}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{fact}[theorem]{Fakt}


\setlist[enumerate]{label=(\arabic*), itemsep=0pt}
\setlist[itemize]{itemsep=0pt}
\setlist{beginpenalty=10000, midpenalty=10000}

\newlist{statements}{enumerate}{1}
\setlist[statements]{resume,label=(A\arabic*)}

\usepackage{turnstile}

\def\P{\ensuremath{\mathrm{P}}}
\def\NP{\ensuremath{\mathrm{NP}}}
\def\NE{\ensuremath{\mathrm{NE}}}
\def\NEE{\ensuremath{\mathrm{NEE}}}
\def\FP{\ensuremath{\mathrm{FP}}}
\def\UP{\ensuremath{\mathrm{UP}}}
\def\DisjNP{\ensuremath{\mathrm{DisjNP}}}
\def\DisjCoNP{\ensuremath{\mathrm{DisjCoNP}}}
\def\DisjUP{\ensuremath{\mathrm{DisjUP}}}
\def\DisjCoUP{\ensuremath{\mathrm{DisjCoUP}}}
\def\coNP{\ensuremath{\mathrm{coNP}}}
\def\coNE{\ensuremath{\mathrm{coNE}}}
\def\coNEE{\ensuremath{\mathrm{coNEE}}}
\def\coUP{\ensuremath{\mathrm{coUP}}}
\def\NPcoNP{\ensuremath{\mathrm{NP}\cap\mathrm{coNP}}}
\def\TFNP{\ensuremath{\mathrm{TFNP}}}
\def\TALLY{\ensuremath{\mathrm{TALLY}}}
\def\NPMV{\ensuremath{\mathrm{NPMV}}}
\def\NPMVt{\ensuremath{\mathrm{NPMV_t}}}
\def\NPSV{\ensuremath{\mathrm{NPSV}}}
\def\NPSVt{\ensuremath{\mathrm{NPSV_t}}}
\def\NPbV{\ensuremath{\mathrm{NPbV}}}
\def\NPbVt{\ensuremath{\mathrm{NPbV_t}}}
\def\NPkV{\ensuremath{\mathrm{NP}k\mathrm{V}}}
\def\NPkVt{\ensuremath{\mathrm{NP}k\mathrm{V_t}}}
\def\TAUT{\ensuremath{\mathrm{TAUT}}}
\def\SAT{\ensuremath{\mathrm{SAT}}}
\def\PF{\ensuremath{\mathrm{PF}}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\img}{img}
\DeclareMathOperator{\supp}{supp}
\def\hUP{\ensuremath{\mathsf{UP}}}
\def\hDisjNP{\ensuremath{\mathsf{DisjNP}}}
\def\hDisjCoNP{\ensuremath{\mathsf{DisjCoNP}}}
\def\hNPcoNP{\ensuremath{\mathsf{NP}{}\cap{}\mathsf{coNP}}}
\def\hCON{\ensuremath{\mathsf{CON}}}
\def\hSAT{\ensuremath{\mathsf{SAT}}}
\def\hTFNP{\ensuremath{\mathsf{TFNP}}}
\def\leqmpp{\ensuremath{\leq_\mathrm{m}^\mathrm{pp}}}
\def\leqmp{\ensuremath{\leq_\mathrm{m}^\mathrm{p}}}
\DeclareMathOperator{\tower}{tower}


\begin{document}

\renewcommand{\phi}{\varphi}
\noindent
%Sei $B\in\mathrm P$, $B\subseteq\Sigma^*\times\Sigma^*$ mit folgender Padding-Eigenschaft:
Sei $A\in\mathrm {NP}$ mit folgender Padding-Eigenschaft:
es existiert eine Menge $B\in\mathrm P$ sodass $A=\{x\mid \exists y, |y|\leq p(|x|), (x,y)\in B\}$ und 
für alle $n\in\mathbb N$ gilt
\[ (x,y)\in B \iff (\mathit{pad}(x, 1^n), y)\in B. \]
wobei $\mathit{pad}\in\mathrm{FP}$ und verlängernd ist.
Die folgenden Aussagen sind äquivalent:
\begin{statements}
    \item Für alle NPTM $N$ mit $L(N)=A$ lassen sich akzepierende Rechenwege von $N$ in Zertifikate umrechnen: es existiert eine Funktion $f\in\mathrm{FP}$ sodass
        \[ N(x) \text{ akz. mit RW $\alpha$} \implies (x,f(x,\alpha))\in B. \]
    \item Das Standard-Beweissystem $\mathit{std}_B$ bzgl. $B$ ist p-optimal. Dieses ist
        \[ \mathit{std}_B(w) = \begin{cases} x & \text{wenn $w=(x,y)$ und $(x,y)\in B$}\\
        \top & \text{sonst}\end{cases}. \] 
\end{statements}

\begin{center}\ast\end{center}

\noindent
Diese Padding-Eigenschaft erfüllen folgende Mengen:
\begin{itemize}
    \item $\mathrm{SAT}=\{ \phi\mid \exists y. \phi(y)=1 \}$, Padding durch Anhängen von Tautologien.
        Hier ist $\mathit{std}_B$ das Standard-Beweissystem für SAT.
    \item Das kanonische vollständige Problem \[ K=\{ (N,x,1^i) \mid \exists \alpha, |\alpha|\leq i, N(x)\text{ akz. mit RW $\alpha$} \},\]Padding durch „Verlängern“ von $N$ mit nicht erreichbaren Zuständen.

        Hier lässt sich (A1) auch wie folgt interpretieren: jede universelle NP-Maschine $U$ mit $L(U)=K$ ist „transparent“ in dem Sinn dass ein akzeptierender Rechenweg $\alpha$ von $U(N,x,1^i)$ sich effizient in einen akzeptierenden Rechenweg $\beta$ für $N(x)$ umrechnen lassen kann.

    \item Jede Menge $A\in\mathrm{NP}$, die im klassischen Sinn paddable ist, also für die eine Funktion $g$ mit $g,g^{-1}\in\mathrm{FP}$ existiert sodass $x\in A \iff g(x,z)\in A$.
\end{itemize}


\begin{center}\ast\end{center}

\noindent
%Sei $R\in\mathrm{NPMV}$ vollständig unter folgenden Begriff von Reduktion (vgl. die Definition von Pudlák zur Reduktion zwischen TFNP-Funktionen):
%$S$ ist reduzierbar auf $S$ wenn zwei Funktionen $f,g\in\mathrm{FP}$ existieren sodass
%\[ R(f(x),z)=S(x,g(x,z)). \]
%(Vgl. auch Levin-Reduktion von Suchproblemen.)
%
%Ein Suchproblem $R$ ist eine Menge in P sodass wenn $(x,y)\in R$ dann ist $y$ höchstens polynomiell länger als $x$.
%Sei $L(R)=\{x\mid \exists y\mid (x,y)\in R\}\in\mathrm{NP}$ das zugehörige Entscheidungsproblem.

%Ein Suchproblem $S$ ist polynomialzeit-reduzierbar auf $R$ wenn zwei Funktionen $f,g\in\mathrm{FP}$ existieren sodass $x\in L(S)\iff f(x)\in L(R)$ und
%\[ (f(x),z)\in R \implies (x,g(x,z))\in S. \]
%(Funktion $g$ bildet Zertifikate für $f(x)\in R$ auf Zerifikate für $x\in S$ ab.)
Sei $A\in\mathrm{NP}$ mit folgender Eigenschaft von Vollständigkeit: es existiert eine Menge $B\in\mathrm P$ sodass $A=\{x\mid \exists y, |y|\leq p(|x|), (x,y)\in B\}$ und für alle Mengen $A'\in\mathrm{NP}$, $A'=\{x\mid \exists y, |y|\leq p'(|x|), (x,y)\in B'\}$ existieren zwei Funktionen $r,r^{-1},t\in\mathrm{FP}$ sodass
\[ x\in A' \iff r(x) \in A, \quad (r(x),z)\in B \implies (x, t(x,z)) \in B'. \]
($A'\leq_m^p A$ via invertierbarem $r$, Funktion $t$ bildet Zertifikate für $r(x)\in A$ auf Zertifikate für $x\in A'$ ab. Vgl. Reduktionsbegriff unter TFNP-Problemen. Vgl. Levin-Reduktionsbegriff.)
Folgende Aussagen sind äquivalent:
\begin{statements}
    \item[(A1)] Für alle NPTM $N$ mit $L(N)=A$ lassen sich akzepierende Rechenwege von $N$ in Zertifikate umrechnen: es existiert eine Funktion $f\in\mathrm{FP}$ sodass
        \[ N(x) \text{ akz. mit RW $\alpha$} \implies (x,f(x,\alpha))\in B. \]
    \item[(Q)] $\mathrm{NPMV}_t \subseteq_c \mathrm{FP}$.
    %\item Für alle NPTM $N$ mit $L(N)=\Sigma^*$ lassen sich aus Eingabe $x$ Rechenwege von $N(x)$ effizient bestimmen: es existiert $g\in\mathrm{FP}$ sodass $N(x)\sststile{}{g(x)}1$ für alle $x$. (Das ist die Aussage Q.)
\end{statements}

\begin{center}\ast\end{center}

\noindent
Zumindest SAT und $K$ erfüllen sowohl die Padding-Eigenschaft, als auch die Vollständigkeits-Eigenschaft.
Deren Standard-Beweissysteme sind p-optimal genau dann wenn $Q$ gilt.

Die genannte Padding-Eigenschaft und Vollständigkeits-Eigenschaft werden von Mengen erfüllt, welche Levin-vollständig und paddable (im klassichen Sinn) sind.
\clearpage

Für Relation $R$ ist zulässig wenn $R(x,y)\implies |y|\leq p(|x|)$. Für zulässige Relationen $R$ ist $L(R)=\{x\mid\exists y. R(x,y)\}\in\mathrm{NP}$.

Eine Relation $R$ ist Levin-vollständig falls diese zulässig ist,
und für jede zulässige Relation $Q$ gilt: es existieren FP-Funktionen $f$ und $g$ mit
\[ x\in L(Q) \iff f(x)\in L(R), \quad R(f(x),z) \implies Q(x, g(x,z)). \]
Die folgenden Aussagen sind äquivalent:
\begin{enumerate}
    \item Das Standardbeweissystem $sat$ für SAT ist p-optimal\\
        {}[wahrscheinlich falsch da wahrscheinlich $\mathsf{SAT}$]
    \item Für eine Levin-vollständige, paddable Relation $R$ ist das Standardbeweissystem $std_R$ p-optimal. Zur Erinnerung:
        \[ \mathit{std}_R(w) = \begin{cases} x & \text{wenn $w=(x,y)$ und $R(x,y)$}\\
        \top & \text{sonst}\end{cases}. \] 
    \item Für \emph{alle} Levin-vollständigen, paddable Relationen $R$ ist das Standardbeweissystem $std_R$ p-optimal
    \item $\mathrm{NPMV}_t\subseteq_c \mathrm{FP}$, i.e., Q\\
        {}[wahrscheinlich falsch da wahrscheinlich $\mathrm{P}\neq\mathrm{NP}\cap\mathrm{coNP}$]
    \item Jedes optimale Beweissystem ist p-optimal
    \item Für jede Relation gilt:\\ $R$ ist Levin-vollständig $\iff$ $L(R)$ ist many-one-vollständig.\\
        {}[„empirisch“ wahr]
\end{enumerate}
\clearpage


\subsection*{Orakelkonstruktion $\hDisjNP$, $\hUP$, und $Q$}

Konstruktion wie bei DG.

Sei $e(0)=2, e(i+1)=2^{e(i)}$. Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmenge von $e(\mathbb N)$. (Ebenen $H_m$ gehören zur Zeugensprache bzgl. DisjNP-Maschinenpaar $M_a, M_b$.)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.
Definiere folgende Zeugensprachen:
        \begin{gather*}
            A_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O \text{ und $x$ endet mit $0$} \}\\
            B_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O \text{ und $x$ endet mit $1$} \}\\
            C_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O  \}
        \end{gather*}
        Fakt: wenn $|O\cap \Sigma^{n}|\leq 1$ für alle $n\in H_m$, dann $(A_m^O, B_m^O)\in\DisjNP^O$.\\
        Wenn $|O\cap \Sigma^n|\leq 1$ für alle $n\in H_m$, dann $C_m^O \in \UP^O$.
\medskip

Idee: erreiche entweder dass $M_a$, $M_b$ nicht disjunkt akzeptieren (Task $\tau^1_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^1_{a,b,r}$ für Transduktor $F_r$).

Symmetrisch: erreiche das $M_a$ nicht kategorisch akzeptiert (Task $\tau^3_{a}$), oder dass die Zeugensprache $C_m$ nicht auf $L(M_a)$ reduzierbar ist (Task $\tau^2_{a,r}$ für Transduktor $T_r$).

Gleichzeitig versuchen wir für möglichst viele $M_j$ erreichen, dass diese nicht total sind. (Task $\tau^2_j$)
%Dies hat in gewisser Weise Priorität über die o.g. Diagonalisierung.
Am Ende sind die verbleibenden totalen Maschinen $M^O_j$ sehr speziell, denn sie sind auch für gewisse Teilmengen von $O$ total.
In Kombination mit dem Fakt dass $\P^C=\mathrm{PSPACE}^C$ können wir relevante Wörter in $O-C$ errechnen und so einen akzeptierenden Weg von $M^O_j(x)$ ausgeben -- damit erzielen wir $Q$.
\medskip

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^1_j, \tau^2_{a,b}, \tau^3_a$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

Ein Orakel $w\in\Sigma^*$ ist $t$-valide wenn $t\in\mathcal T$ und folgendes gilt:
\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    \item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2$.\\
        (Orakel $w$ ist dünn auf den Ebenen der Länge $e(\cdot)$.)
    \item Wenn $t(\tau^1_j)=0$, dann existiert ein $z$ sodass $M_j^w(z)$ definitiv ablehnt.\\
        ($L(M_j)\neq \Sigma^*$ relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv akzeptieren.\\
        (Wenn $t(\tau^2_{a,b})=0$, dann $L(M_a)\cap L(M_b)\neq \emptyset$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^2_{a,b})=m$, dann gilt für alle $n\in H_m$ dass $|\Sigma^{n}\cap w|\leq 1$.\\
        (Wenn $0<t(\tau^2_{a,b})=m$, dann $(A_m,B_m)\in\DisjNP$.)
    \item Wenn $t(\tau^3_{a})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ definitiv auf zwei Rechenwegen akzeptiert.\\
        (Wenn $t(\tau^3_{a})=0$, dann $L(M_a)\not\in \UP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^3_{a})=m$, dann gilt für alle $n\in H_m$ dass $|\Sigma^n\cap w|\leq 1$.\\
        (Wenn $0<t(\tau^3_{a})=m$, dann $C_m\in\UP$.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^2_{a,b,r}$ immer nach $\tau^2_{a,b}$ kommt, sowie $\tau^3_{a,r}$ immer nach $\tau^3_a$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_j$: Setze $t'=t_{s-1}\cup\{\tau^1_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^2_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^2_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^2_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^2_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^2_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in A_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
            \item $0^n\in B_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
        \end{itemize} (Das ist möglich nach Behauptung 2.)

    \item $\tau^3_{a}$: Setze $t'=t_{s-1}\cup\{\tau^3_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^3_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^3_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^3_{a,r}$: Wir wissen dass $t_{s-1}(\tau^3_{a})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in C_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
            \item $0^n\not\in C_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ akzeptiert relativ zu $w_s$ definitiv.
        \end{itemize} (Das ist möglich nach Behauptung 3.)
\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $b\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^2_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^2_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}
\begin{proof}[Skizze.]
    Widerspruchsbeweis. Erweitere $w_{s-1}$ mit Behauptung 1 so weit zu $u$, dass genau alle Wörter der Länge $<n=e(i)\in H_m$ definiert sind, wobei das $i$ hinreichend groß gewählt wird. Sei $u(X), X\subseteq \Sigma^n$ das Orakel was entsteht, wenn die Ebene $e(i)$ mit genau den Wörtern aus $X$ gefüllt wird, bzw. $u(X)=u\cup X \cup C$. Beob. dass $u(X), |X|\leq 1$ auch $t_{s-1}$-valide ist.

    Nach Annahme gilt
    \begin{itemize}
        \item für gerades $\alpha\in \Sigma^n$ gilt $0^n\in A_m^{u(\{\alpha\})}$ und daher akzeptiert $M_a(F_r(0^n))$ definitiv relativ zu $u(\{\alpha\})$.
        \item für ungerades $\beta\in \Sigma^n$ gilt $0^n\in B_m^{u(\{\alpha\})}$ und daher akzeptiert $M_b(F_r(0^n))$ definitiv relativ zu $u(\{\beta\})$.
    \end{itemize}
    Kombinatorische Standardmethoden zeigen dann, dass relativ zu $u(\{\alpha,\beta\})$ mit geeignetem geraden $\alpha$, ungeradem $\beta$ sowohl $M_a(F_r(0^n))$ also auch $M_b(F_r(0^n))$ relativ zu $u(\{\alpha,\beta\})$ akzeptieren.
    Damit wäre aber auch $u(\{\alpha,\beta\})$ ein geeignetes Orakel in der Bearbeitung von Task $\tau^2_{a,b}$ und wir hätten $t_{s-1}(\tau^2_{a,b})=0$.
\end{proof}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^3_{a,r}$ ist möglich: gilt $t_{s-1}(\tau^3_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}
\begin{proof}[Skizze.]
    Widerspruchsbeweis symmetrisch zu Behauptunng 2. Betrachte wieder die identisch definierten Orakel $u(X)$.
    Nach Annahme gilt
    \begin{itemize}
        \item es gilt $0^n\in C_m^{u(\emptyset)}$ und daher lehnt $M_a(F_r(0^n))$ definitiv relativ zu $u(\emptyset)$ ab. [Das ist wichtig um zu zeigen dass es zwei \emph{unterschiedliche} Berechnungen gibt.]
        \item für gerades $\alpha\in \Sigma^n$ gilt $0^n\in C_m^{u(\{\alpha\})}$ und daher akzeptiert $M_a(F_r(0^n))$ definitiv relativ zu $u(\{\alpha\})$.
        \item für ungerades $\beta\in \Sigma^n$ gilt $0^n\in C_m^{u(\{\beta\})}$ und daher akzeptiert $M_a(F_r(0^n))$ definitiv relativ zu $u(\{\beta\})$.
    \end{itemize}
    Sei für $\xi\in\Sigma^n$ die Menge $Q_\xi$ die Menge an Orakelfragen auf dem akzeptierenden Rechenweg von $M_a(F_r(0^n))$ relativ zu $u(\{\alpha\})$.
    Es gilt $\xi\in Q_\xi$, denn andernfalls würde $u(\emptyset)$ und $u(\{\xi\})$ auf $Q_\xi$ übereinstimmen und wir hätten dass auch $M_a(F_r(0^n))$ relativ zu $u(\emptyset)$ akzeptiert. Das widerspricht der Annahme.

    Kombinatorische Standarmethoden zeigen dann, dass es ein gerades $\alpha$, ungerades $\beta$ gibt mit $\alpha\not\in Q_\beta$, $\beta\not\in Q_\alpha$ und so $M_a(F_r(0^n))$ relativ zu $u(\{\alpha,\beta\})$ auf zwei Rechenwegen akzeptiert, je mit Orakelfragen $Q_\alpha$ und $Q_\beta$. Diese Rechenwege sind nicht gleich, da $\alpha\in Q_\alpha$ nach obiger Behauptung, aber $\beta\not\in Q_\beta$.

    Damit wäre aber auch $u(\{\alpha,\beta\})$ ein geeignetes Orakel in der Bearbeitung von Task $\tau^3_{a}$ und wir hätten $t_{s-1}(\tau^3_{a})=0$.
\end{proof}

Damit ist die Konstruktion möglich. Sei $O=\lim_{s\to\infty} w_s$.

\begin{claim}
    Kein Paar aus $\DisjNP^O$ ist $\leqmpp$-hart für $\DisjUP$.
\end{claim}

\begin{claim}
    Keine Menge aus $\UP^O$ ist $\leqmp$-vollständig.
\end{claim}


\begin{claim}
    Sei $M_j$ eine totale Maschine, d.h. $L(M^O)=\Sigma^*$.
    Es existiert eine Länge $n$ mit folgender Eigenschaft: 
    falls $T\subseteq O$ mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern $\leq n$ übereinstimmt, dann $L(M_j^T)=\Sigma^*$.
\end{claim}
\begin{proof}[Skizze.]
    Sei $s$ die Stufe bei der $\tau^1_j$ bearbeitet wurde. Setze $n=|w_{s-1}|$.
    Wir zeigen nun, dass dieses $n$ die behauptete Eigenschaft erfüllt.
    Angenommen, dies gilt nicht, dann existiert ein $T\subseteq O$ dass mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern $<n$ übereinstimmt, aber für ein Wort $z$ lehnt $M_j^T(x)$ ab.
    Sei $t'=t_{s-1}\cup \{\tau^1_j\mapsto 0\}$ und sei $v=T\cap\Sigma^{\leq p_j(|x|)}$. 
    Beob. dass $M_j^v(z)$ definitiv ablehnt.

    Wir zeigen, das $v$ auch $t'$-valide ist;  damit wäre $v$ eine geeignete Erweiterung in Stufe $s$ und wir hätten $t_s=t'$. 
    Das bedeutet nach V3, dass $M_j^{w_s}(z)$ definitiv ablehnt, damit auch $M_j^O(z)$ ablehnt, was der Voraussetzung widerspricht.

    Wir zeigen dass $v$ auch $t'$-valide ist:
    V1, V2, V5, V7 sind sofort erfüllt nach Definition von $T$ als Teilmenge von $O$ bzw. übereinstimmend mit $O$ auf Wörtern der Länge $\neq e(\cdot)$.
    Da $v\sqsupsetneq w_{s-1}$, sind auch V4 und V6 erfüllt, außer der neue V3-Fall von $t'(\tau_j^2)=0$.

    Aber auch hier erfüllen wir entsprechende Instanz von V3, da ja $M_j^v(z)$ definitiv ablehnt.
\end{proof}

\begin{claim}
    Sei $M_j$ eine totale Maschine, d.h. $L(M_j^O)=\Sigma^*$. Dann existiert eine Funktion $g\in \FP^O$ sodass $g(x)$ einen akzeptierenden Rechenweg von $M^O_j(x)$ ausgibt. Damit gilt nach Definition die Hypothese $Q$ relativ zu $O$.
\end{claim}
\begin{proof}[Skizze.]
    Es reicht aus, dass $g\in\FP^O$ nur Wörter hinreichender Länge verarbeiten muss.
    Sei $n$ hinreichend groß, sodass diese vorige Behauptung 6 erfüllt ist.
    Damit gilt: wenn $T\subseteq O$ mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern der Länge $\leq n$ übereinstimmt, dann $L(M_j^T)=\Sigma^*$.

    Sei also nun ein solches $x$ gegeben. 
    Wir werden obige Eigenschaft ausnutzen und iterativ eine Menge $D\subseteq O$ an Orakelwörtern der Länge $e(\cdot)$ aufbauen, welche für die Berechnung $M_j^O(z)$ relevant ist, bis wir alle solchen relevanten Wörter gefunden haben.
    Wir starten hierbei mit der Menge aller Orakelwörter in $O$, welche Länge $\leq n$  und Länge $=e(\cdot)$ haben.
    Beob. dass damit $C\cup D$ mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern der Länge $\leq n$ übereinstimmt, also auch $L(M_j^{C\cup D})=\Sigma^*$.
    Da uns $D$ vorliegt, können wir sogar diese Orakelwerte in $M$ hineincodieren, sodass $\smash{M'^C_j(z)}$ äquivalent arbeitet. Und da $\smash{\P^C=\mathrm{PSPACE}^C}$, können wir in $\FP^O$ auch einen akzeptierenden Rechenweg von $M'^C_j(x)$ bestimmen.

    \noindent
    \SetKwFor{Loop}{repeat}{}{end}
    \begin{algorithm}[H]
        $D\gets \{ w\mid w\in O, |w|\leq n, \exists i.|w|=e(i)\}$\;
        \Loop{}{
            Sei $\alpha$ ein akzeptierender Rechenweg auf $M_j^{C\cup D}(x)$ und $Q$ die Menge an Orakelfragen\;
            \eIf{existiert eine Frage $q\in Q$ für die $q\in O-C$ aber $q\not\in D$}
            {
                $D\gets D \cup \{q\}$\;
            }
            {
                \Return{$\alpha$}
            }
        }
    \end{algorithm}

    Korrektheit: Beobachte zunächst die Invariante dass $D\subseteq O\cap \{ w \mid \exists i.|w|=e(i)\}$.
    Wie oben argumentiert gilt außerdem, dass $C\cup D$ mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern der Länge $\leq n$ übereinstimmt. Damit $L(M_j^{C\cup D})=\Sigma^*$ und insbesondere existiert dann auch ein akzeptierender Rechenweg auf $M_j^{C\cup D}(x)$, und Zeile 3 wohldefiniert.

    Terminiert nun der Algorithmus mit einem Rechenweg $\alpha$, wissen wir auch dass für alle Orakelfragen $q\in Q$ entweder $q\in C$ gilt oder $q\not\in O$ oder $q\in O, D$ gilt.
    Damit stimmt $C\cup D$ mit $O$ auf $Q$ überein, und auch $M_j^O(x)$ akzeptiert mit Rechenweg $\alpha$.

    Laufzeit: Wir zeigen dass der Algorithmus in polynomiell beschränkter deterministischer Zeit (abhängig von $|x|$) relativ zu $O$ arbeitet. 
    Wir wissen, dass für jede Orakelfrage $q\in Q$ gilt, dass $|q|\leq p_j(|x|)$.
    Zusammen mit o.g. Invariante gilt $D\subseteq O\cap \{w \mid \exists i.|w|=e(i)\leq p_j(|x|)\}$.
    Nach V2 gilt damit $\ell(D)\leq p_j(|x|)\cdot p_j(|x|)\cdot 2$, denn in den je $\leq p_j(|x|)$ Ebenen der Länge $e(i)\leq p_j(|x|)$ existieren höchstens zwei Wörter der Länge $e(i)\leq p_j(|x|)$.
    Damit folgt auch unmittelbar, dass der Algorithmus nach höchstens polynomiell vielen Iterationen terminiert.

    Zeile 3 kann damit auch in polynomiell beschränkter deterministischer Zeit berechnet werden. Wie oben skizziert kann der Rechenweg in deterministisch polynomieller Zeit abh. von $|x|$ und $\ell(D)$ relativ zu $C$ bestimmt werden.
    Nach Konstruktion ist leicht zu sehen, dass dieser Rechenweg dann auch relativ zu $O$ bestimmt werden kann.
\end{proof}

\clearpage

\subsection*{Orakel mit $\hDisjCoNP$ und $\hDisjNP$ und $\P=\UP$}
\setcounter{theorem}{0}

Sei $e(0)=2, e(i+1)=2^{2^{e(i)}}$. (Doppelt exponentiell!) Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmenge von $e(\mathbb N)$. (Ebenen $H_m$ gehören zur Zeugensprache bzgl. Disj(Co)NP-Maschinenpaar $M_a, M_b$.)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.
Definiere folgende Zeugensprachen:
\begin{gather*}
    A_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{für alle $x\in \Sigma^{n}$ gilt } x\in O \rightarrow \text{ $x$ endet mit $0$} \}\\
    B_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{für alle $x\in \Sigma^{n}$ gilt } x\in O \rightarrow \text{ $x$ endet mit $1$} \}\\
    D_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{es existiert ein $x\in \Sigma^{n}$ mit $x\in O$ und $x$ endet mit $0$} \}\\
    E_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{es existiert ein $x\in \Sigma^{n}$ mit $x\in O$ und $x$ endet mit $1$} \} \cup \overline{\{ z\in\Sigma^* \mid |z|=e(i) \text{ für ein $i$} \}}\\
\end{gather*}
Fakt: $|O\cap \Sigma^n|\geq 1$ für alle $n\in H_m \implies (A_m^O, B_m^O)\in\DisjCoNP$.\\
Fakt: $O\cap \Sigma^{n-1}0\neq\emptyset$ genau dann wenn  $O\cap \Sigma^{n-1}1=\emptyset$ für alle $n\in H_m \implies \overline{D_m^O}=E_m^O$ und $(D_m^O, E_m^O)\in\DisjNP$ und $D_m^O\in\NP\cap\coNP$.
\medskip

Idee: erreiche entweder dass $M_a$, $M_b$ nicht disjunkt ablehnen (Task $\tau^2_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^2_{a,b,r}$ für Transduktor $F_r$).
Ebenso, für $\hDisjNP$, erreiche entweder dass $M_a$, $M_b$ nicht disjunkt akzeptieren (Task $\tau^3_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^3_{a,b,r}$ für Transduktor $F_r$).

Gleichzeitig versuchen wir für möglichst viele $M_j$ erreichen, dass diese nicht kategorisch sind. (Task $\tau^1_j$)
%Dies hat in gewisser Weise Priorität über die o.g. Diagonalisierung.
Am Ende sind die verbleibenden totalen Maschinen $M^O_j$ sehr speziell, denn sie sind auch für gewisse Teilmengen von $O$ kategorisch.
In Kombination mit dem Fakt dass $\P^C=\mathrm{PSPACE}^C$ können wir relevante Wörter in $O-C$ errechnen und so einen akzeptierenden Weg von $M^O_j(x)$ ausgeben -- damit entscheiden wir $L(M^O_j)$ und haben also auch $\P=\UP$.
\medskip

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^2_{a,b}, \tau^3_{a,b}, \tau^1_j$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

Ein Orakel $w\in\Sigma^*$ ist $t$-valide wenn $t\in\mathcal T$ und folgendes gilt:
\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    %\item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2$.\\
    %    (Orakel $w$ ist dünn auf den Stufen der Länge $e(\cdot)$.)
    \item Wenn $t(\tau^1_j)=0$, dann existiert ein $z$ sodass $M_j^w(z)$ auf zwei Rechenwegen akzeptiert.\\
        ($M_j$ nicht kategorisch relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv ablehnen.\\
        (Wenn $t(\tau^2_{a,b})=0$, dann $(\overline{L(M_a)}, \overline{ L(M_b)})\not\in \DisjCoNP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^2_{a,b})=m$, dann gilt für alle $n\in H_m$: wenn $w$ für alle Wörter der Länge $n$ definiert ist, dann $|\Sigma^n\cap w|\geq 1$.\\
        (Wenn $0<t(\tau^2_{a,b})=m$, dann $(A_m,B_m)\in\DisjCoNP$.)
    \item Wenn $t(\tau^3_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv akzeptieren.\\
        (Wenn $t(\tau^3_{a,b})=0$, dann $({L(M_a)}, { L(M_b)})\not\in \DisjNP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^3_{a,b})=m$, dann gilt für alle $n\in H_m$: wenn $w$ für alle Wörter der Länge $n$ definiert ist, dann entweder $|\Sigma^{n-1}0\cap w|=0$ oder $|\Sigma^{n-1}1\cap w|=0$ aber nicht beides.\\
        (Wenn $0<t(\tau^3_{a,b})=m$, dann $(D_m,E_m)\in\DisjNP$.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^2_{a,b,r}$ immer nach $\tau^2_{a,b}$, sowie $\tau^3_{a,b,r}$ immer nach $\tau^3_{a,b}$ kommt.
%Wir sagen dass ein Task $\tau$ \emph{priorisierter} als Task $\tau'$ ist, wenn $\tau$ in $T$ vor $\tau'$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

%Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun die Tasks $\{\tau_{(1)}, \tau_{(2)}, \dots, \tau_{(s)}\}$ behandelt -- $\tau^{(s)}$ kommt dazu. Je nach Typ von Task $\tau^{(s)}$ führen wir nun Folgendes durch:
Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_j$: Setze $t'=t_{s-1}\cup\{\tau^1_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^2_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^2_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^2_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^2_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^2_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in A_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ akzeptiert definitiv relativ zu $w_s$.
            \item $0^n\in B_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ akzeptiert definitiv relativ zu $w_s$.
        \end{itemize} (Das ist möglich nach Behauptung 2.)

    \item $\tau^3_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^3_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^3_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^3_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^3_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^3_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in D_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ lehnt definitiv relativ zu $w_s$ ab.
            \item $0^n\in E_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ lehnt definitiv relativ zu $w_s$ ab.
        \end{itemize} (Das ist möglich nach Behauptung 2.)
\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $b\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^2_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^2_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}
\begin{proof}[Skizze.]
    Direkter Beweis. %Sei $\hat{s}$ die Stufe, in der $\tau^1_{a,b}$ bearbeitet wurde. Beobachte dass $t_{s-1}$ auch $\hat{s}-1$-valide ist.
    Erweitere durch Beauptung 1 das Orakel $w_{s-1}$ so weit zu $u$, dass genau alle Wörter der Länge $<n=e(i)\in H_m$ definiert sind, wobei das $i$ hinreichend groß gewählt wird. Sei $u(X), X\subseteq \Sigma^n$ das Orakel was entsteht, wenn die Stufe $e(i)$ mit genau den Wörtern aus $X$ gefüllt wird, bzw. $u(X)=u\cup X\cup C$.

    Sei $\hat{s}$ die Stufe, in der $\tau^2_{a,b}$ bearbeitet wurde.
    Da nach Behauptung 1 $u$ auch $t_{s-1}$ valide ist, ist es auch $t_{\hat{s}-1}$-valide.
    Es ist sogar $u(\emptyset)$ auch $t_{\hat{s}-1}$-valide, denn $t_{\hat{s}-1}(\tau^2_{a,b})$ ist undefiniert.

    Sei $y=T_r(0^n)$.
    Wir wissen, dass eine der Maschinen $M_a(y)$ oder $M_b(y)$ relativ zu $u(\emptyset)$ akzeptieren muss.
    Andernfalls wäre $u(\emptyset)$ ein geeignetes Orakel zur Zerstörung des Paars $M_a$, $M_b$ in der Bearbeitung von Task $\tau^2_{a,b}$ und wir hätten $t_{s-1}(\tau^2_{a,b})=0$.

    Ohne Beschränkung akzeptiert also $M_a(y)^{u(\emptyset)}$ auf einem Rechenweg mit polynomiell vielen Orakelfragen $Q$.
    Wähle ein $\alpha\in \Sigma^n-Q$ was mit $0$ endet. Dann akzeptiert auch $M_a(y)^{u(\{\alpha\})}$ auf dem gleichen Rechenweg und $0^n\in A_m^{u(\{\alpha\})}$. Es ist leicht zu sehen, dass $u(\{\alpha\})$ auch $t_{s}$-valide ist.
\end{proof}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^3_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^3_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}

Damit ist die Konstruktion möglich. Sei $O=\lim_{s\to\infty} w_s$.

\begin{claim}
    Kein Paar aus $\DisjCoNP^O$ ist $\leqmpp$-vollständig.
\end{claim}
\begin{claim}
    Kein Paar aus $\DisjNP^O$ ist $\leqmpp$-hart für $\NP^O\cap\coNP^O$.
    Damit gilt im Übrigen dass keine Sprache aus $\NP^O\cap\coNP^O$ auch $\leqmp$-vollständig ist.
\end{claim}

Wir wollen nun zeigen, dass wir UP-Sprachen in P entscheiden können. Sei im Folgenden $M_j$ eine kategorische Maschine relativ zu $O$. Um $x\in L(M_j)$ zu entscheiden nutzen wir aus, dass $\mathrm{PSPACE}^C=\P^C$, um so iterativ eine Menge $D\subseteq O$ an Orakelwörtern der Länge $e(\cdot)$ aufbauen, welche für die Berechnung $M_j(x)$ relevant ist, bis wir nach einigen Iterationen alle solchen relevanten Wörter gefunden haben. 
Wir beschränken uns im Folgenden auf Eingaben hinreichender Länge, sodass es für $x$ ein eindeutiges $i$ gibt, sodass
\[ e(i-1) \leq \log(|x|) < e(i), \quad 2p_j(|x|)< 2^{e(i)-1} < e(i+1).\tag{\ast} \]

Wir definieren Folgendes: %Seien $W,W'\subseteq \{q\in \Sigma^*\mid \exists i.|q|=e(i)\}$ zwei disjunkte Mengen mit $W\subseteq O,$ $W'\subseteq \overline{O}$.
Eine \emph{$(U, W, W')$ respektierende akzeptierende Berechnung $P$ von $M_j$ auf Eingabe $x$} ist ein akzeptierender Rechenweg $P$ von $M_j(x)$ relativ zu einem Orakel $v\subseteq\Sigma^*$, wobei 
\[ U, W,W'\subseteq \Sigma^{e(i)}, \quad W\subseteq O, \quad W'\subseteq\overline{O} \]
und für $v$ gilt:
\begin{enumerate}[noitemsep,label=\arabic*.]
    \item $v$ ist definiert für genau die Wörter der Länge $\leq p_j(|x|)$.
    \item $v(q)=O(q)$ für alle $q$ mit $|q|\neq  e(i)$, wobei hier das $i$ diejenige eindeutige Zahl ist für die obigen Ungleichungen ($\ast$) bzgl. $|x|$ gelten.
    \item $v(q)=1$ für alle $q$ mit $q\in W$.
    \item $v(q)=0$ für alle $q$ mit $q\in W'$.
    \item $v(q)=1 \implies q\in U$ für alle $q\in\Sigma^{e(i)}$. [$v$ enthält auf Ebene $e(i)$ nur Wörter, die auch in $U$ vorkommen.]
\end{enumerate}

Sei $P^\mathrm{all}$ die Menge der Orakelfragen auf $P$, und sei $P^\mathrm{yes}=P^\mathrm{all}\cap v$, $P^\mathrm{no}=P^\mathrm{all}\cap \overline{v}$.
Beob. dass für festes $U=\Sigma^{e(i)}$ (bzw. $U=\Sigma^{e(i)-1}0$, $U=\Sigma^{e(i)-1}1$) wegen $\mathrm{PSPACE}^C=\P^C$ das Ermitteln einer $(U, W, W')$ respektierenden akzeptierenden Berechnung einfach in Polynomialzeit (abh. von $|x|$ und $\ell(W),\ell(W')$) relativ zu $O$ möglich ist: insbesondere stimmt $O$ mit $C$ auf Wörtern der Länge $\neq e(\cdot)$ überein, und alle anderen Wörter der Länge $e(0), e(1), \dots, e(i-1)$ können vorab mit Queries an $O$ in Polynomialzeit erfragt werden.
Entsprechende Belegungen von $v$ für Wörter der Länge $e(i)$ können z.B. in PSPACE enumeriert werden.

Sei $s$ die Stufe bei der $\tau^1_j$ betrachtet wurde.
Zusätzlich zur Einschränkung $(\ast)$ diskutieren wir ab jetzt nur noch Eingaben, für welche das Orakel $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert.
Sei $M=\bigcup \{ H_m \mid t_s(\tau^3_{a,b})=m>0 \}$ eine Menge an Ebenen, welche einer DisjNP-Zeugensprache \emph{in Stufe $s$} zugewiesen ist.
Beob. dass $M\in \P$, denn es sind höchstens endlich viele $H_m$ in der Vereinigung, welche je in $\P$ entscheidbar sind.

[ TODO was soll die Menge $U$? ]


\begin{claim}
    %Sei $M_j$ eine kategorische Maschine relativ zu $O$.
    %Ab hinreichend großer Eingabelänge $n_0$ gilt für alle Eingaben $x$, $|x|\geq n_0$, alle $W, W'$:
    Seien $P_1, P_2$ zwei $(U, W, W')$ respektierenden akzeptierenden Berechnungen von $M_j$ auf Eingabe $x$.
    %Folgende Aussage gilt uneingeschränkt falls $e(i)\not\in M$, und sonst falls $e(i)\in M$ dann mit der Einschränkung dass $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$ gelten muss.
    Folgende Aussage gilt jeweils bezüglich dieser beiden Einschränkungen auf $U$:
    \begin{itemize}[nosep]
        \item $e(i)\in M$ und $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$,
        \item $e(i)\not\in M$ und $U=\Sigma^{e(i)}$.
    \end{itemize}

    Wenn $P^\mathrm{all}_1$ und $P^\mathrm{all}_2$ beide je eine (nicht notwendigerweise identische) Orakelfrage $q_1, q_2$ der Länge $e(i)$ enthalten, welche in $U-(W\cup W')$ liegt, dann haben diese zwei Berechnungen eine (identische) Orakelfrage $q$ der Länge $e(i)$ gemeinsam, welche nicht in $W\cup W'$ liegt.
\end{claim}
\begin{proof}[Skizze.]
    Wir beweisen zunächst den ersten Fall.
    Angenommen, dies gilt nicht, also sei $x$ sowie $U,W,W'\subseteq \Sigma^{e(i)}$, $W\subseteq O$, $W'\subseteq\overline{O}$ gegeben.
    Seien außerdem $P_1$ und $P_2$ zwei $(U, W, W')$ respektierenden akzeptierenden Berechnungen von $M_j$ auf Eingabe $x$,
    welche je eine Orakelfrage der Länge $e(i)$ enthalten, welche nicht in $W\cup W'$ liegt,
    aber keine Orakelfrage aus $\Sigma^{e(i)}-(W\cup W')$ gemeinsam haben.
    Dann sind schon $P_1$ und $P_2$ verschieden.
    Seien ferner $v_1, v_2$ die zugehörigen Orakel, also für welche $M_j(x)$ akzeptiert und Eigenschaften~1--4 erfüllen.

    Wir werden nun ein $t_{s-1}$-valides Orakel $u\sqsupsetneq w_{s-1}$ konstruieren welches mit $v_1$ auf $P^\mathrm{all}_1$ übereinstimmt, und welches mit $v_2$ auf $P^\mathrm{all}_2$ übereinstimmt.
    Außerdem wird es auf Ebene $\Sigma^{e(i)}$ nur Wörter aus $U$ enthalten, woraus wir zeigen können dass $u$ sogar ein geeignetes Orakel zur Zerstörung der UP-Machine in der Bearbeitung von Task $\tau^2_{j}$ in Stufe $s$ ist, ohne Beschränkungen bzgl. DisjNP-Zeugensprachen zu verletzen. Insbesondere akzeptiert dann auch $M_j^O(x)$ auf den zwei Rechenwegen $P_1$, $P_2$, was der Voraussetzung widerspricht.

    %Setze $D=(\Sigma^{e(i)}\cap P^\mathrm{yes}_1) \cup (\Sigma^{e(i)}\cap P^\mathrm{yes}_2) \cup \{\alpha\}$ wobei $\alpha\in \Sigma^{e(i)}-(P^\mathrm{all}_1\cup P^\mathrm{all}_2)$.
    Sei $Y=(P^\mathrm{yes}_1\cup P^\mathrm{yes}_2)\cap\Sigma^{e(i)}$, und $N=(P^\mathrm{no}_1\cup P^\mathrm{no}_2)\cap\Sigma^{e(i)}$.
    Wir zeigen $Y\cap N = \emptyset$. (Das soll uns helfen nachzuweisen, dass ein geeignetes $u$ existieren kann.)
    Nehme an es gibt ein $q\in Y\cap N$ der Länge $e(i)$.
    \begin{itemize}[noitemsep]
        \item Ist $q\not\in U$ dann schon sofort dass $q\not\in P^\mathrm{yes}, P^\mathrm{yes}_2$ was $q\in N$ widerspricht.
        \item Ist $q\in W$ dann gilt schon sofort dass $q\not\in P^\mathrm{no}, P^\mathrm{no}_2$ was $q\in N$ widerspricht.
        \item Ist $q\in W'$ dann gilt schon sofort dass $q\not\in P^\mathrm{yes}, P^\mathrm{yes}_2$ was $q\in Y$ widerspricht.
        \item Andernfalls ist $q\in U-( W\cup W')$, dann gilt $q\in P^\mathrm{yes}_1\cap P^\mathrm{no}_2$ oder $q\in P^\mathrm{yes}_2\cap P^\mathrm{no}_1$.
            In beiden Fällen hätten wir aber, dass $P_1$ und $P_2$ eine Orakelfrage der Länge $e(i)$ teilen, welche in $U-(W\cup W')$ liegt. Das widerspricht der urpsrünglichen Annahme.
    \end{itemize}

    Es gilt also $Y\cap N =\emptyset$. Wir beobachten außerdem dass $Y\subseteq U$ nach Punkt~5 der Definition gilt. Wähle ein $\alpha\in U-N$. Dieses existiert da $|N|\leq 2p_j(|x|)<2^{e(i)-1} = |U|$ nach ($\ast$).
    Sei nun $u$ das Orakel was genau alle Wörter der Länge $\leq p_j(|x|)$ definiert sind, und
    \[ u(z)= \begin{cases} O(z) & \text{falls $|z|\neq e(i)$}\\ 1 & \text{falls $z=\alpha$} \\1 & \text{falls $z\in Y$} \\ 0&\text{sonst,} \end{cases}
    \]
    also wie $O^{\leq p_j(|x|)}$ aufgebaut ist, außer dass die Ebene $e(i)$ mit genau den Wörtern aus $Y$ gefüllt wird. bzw. $u\cap\Sigma^{e(i)} = Y\cup \{\alpha\}$.
    Es ist leicht zu sehen dass $u\sqsupsetneq w_{s-1}$.
    Beob. dass 
    \[ u\cap N = \Sigma^{e(i)}\cap u \cap N = (Y\cup \{\alpha\}) \cap N= Y\cap N=\emptyset.\]

    Das Orakel $u$ stimmt mit $v_1$ auf $P^\mathrm{all}_1$ überein. Sei hierfür $q\in P^\mathrm{all}_1$.
    Ist $|q|\neq e(i)$, dann gilt schon nach Definition $v_1(q)=O(q)=u(q)$. Sei daher im Folgenden $|q|=e(i)$.
    Ist $q\in P^\mathrm{yes}_1$, dann auch $q\in v_1$. Außerdem dann auch $q\in Y$, daher $q\in u$.
    Ansonsten ist $q\in P^\mathrm{no}_1$, dann auch $q\not\in v_1$. Außerdem dann auch $q\in N$, daher $q\not\in u$ nach obiger Beobachtung.
    
    Auf symmetrische Weise stimmt $u$ mit $v_2$ auf $P^\mathrm{all}_2$ überein.
    Wir zeigen nun dass $u$ auch $t_{s-1}$-valide ist.
    Nach obiger Argumentation wäre dann $u$ eine geeignete Erweiterung von $w_{s-1}$ für welche $M_j^O(x)$ nicht mehr kategorisch ist, was der Wahl von $M_j^O(x)$ widerspricht.

    Nach Konstruktion ist V1 erfüllt; V2, V3, V5 sind wegen $u\sqsupsetneq w_{s-1}$ erfüllt. Angenommen V3 ist verletzt. Dies kann nur an der Ebene $e(i)$ liegen. Aber dann wäre $e(i)\in H_{m}$ mit $m=t_{s-1}(\tau^2_{a,b})$ und $e(i) \not\in M$; Widerspruch zur Einschränkung.

    Angenommen V5 ist verletzt.
    Wieder kann das nur an der Ebene $e(i)$ liegen.
    Aber hier gilt $u\cap\Sigma^{e(i)}=Y\cap\{\alpha\}\subseteq U$ und nach Wahl von $U$ ist damit $|\Sigma^{n-1}0\cap w|=0$ oder $|\Sigma^{n-1}1\cap w|=0$ aber nicht beides, ist ja $\alpha\in u\cap\Sigma^{e(i)}$.
    \medskip

    Wir beweisen jetzt den zweiten Fall. Hier läuft die Konstruktion von $u$ identisch,
    und wieder gilt dass $u$ mit $v_1$ auf $P^\mathrm{all}_1$ übereinstimmt, sowie $u$ mit $v_2$ auf $P^\mathrm{all}_2$ übereinstimmt.
    Nach obiger Argumentation wäre dann $u$ eine geeignete Erweiterung von $w_{s-1}$ für welche $M_j^O(x)$ nicht mehr kategorisch ist, was der Wahl von $M_j^O(x)$ widerspricht.

    Nach Konstruktion ist V1 erfüllt; V2, V3, V5 sind wegen $u\sqsupsetneq w_{s-1}$ erfüllt. Angenommen V5 ist verletzt. Dies kann nur an der Ebene $e(i)$ liegen. Aber dann wäre $e(i)\in H_{m}$ mit $m=t_{s-1}(\tau^3_{a,b})$ und $e(i)\in M$; Widerspruch zur Einschränkung.

    Angenommen V3 ist verletzt.
    Wieder kann das nur an der Ebene $e(i)$ liegen.
    Aber hier gilt $u\cap\Sigma^{e(i)}=Y\cap\{\alpha\}$ und nach Wahl von $U$ ist damit $|\Sigma^{n}\cap w|>0$, ist ja $\alpha\in u\cap\Sigma^{e(i)}$.
\end{proof}

\begin{claim}
    $\P=\UP$ relativ zu $O$.
\end{claim}
\begin{proof}[Skizze.]
    Sei $S\in \UP^O$. Es existiert nach Definition eine Maschine $M_j$ mit $L(M_j)^O=S$.
    Wir zeigen für hinreichend lange $x$ wie man $x\in S$ in Polyonmialzeit relativ zu $O$ entscheiden kann.
    
    Sei im Folgenden $x$ hinreichend lange wie oben diskutiert, also für dieses $(\ast)$ mit eindeutigem $i$ gilt, sowie $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert, wobei $s$ die Stufe ist, bei der $\tau^2_j$ betrachtet wurde.
    Sei wieder $M=\bigcup \{ H_m \mid t_s(\tau^3_{a,b})=m>0 \}$.
    Für diese Maschine $M_j$ und eine solche Eingabe $x$ gilt dann Behauptung~6.

    Wir werden diese Eigenschaft ausnutzen und iterativ Mengen $W, W'$ aufbauen, welche für die Berechnung $M_j^O(x)$ relevant ist, bis wir alle solchen relevanten Wörter gefunden haben.
    Betrachte dafür zunächst folgende Subroutine:

    \noindent%
    \SetKwProg{Fn}{Function}{:}{}%
    \SetKw{Assert}{assert}%
    \begin{algorithm}[H]
        \Fn{Search($U$)}{
            \Assert{$e(i)\in M\implies (U=\Sigma^{e(i)-1}0 \lor U=\Sigma^{e(i)-1}1)$}\;
        $W\gets\emptyset,\, W'\gets\emptyset$\;
        \For{$k$ von $0$ bis $p_j(|x|)+1$}{
            $P\gets$ eine $(U, W, W')$ respektierende akzeptierende Berechnung $P$ von $M_j$ auf $x$ mit $|P^\mathrm{all}\cap\Sigma^{e(i)}-(W\cup W')|$ minimal, oder $\bot$ falls keine existiert\;
            \If{$P=\bot$}
            {
                \Return{„$x\not\in S$“}
            }
            \If{alle $q\in P^\mathrm{all}$ mit $|q|=e(i)$ sind in $W\cup W'$}{
                \Return{„$x\in S$“}
            }
            \ForEach{$q\in P^\mathrm{all}$ mit $|q|=e(i)$}
            {
                \lIf{$q\in O$}{$W\gets W\cup\{q\}$}
                \lIf{$q\not\in O$}{$W'\gets W'\cup\{q\}$}
            }
            %\If{$P$ ist immer noch eine $(W, W')$ respektierende akzeptierende Berechnung}
            %{
                %\Return{„$x\in S$“}
            %}
        }
        \Return{„$x\not\in S$“}
        }
    \end{algorithm}
    Es ist leicht zu sehen dass der Algorithmus eine polynomielle Laufzeitschranke einhält.
    Wir zeigen nun folgende Aussage: Wenn die Assertion in Z.~2 zutrifft dann macht der Algorithmus keinen falsch-positiv-Fehler. Falls zusätzlich $O\cap \Sigma^{e(i)}\subseteq U$, dann macht der Algorithmus keinen falsch-negativ-Fehler.

    Wir beobachten die Invariante dass $W\subseteq O\cap\Sigma^{e(i)}$ und $W'\subseteq \overline{O}\cap\Sigma^{e(i)}$. 
    Terminiert also der Algorithmus in Z.~10 mit „$x\in S$“ dann ist auch $x\in S$: Sei $v$ das Orakel der $(U, W, W')$ respektierenden akzeptierenden Berechnung $P$ von $M_j(x)$. Es ist nun leicht zu sehen dass $v$ und $O$ auf $P^\mathrm{all}$ übereinstimmen. Damit gilt auch dass $M_j^O(x)$ akzeptiert und damit $x\in S$.
    Der Algorithmus macht also schon mal keinen falsch-positiv-Fehler.

    Es verbleibt zu zeigen dass wenn $x\in S$ und  $O\cap \Sigma^{e(i)}\subseteq U$ dann der Algorithmus auch in Z.~10 mit „$x\in S$“ terminiert, also keinen falsch-negativ-Fehler macht.
    Sei hierfür $P^*$ der längste akzeptierende Rechenweg von $M_j^O(x)$.
    Beob. dass mit der o.\,g. Invariante sowie der Bedingung $O\cap\Sigma^{e(i)}\subseteq U$ gilt, dass $P^*$ auch immer ein $(U,W,W')$ respektierender akzeptierender Rechenweg ist.
    Damit ist die Bedingung in Z.~6 nie erfüllt.
    %Damit ist auch die Bedingugn in Z.~2 immer erfüllt und der Algorithmus terminiert sicher nicht ablehnend in Z.~12.
    Wir zeigen nun noch, dass nach $\leq p_j(|x|)+1$ vielen Iterationen auch die Bedingung in Z.~9 erfüllt ist.
    Hierfür zeigen wir, dass $|P^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|$ in jeder Iteration um $\geq 1$ abnimmt. Da $|P^{*\mathrm{all}}|\leq p_j(|x|)$ ist nach $\leq p_j(|x|)+1$ vielen Iterationen $|P^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|=0$.
    Nach $\leq p_j(|x|)+1$ vielen Iterationen wird also in Z.~5 eine Berechnung $P$ ausgewählt, bei der alle $q\in P^{\mathrm{all}}$ mit $|q|=e(i)$ in $W\cup W'$ liegen. Dann ist die Bedingung in Z.~10 erfüllt und der Algorithmus terminiert akzeptierend.

    Steht der Algorithmus in Z.~12, dann gilt sowohl für das ausgewählte $P$, als auch für $P^*$ dass beide je eine (nicht notwendigerweise identische) Orakelfrage der Länge $e(i)$ enthalten, welche nicht in $W\cup W'$ liegt. (Andernfalls  wäre $P$ in Z.~5 anders ausgewählt worden.)

    Sowohl $P$ als auch $P^*$ sind $(U, W, W')$ respektierende akzeptierende Rechenwege. Nachdem die Assertion gilt, ist Behauptung~4 anwendbar. Also haben diese zwei Berechnungen eine identische Orakelfrage $q\in P^\mathrm{all}\cap P^{*\mathrm{all}}\cap \Sigma^{e(i)}$ gemeinsam, welche in $U-(W\cup W')$ liegt.
    Diese wird in den Zz.~12--15 irgendwann der Menge $W\cup W'$ hinzugefügt.
    Damit nimmt auch $|P^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|$ um $\geq 1$ ab, wie behauptet.
    \medskip

    Betrachte nun folgenden Entscheidungsalgorithmus für $S=L(M_j^O)$.

    \noindent
    \begin{algorithm}[H]
        \setcounter{AlgoLine}{17}
        \eIf{$e(i)\in M$}
        {
            \uIf{{Search}($\,\Sigma^{e(i-1)0}$) = „$x\in S$“}
            {
                \Return{„$x\in S$“}
            }
            \uElseIf{{Search}($\,\Sigma^{e(i-1)1}$) = „$x\in S$“}
            {
                \Return{„$x\in S$“}
            }
            \Else{
                \Return{„$x\not\in S$“}
            }
        }
        {
            \Return \emph{Search}($\Sigma^{e(i)}$)\;
        }
        \medskip
    \end{algorithm}

    Es ist leicht zu überprüfen dass in allen Fällen die Subroutine so ausgeführt wird dass die Assertion immer erfüllt ist.
    Ebenso ist leicht zu sehen, dass dieser Algorithmus in Polynomialzeit läuft.

    Wir überprüfen nun Korrektheit in zwei Fällen.
    Im Fall $e(i)\not\in M$ rufen wir die Subroutine mit $U=\Sigma^{e(i)}$ auf, und nach obiger Argumentation macht \emph{Search} sowohl keinen falsch-positiv- also auch keinen falsch-negativ-Fehler.
    Der zurückgegebene Wert ist also korrekt.

    Im Fall $e(i)\in M$ bekommen wir in beiden Aufrufen von \emph{Search} zumindest keinen falsch-positiven Fehler. Wenn also in Zz.~20 oder 22 mit „$x\in S$“ terminiert wird, dann war auch $x\in S$.
    Fener wissen wir wegen $e(i)\in M$ und V6 dass entweder $O\cap\Sigma^{e(i)}\subseteq \Sigma^{e(i)-1}0$ oder $O\cap\Sigma^{e(i)}\subseteq \Sigma^{e(i)-1}1$.
    Wenn also $x\in S$, dann macht einer der Aufrufe von \emph{Search} in Zz.~19 oder 21 keinen falsch-negativ-Fehler und die zugehörige If-Bedingung wird positiv ausfallen, und der Algorithmus terminiert mit „$x\in S$“.
\end{proof}

\clearpage
\subsection*{Orakelkonstruktion $\hDisjNP$, $\P=\UP$, und $Q$}
\setcounter{theorem}{0}

Sei $e(0)=2, e(i+1)=2^{2^{e(i)}}$. Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmenge von $e(\mathbb N)$. (Ebenen $H_m$ gehören zur Zeugensprache bzgl. DisjNP-Maschinenpaar $M_a, M_b$.)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.
Definiere folgende Zeugensprachen:
        \begin{gather*}
            A_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O \text{ und $x$ endet mit $0$} \}\\
            B_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O \text{ und $x$ endet mit $1$} \}\\
        \end{gather*}
        Fakt: wenn $|O\cap \Sigma^{n-1}0|=0$ oder $|O\cap \Sigma^{n-1}1|=0$ für alle $n\in H_m$, dann $(A_m^O, B_m^O)\in\DisjNP^O$.\\
\medskip

Idee: erreiche entweder dass $M_a$, $M_b$ nicht disjunkt akzeptieren (Task $\tau^1_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^1_{a,b,r}$ für Transduktor $F_r$).

Gleichzeitig versuchen wir für möglichst viele $M_j$ erreichen, dass diese (a) nicht total sind (Task $\tau^2_j$), und diese (b) nicht kategorisch sind (Task $\tau^3_j$).
%Dies hat in gewisser Weise Priorität über die o.g. Diagonalisierung.
Am Ende sind die verbleibenden totalen Maschinen $M^O_j$ sehr speziell, denn sie sind auch für gewisse Teilmengen von $O$ total.
In Kombination mit dem Fakt dass $\P^C=\mathrm{PSPACE}^C$ können wir relevante Wörter in $O-C$ errechnen und so einen akzeptierenden Weg von $M^O_j(x)$ ausgeben -- damit erzielen wir $Q$ bzw. $\P=\UP$.
Besonders aufgepasst muss hier auf den $\UP$-Entscheidungsalgorithmus: im Korrektheitsbeweis müssen wir sicherstellen, dass höchstens polynomiell viele Wörter in eine Ebene gesetzt werden. Das ist etwas schwieriger, weil üblicherweise im Beweis bis zu $2\cdot p_j(|x|)$ Wörter eingesetzt werden (Menge $Y$); und dieses Polynom ist kann nicht von der Eingabelänge allein beschränkt werden da $j$ beliebig.

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^1_{a,b}, \tau^2_j$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    \item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2^{c}$ mit $c=|\{j\mid t(\tau^2_j)=0 \}|$.
        Ferner definiert $w$ alle Wörter der Länge $e(c)$.\\
        (Auf den Ebenen der Länge $e(\cdot)$ sind exponeniell so viele Wörter wie Tasks $\tau^2_j$ „negativ“ behandelt werden. Wir werden sehen dass mit dieser Eigenschaft das Orakel dünn auf Ebenen der Länge $e(\cdot)$ ist.)
    \item Wenn $t(\tau^1_j)=0$, dann existiert ein $z$ sodass $M_j^w(z)$ definitiv ablehnt.\\
        ($L(M_j)\neq \Sigma^*$ relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_j)=0$, dann existiert ein $z$ sodass $M_j^w(z)$ definitiv auf zwei Rechenwegen akzeptiert.\\
        ($M_j$ nicht kategorisch relativ zum finalen Orakel.)
    \item Wenn $t(\tau^3_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv akzeptieren.\\
        (Wenn $t(\tau^3_{a,b})=0$, dann $L(M_a)\cap L(M_b)\neq \emptyset$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^3_{a,b})=m$, dann gilt für alle $n\in H_m$ dass $|\Sigma^{n-1}0\cap w|=0$ oder $|\Sigma^{n-1}1\cap w|=0$.\\
        (Wenn $0<t(\tau^3_{a,b})=m$, dann $(A_m,B_m)\in\DisjNP$.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^3_{a,b,r}$ immer nach $\tau^3_{a,b}$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_j$: Setze $t'=t_{s-1}\cup\{\tau^1_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^2_j$: Setze $t'=t_{s-1}\cup\{\tau^2_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^3_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^3_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^3_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^3_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^2_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in A_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
            \item $0^n\in B_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
        \end{itemize} (Das ist möglich nach Behauptung 2.)
\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $b\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^3_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^3_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}
\begin{proof}[Hinweis.]
    Unterschied ist V2. Trotzdem dürfen wir zwei Wörter in die Ebene einer Stufe $e(i)$ einsetzen, und verletzen dabei V2 nicht.
\end{proof}

Damit ist die Konstruktion möglich. Sei $O=\lim_{s\to\infty} w_s$.

\begin{claim}
    Kein Paar aus $\DisjNP^O$ ist $\leqmpp$-hart für $\DisjUP$.
\end{claim}


\begin{claim}
    Sei $M_j$ eine totale Maschine, d.h. $L(M^O)=\Sigma^*$.
    Es existiert eine Länge $n$ mit folgender Eigenschaft: 
    falls $T\subseteq O$ mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern $\leq n$ übereinstimmt, dann $L(M_j^T)=\Sigma^*$.
\end{claim}

\begin{claim}
    Das Orakel $O$ ist dünn auf den Ebenen der Länge $e(i)$. Insbesondere gilt $|O\cap \Sigma^{e(i)}|\leq e(i)$ für alle $i$.
\end{claim}
\begin{proof}[Skizze.]
    Sein eine Ebene $e(i)$ beliebig.
    Sei $c_k=|\{j\mid t_{k}(\tau^2_j)=0 \}|$.
    Nachdem in der Folge $c_0, c_1, c_2, \dots$ die Terme immer um $\leq 1$ ansteigen, existiert ein kleinstes $s$ sodass $c_s=i$.
    Damit hat nach V2 das Orakel $w_s\sqsubsetneq O$ alle Wörter der Länge $c(i)$ definiert.
    Ferner gilt $|w_s\cap\Sigma^{e(i)}|\leq 2^{c_s}$.
    Also haben wir $|O\cap\Sigma^{e(i)}|=|w_s\cap\Sigma^{e(i)}|\leq 2^{i}\leq e(i)$.
\end{proof}

\begin{claim}
    Sei $M_j$ eine totale Maschine, d.h. $L(M_j^O)=\Sigma^*$. Dann existiert eine Funktion $g\in \FP^O$ sodass $g(x)$ einen akzeptierenden Rechenweg von $M^O_j(x)$ ausgibt. Damit gilt nach Definition die Hypothese $Q$ relativ zu $O$.
\end{claim}
\begin{proof}[Hinweis.]
    Wie im vorigen Abschnitt. Analog gilt für die Menge an erfassten Orakelwörtern $D$ nach V2: $\ell(D) \leq p_j(|x|)\cdot p_j(|x|)\cdot p_j(|x|)$ denn in den je $\leq p_j(|x|)$ Ebenen der Länge $e(i)\leq p_j(|x|)$ existieren nach Behauptung 5 höchstens $e(i)\leq p_j(|x|)$ Wörter der Länge $e(i)\leq p_j(|x|)$.
    Damit folgt auch, dass der Algorithmus nach höchstens polynomiell vielen Iterationen terminiert.
\end{proof}

Um $\UP$-Sprache $S=L(M_j^O)$ in $\P$ zu entscheiden, gehen wir wie in vorigem Abschnitt vor.
Sei $s$ die Stufe bei der $\tau^1_j$ betrachtet wurde.
Sei $c=|\{j\mid t_{s-1}(\tau^2_j)=0|$.
Wir beschränken uns im Folgenden wieder auf Eingaben hinreichender Länge, sodass es für $x$ ein eindeutiges $i$ gibt, sodass
\[ e(c+1)\leq e(i), \quad \leq e(i-1) \leq \log(|x|), \quad 2p_j(|x|)< 2^{e(i)-1} < e(i+1).\tag{\ast} \]

Zusätzlich zur Einschränkung $(\ast)$ diskutieren wir ab jetzt nur noch Eingaben, für welche das Orakel $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert.
Sei $M=\bigcup \{ H_m \mid t_s(\tau^3_{a,b})=m>0 \}$ eine Menge an Ebenen, welche einer DisjNP-Zeugensprache \emph{in Stufe $s$} zugewiesen ist.

Wir verfeinern die Definition einer \emph{$(U, W, W')$ respektierende akzeptierende Berechnung $P$ von $M_j$ auf Eingabe $x$}, und verlangen zusätzlich
\begin{enumerate}[label={\arabic*.},nosep]
    \setcounter{enumi}{5}
    \item $|v\cap \Sigma^{e(i)}|\leq 2^{c}$.
\end{enumerate}

\begin{claim}
    %Sei $M_j$ eine kategorische Maschine relativ zu $O$.
    %Ab hinreichend großer Eingabelänge $n_0$ gilt für alle Eingaben $x$, $|x|\geq n_0$, alle $W, W'$:
    Seien $P_1, P_2$ zwei $(U, W, W')$ respektierenden akzeptierenden Berechnungen von $M_j$ auf Eingabe $x$.
    %Folgende Aussage gilt uneingeschränkt falls $e(i)\not\in M$, und sonst falls $e(i)\in M$ dann mit der Einschränkung dass $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$ gelten muss.
    Folgende Aussage gilt jeweils bezüglich dieser beiden Einschränkungen auf $U$:
    \begin{itemize}[nosep]
        \item $e(i)\in M$ und $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$,
        \item $e(i)\not\in M$ und $U=\Sigma^{e(i)}$.
    \end{itemize}

    Wenn $P^\mathrm{all}_1$ und $P^\mathrm{all}_2$ beide je eine (nicht notwendigerweise identische) Orakelfrage $q_1, q_2$ der Länge $e(i)$ enthalten, welche in $U-(W\cup W')$ liegt, dann haben diese zwei Berechnungen eine (identische) Orakelfrage $q$ der Länge $e(i)$ gemeinsam, welche nicht in $W\cup W'$ liegt.
\end{claim}
\begin{proof}[Skizze.]
    Wieder beweisen wir zunächst den ersten Fall, der zweite Fall ist noch leichter.
    Wir konstruieren ein $u$ ähnlich wie im originalen Beweis, verzichten aber auf das zusätzliche Wort $\alpha$, also sodass $u\cap\Sigma^{e(i)}=Y\subseteq U$.

    Es gilt dass $u$ mit $v_1$ auf $P^\mathrm{all}_1$ übereinstimmt, sowie $u$ mit $v_2$ auf $P^\mathrm{all}_2$ übereinstimmt.
    Sei $t'=t_{s-1}\cup \{\tau^2_j\mapsto 0\}$.
    Wir zeigen dass $u$ auch $t'$-valide ist
    Damit wäre $u$ dann eine geeignete Erweiterung von $w_{s-1}$ in Bearbeitung von Task $\tau^2_j$, für welche $M_j^O(x)$ nicht mehr kategorisch ist, was der Wahl von $M_j^O(x)$ widerspricht.

    Beob. dass $|P^\mathrm{yes}_1|,|P^\mathrm{yes}_2|\leq 2^{c}$,
    damit gilt $|u\cap\Sigma^{e(i)}|=|Y|\leq 2^{c+1}$.
    Aber nun gilt $c'=|\{j\mid t'(\tau^2_j)=0\}|=c+1$, damit $|u\cap\Sigma^{e(i)}|\leq 2^{c'}$.
    Außerdem definiert $u$ nach Konstruktion alle Wörter der Länge $e(i)\geq e(c+1)=e(c')$ und $u$ erfüllt damit auf jeden Fall V2.
    Es ist nun auch leicht zu sehen, dass V1, V3, V4, V5, V6 erfüllt sind, daher ist $u$ wie behauptet $t'$-valide.
    \medskip
\end{proof}

Damit gilt mit gleichem Verfahren

\begin{claim}
    $\P=\UP$ relativ zu $O$.
\end{claim}

\clearpage
\subsection*{Orakel mit $\hDisjCoNP$, $\hCON^N$ und alle Paare aus $\DisjNP$ sind $\P$-separierbar}
\setcounter{theorem}{0}

Sei $e(0)=2, e(i+1)=2^{2^{e(i)}}$. (Doppelt exponentiell!) Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmenge von $e(\mathbb N)$. (Ebenen $H_m$ gehören zur Zeugensprache bzgl. Disj(Co)NP-Maschinenpaar $M_a, M_b$.)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.
Definiere folgende Zeugensprachen:
\begin{gather*}
    A_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{für alle $x\in \Sigma^{n}$ gilt } x\in O \rightarrow \text{ $x$ endet mit $0$} \}\\
    B_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{für alle $x\in \Sigma^{n}$ gilt } x\in O \rightarrow \text{ $x$ endet mit $1$} \}\\
\end{gather*}
Fakt: $|O\cap \Sigma^n|\geq 1$ für alle $n\in H_m \implies (A_m^O, B_m^O)\in\DisjCoNP$.
\medskip

\medskip
Definiere die Orakel-ergänzte aussagenlogische Formel
\[ \theta_n = „\neg\mathtt{query}_n(x_1, \dots, x_n)“. \]
Die Forme $\theta_n$ ist polynomiell groß abh. von $n$, und $\theta_n\in\TAUT^O \iff O\cap\Sigma^n=\emptyset$.
Definiere das Beweissystem
\[ g_m(x) = \begin{cases} \theta_n & \text{wenn $x=0^n$ und $n\in H_m$} \\ \top & \text{sonst} \end{cases}. \]
Damit ist $\img(g_m)\subseteq \TAUT^O \iff \forall n\in H_m. O\cap\Sigma^n=\emptyset$. 

TODO
%Ferner gilt folgendes für Beweissystem $f^O$: existiert eine unendliche aufsteigende Folge $n_1, n_2, \ldots \in H_m$ sodass kein $f$-Beweis für $\theta_{n_i}$ der Länge $\leq |\theta_{n_i}|^{|\theta_{n_i}|}$ existiert, dann ist $f$ kein \emph{optimales} Beweissystem für $\TAUT^O$.
\medskip

Idee: erreiche entweder dass $M_a$, $M_b$ nicht disjunkt ablehnen (Task $\tau^2_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^2_{a,b,r}$ für Transduktor $F_r$).
Erreiche dass $T_r$ kein Beweissystem für $\TAUT$ ist (Task $\tau^3_{r}$), oder falls das nicht möglich ist, das zugehörige Zeugen-Beweissystem $g_m$ tatsächlich ein Beweissystem für eine Teilmenge von $\TAUT^O$ ist.

Gleichzeitig versuchen wir für möglichst viele Paare $M_a, M_b$ zu erreichen, dass diese nicht disjunkt akzeptieren. (Task $\tau^1_{a,b}$)
%Dies hat in gewisser Weise Priorität über die o.g. Diagonalisierung.
Am Ende sind die verbleibenden Maschinenpaare $M_a^O, M_b^O$ sehr speziell, denn sie sind auch für gewisse Teilmengen von $O$ kategorisch.
In Kombination mit dem Fakt dass $\P^C=\mathrm{PSPACE}^C$ können wir relevante Wörter in $O-C$ errechnen und so $L(M_a^O)$ von $L(M_b^O)$ trennen.
\medskip

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^1_{a,b}, \tau^2_{a,b}, \tau^3_i$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

Ein Orakel $w\in\Sigma^*$ ist $t$-valide wenn $t\in\mathcal T$ und folgendes gilt:
\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    %\item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2$.\\
    %    (Orakel $w$ ist dünn auf den Stufen der Länge $e(\cdot)$.)
    \item Wenn $t(\tau^1_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv akzeptieren.\\
        ($M_a, M_b$ nicht disjunkt relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv ablehnen.\\
        (Wenn $t(\tau^2_{a,b})=0$, dann $(\overline{L(M_a)}, \overline{ L(M_b)})\not\in \DisjCoNP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^2_{a,b})=m$, dann gilt für alle $n\in H_m$: wenn $w$ für alle Wörter der Länge $n$ definiert ist, dann $|\Sigma^n\cap w|\geq 1$.\\
        (Wenn $0<t(\tau^2_{a,b})=m$, dann $(A_m,B_m)\in\DisjCoNP$.)
    \item Wenn $t(\tau^3_{r})=0$, dann existiert ein $z$ sodass definitiv $T_r^w(z)=y$ und $y\not\in\TAUT^w$.\\
        ($T_r$ kein Beweissystem für TAUT relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^3_{r})=m$, dann gilt für alle $n\in H_m$: $|\Sigma^n\cap w|=0$.\\
        (Wenn $0<t(\tau^3_{r})=m$, dann $\img g_m \subseteq \TAUT^w$.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^2_{a,b,r}$ immer nach $\tau^2_{a,b}$ kommt.
%Wir sagen dass ein Task $\tau$ \emph{priorisierter} als Task $\tau'$ ist, wenn $\tau$ in $T$ vor $\tau'$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

%Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun die Tasks $\{\tau_{(1)}, \tau_{(2)}, \dots, \tau_{(s)}\}$ behandelt -- $\tau^{(s)}$ kommt dazu. Je nach Typ von Task $\tau^{(s)}$ führen wir nun Folgendes durch:
Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^1_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^2_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^2_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^2_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)

    \item $\tau^2_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^2_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in A_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ akzeptiert definitiv relativ zu $w_s$.
            \item $0^n\in B_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ akzeptiert definitiv relativ zu $w_s$.
        \end{itemize} (Das ist möglich nach Behauptung 2.)

    \item $\tau^3_{r}$: Setze $t'=t_{s-1}\cup\{\tau^3_{r}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. 

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^3_{r}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.)
\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $b\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^2_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^2_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}

Damit ist die Konstruktion möglich. Sei $O=\lim_{s\to\infty} w_s$.

\begin{claim}
    Kein Paar aus $\DisjCoNP^O$ ist $\leqmpp$-vollständig.
\end{claim}

\begin{claim}
    Es existiert kein optimales Beweissystem für $\TAUT^O$.
\end{claim}
\begin{proof}
    Angenommen es existiert ein optimales Beweissytem $T_r^O$ für $\TAUT^O$.
    Sei $s$ die Stufe in der $\tau^3_{r}$ bearbeitet wurde. Sei $n_0=|w_s|$.
    Wir haben $t_{s'}(\tau^3_{r})=m>0$ für alle $s'\geq s$, da andernfalls nach V5 ein $z$ existiert mit $T_r^O(z)=T_r^w(z)\not\in\TAUT^O$; Widerspruch zur Wahl als Beweissystem für $\TAUT^O$.

    Ferner ist $g_m$ ein Beweissystem mit $\img(g_m)\subseteq \TAUT^O$, denn wenn immer $g_m(0^n)=\theta_n$, dann war $n\in H_m$ und nach V6 ist $\Sigma^n\cap O=\emptyset$ und daher $\theta_n\in\TAUT^O$.
    Nach Wahl von $T_r$ als optimal existiert daher ein Polynom $p$ sodass 
    \[ g_m(0^n)=\theta_n \implies \exists z\in\Sigma^{\leq p(z)}.\, T_r^O(z)=\theta_n. \]

    %Wähle nun eine beliebige aufsteigende Folge $n_1, n_2, n_3\in H_m$ sodass (a) $n_i>n_0$ für alle $i>0$, und
    %\[ t_r\!\left(|\theta_{n_i}|^{\log|\theta_{n_i}|}\right) < 2^{n_i}. \tag{b} \]
    Wähle nun ein $n\in H_m$ sodass (a) $n>n_0$, und (b) $|\theta_n|^{\log |\theta_n|}>p(n)$ und
    \[ t_r(|\theta_n|^{\log|\theta_n|}) < 2^n \tag{c}. \] 
    Nachdem $g_m(0^n)=\theta_n$ existert also ein $T_r$-Beweis $z$ mit $|z|\leq p(z)$ für $\theta_n$, bzw. $T_r^O(z)=\theta_n$.
    Ohne Beschränkung ist $t_r$ monoton und wir haben
    \[ t_r(|z|)\leq t_r(p(z)) \leq  t_r(|\theta_n|^{\log|\theta_n|}) < 2^n. \]
    Also existiert ein Wort $q\in\Sigma^n$ welches sicher nicht von der Berechnung $T^O_r(z)$ gestellt wurde.

    Wir können also durch schrittweises Erweitern von $w_{s-1}$ ein finites Orakel $w'$ konstruieren, welches alle Wörter der Länge $\leq t_r(|z|)$ definiert, mit
    \[ w'(z)=\begin{cases} O(z) & \text{falls $|z|\neq n$} \\ 1 & \text{falls $z=q$} \\ 0 & \text{sonst}. \end{cases} \]
    Dieses Orakel stimmt mit $t_{s-1}$ überein, ist damit $t_{s-1}$-valide, und es wäre $\theta_n\not\in\TAUT^{w'}$ und $T_r^{w'}(z)=\theta_n$.
    Damit wäre $w'$ eine dann eine geeignete Erweiterung von $w_{s-1}$ in Bearbeitung von Task $\tau^3_{k}$, für welche $T_k^O$ kein Beweissystem für $\TAUT$ mehr wäre. Widerspruch zur Wahl von $T_k$.
\end{proof}


Wir wollen nun zeigen, dass wir disjunkte Paare von NP-Sprachen in P separieren können. Sei im Folgenden $M_a, M_b$ ein komplementär akzeptierendes Paar an Maschine relativ zu $O$. Um die Sprachen zu trennen nutzen wir aus, dass $\mathrm{PSPACE}^C=\P^C$, um so iterativ eine Menge $D\subseteq O$ an Orakelwörtern der Länge $e(\cdot)$ aufbauen, welche für die Berechnungen $M_a(x), M_b(x)$ relevant ist, bis wir nach einigen Iterationen alle solchen relevanten Wörter gefunden haben. 
Wir beschränken uns im Folgenden auf Eingaben hinreichender Länge, sodass es für $x$ ein eindeutiges $i$ gibt, sodass
\[ e(i-1) \leq \log(|x|) < e(i), \quad p_a(|x|)+p_b(|x|)< 2^{e(i)} < e(i+1).\tag{\ast} \]

Wir definieren Folgendes: %Seien $W,W'\subseteq \{q\in \Sigma^*\mid \exists i.|q|=e(i)\}$ zwei disjunkte Mengen mit $W\subseteq O,$ $W'\subseteq \overline{O}$.
Sei $j\in \{a,b\}$
Eine \emph{$(W, W')$ respektierende akzeptierende Berechnung $P$ von $M_j$ auf Eingabe $x$} ist ein akzeptierender Rechenweg $P$ von $M_j(x)$ relativ zu einem Orakel $v\subseteq\Sigma^*$, wobei 
\[ W,W'\subseteq \Sigma^{e(i)}, \quad W\subseteq O, \quad W'\subseteq\overline{O} \]
und für $v$ gilt:
\begin{enumerate}[noitemsep,label=\arabic*.]
    \item $v$ ist definiert für genau die Wörter der Länge $\leq p_j(|x|)$.
    \item $v(q)=O(q)$ für alle $q$ mit $|q|\neq  e(i)$, wobei hier das $i$ diejenige eindeutige Zahl ist für die obigen Ungleichungen ($\ast$) bzgl. $|x|$ gelten.
    \item $v(q)=1$ für alle $q$ mit $q\in W$.
    \item $v(q)=0$ für alle $q$ mit $q\in W'$.
    %\item $v(q)=1 \implies q\in U$ für alle $q\in\Sigma^{e(i)}$. [$v$ enthält auf Ebene $e(i)$ nur Wörter, die auch in $U$ vorkommen.]
\end{enumerate}

Sei $P^\mathrm{all}$ die Menge der Orakelfragen auf $P$, und sei $P^\mathrm{yes}=P^\mathrm{all}\cap v$, $P^\mathrm{no}=P^\mathrm{all}\cap \overline{v}$.
Beob. dass  das Ermitteln einer $(W, W')$ respektierenden akzeptierenden Berechnung einfach in Polynomialzeit (abh. von $|x|$ und $\ell(W),\ell(W')$) relativ zu $O$ möglich ist: insbesondere stimmt $O$ mit $C$ auf Wörtern der Länge $\neq e(\cdot)$ überein, und alle anderen Wörter der Länge $e(0), e(1), \dots, e(i-1)$ können vorab mit Queries an $O$ in Polynomialzeit erfragt werden.
Entsprechende Belegungen von $v$ für Wörter der Länge $e(i)$ können z.B. in PSPACE enumeriert werden.

Sei $s$ die Stufe bei der $\tau^1_{a,b}$ betrachtet wurde.
Zusätzlich zur Einschränkung $(\ast)$ diskutieren wir ab jetzt nur noch Eingaben, für welche das Orakel $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert.
Sei $M=\bigcup \{ H_m \mid t_s(\tau^3_{r})=m>0 \}$ eine Menge an Ebenen, welche einem TAUT-Beweissystem \emph{in Stufe $s$} zugewiesen ist.
Beob. dass $M\in \P$, denn es sind höchstens endlich viele $H_m$ in der Vereinigung, welche je in $\P$ entscheidbar sind.


\begin{claim}
    %Sei $M_j$ eine kategorische Maschine relativ zu $O$.
    %Ab hinreichend großer Eingabelänge $n_0$ gilt für alle Eingaben $x$, $|x|\geq n_0$, alle $W, W'$:
    Sei $e(i)\not\in M$.
    Seien $P_a, P_b$ je $(W, W')$ respektierenden akzeptierenden Berechnungen von $M_a$ bzw. $M_b$ auf Eingabe $x$.

    %Folgende Aussage gilt uneingeschränkt falls $e(i)\not\in M$, und sonst falls $e(i)\in M$ dann mit der Einschränkung dass $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$ gelten muss.
    Wenn $P^\mathrm{all}_a$ und $P^\mathrm{all}_b$ beide je eine (nicht notwendigerweise identische) Orakelfrage $q_a, q_b$ der Länge $e(i)$ enthalten, welche in $\Sigma^{e(i)}-(W\cup W')$ liegt, dann haben diese zwei Berechnungen eine (identische) Orakelfrage $q$ der Länge $e(i)$ gemeinsam, welche nicht in $W\cup W'$ liegt.
\end{claim}
\begin{proof}[Skizze.]
    Angenommen, dies gilt nicht, also sei $x$ sowie $W,W'\subseteq \Sigma^{e(i)}$, $W\subseteq O$, $W'\subseteq\overline{O}$ gegeben.
    Seien außerdem $P_a$ und $P_b$ je zwei $(W, W')$ respektierenden akzeptierenden Berechnungen von $M_a$, $M_b$ auf Eingabe $x$,
    welche je eine Orakelfrage der Länge $e(i)$ enthalten, welche nicht in $W\cup W'$ liegt,
    aber keine Orakelfrage aus $\Sigma^{e(i)}-(W\cup W')$ gemeinsam haben.
    Dann sind schon $P_a$ und $P_b$ verschieden.
    Seien ferner $v_a, v_b$ die zugehörigen Orakel, also für welche $M_j(x)$ akzeptiert und Eigenschaften~1--4 erfüllen.

    Wir werden nun ein $t_{s-1}$-valides Orakel $u\sqsupsetneq w_{s-1}$ konstruieren welches mit $v_a$ auf $P^\mathrm{all}_b$ übereinstimmt, und welches mit $v_b$ auf $P^\mathrm{all}_b$ übereinstimmt.
    Außerdem wird es auf Ebene $\Sigma^{e(i)}$ mindestens ein Wort enthalten, woraus wir zeigen können dass $u$ sogar ein geeignetes Orakel zur Zerstörung dieses DisjNP-Machinenpaars in der Bearbeitung von Task $\tau^1_{a,b}$ in Stufe $s$ ist, ohne Beschränkungen bzgl. DisjCoNP-Zeugensprachen zu verletzen. Insbesondere akzeptiert dann sowohl $M_a^O(x)$ als auch $M_b^O(x)$ was der Voraussetzung widerspricht.

    Sei $Y=(P^\mathrm{yes}_a\cup P^\mathrm{yes}_b)\cap\Sigma^{e(i)}$, und $N=(P^\mathrm{no}_a\cup P^\mathrm{no}_b)\cap\Sigma^{e(i)}$.
    Wir zeigen $Y\cap N = \emptyset$. (Das soll uns helfen nachzuweisen, dass ein geeignetes $u$ existieren kann.)
    Nehme an es gibt ein $q\in Y\cap N$ der Länge $e(i)$.
    \begin{itemize}[noitemsep]
        \item Ist $q\in W$ dann gilt schon sofort dass $q\not\in P^\mathrm{no}_a, P^\mathrm{no}_b$ was $q\in N$ widerspricht.
        \item Ist $q\in W'$ dann gilt schon sofort dass $q\not\in P^\mathrm{yes}_a, P^\mathrm{yes}_b$ was $q\in Y$ widerspricht.
        \item Andernfalls ist $q\in  W\cup W'$, dann gilt $q\in P^\mathrm{yes}_a\cap P^\mathrm{no}_b$ oder $q\in P^\mathrm{yes}_a\cap P^\mathrm{no}_b$.
            In beiden Fällen hätten wir aber, dass $P_a$ und $P_b$ eine Orakelfrage der Länge $e(i)$ teilen, welche in $W\cup W'$ liegt. Das widerspricht der urpsrünglichen Annahme.
    \end{itemize}

    Es gilt also $Y\cap N =\emptyset$. Wähle ein $\alpha\in \Sigma^{e(i)}-N$. Dieses existiert da $|N|\leq p_a(|x|)+p_b(|x|)<2^{e(i)}$ nach ($\ast$).
    Sei nun $u$ das Orakel was genau alle Wörter der Länge $\leq p_j(|x|)$ definiert sind, und
    \[ u(z)= \begin{cases} O(z) & \text{falls $|z|\neq e(i)$}\\ 1 & \text{falls $z=\alpha$} \\1 & \text{falls $z\in Y$} \\ 0&\text{sonst,} \end{cases}
    \]
    also wie $O^{\leq p_j(|x|)}$ aufgebaut ist, außer dass die Ebene $e(i)$ mit genau den Wörtern aus $Y$ gefüllt wird. bzw. $u\cap\Sigma^{e(i)} = Y\cup \{\alpha\}$.
    Es ist leicht zu sehen dass $u\sqsupsetneq w_{s-1}$.
    Beob. dass 
    \[ u\cap N = \Sigma^{e(i)}\cap u \cap N = (Y\cup \{\alpha\}) \cap N= Y\cap N=\emptyset.\]

    Das Orakel $u$ stimmt mit $v_a$ auf $P^\mathrm{all}_a$ überein. Sei hierfür $q\in P^\mathrm{all}_a$.
    Ist $|q|\neq e(i)$, dann gilt schon nach Definition $v_a(q)=O(q)=u(q)$. Sei daher im Folgenden $|q|=e(i)$.
    Ist $q\in P^\mathrm{yes}_a$, dann auch $q\in v_a$. Außerdem dann auch $q\in Y$, daher $q\in u$.
    Ansonsten ist $q\in P^\mathrm{no}_a$, dann auch $q\not\in v_a$. Außerdem dann auch $q\in N$, daher $q\not\in u$ nach obiger Beobachtung.
    
    Auf symmetrische Weise stimmt $u$ mit $v_b$ auf $P^\mathrm{all}_b$ überein.
    Wir zeigen nun dass $u$ auch $t_{s-1}$-valide ist.
    Nach obiger Argumentation wäre dann $u$ eine geeignete Erweiterung von $w_{s-1}$ für welche $M_a^O(x)$ und $M_b^O(x)$ akzeptieren, also nicht mehr disjunkt, was der Wahl von $M_a, M_b$ widerspricht.

    Nach Konstruktion ist V1 und V2 erfüllt; V3 ist wegen $u\sqsupsetneq w_{s-1}$ erfüllt.
    Angenommen V4 ist verletzt.
    Wieder kann das nur an der Ebene $e(i)$ liegen.
    Aber hier gilt $|u\cap\Sigma^{e(i)}|=|Y\cap\{\alpha\}|\geq 1$.

    Angenommen V6 ist verletzt.
    Wieder kann das nur an der Ebene $e(i)$ liegen.
    Aber dann wäre $e(i)\in H_{m'}$ für $m', r$ mit $0<m'=t_{s-1}(\tau^3_r)$.
    Damit ist $e(i)\in M$, was der Voraussetzung der Behauptung widerspricht.
\end{proof}

\begin{claim}
    Zu jedem disjunkten \NP-Paar $(L_a, L_b)$ existiert ein Separator aus $\P$.
\end{claim}
\begin{proof}[Skizze.]
    Sei $L_a, L_b\in\NP^O, L_a\cap L_b=\emptyset$. Es existiert nach Definition ein Paar an Maschinen $M_a, M_b$ mit $L(M_a^O)=L_a$, $L(M_b^O)=L_b$.
    Wir zeigen für hinreichend lange $x$ wie man $L_1$ von $L_2$ in Polyonmialzeit relativ zu $O$ trennen kann.
    
    Sei im Folgenden $x$ hinreichend lange wie oben diskutiert, also für dieses $(\ast)$ mit eindeutigem $i$ gilt, sowie $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert, wobei $s$ die Stufe ist, bei der $\tau^1_{a,b}$ betrachtet wurde.
    Sei wieder $M=\bigcup \{ H_m \mid t_s(\tau^3_{a,b})=m>0 \}$.

    Im einfachen Fall ist $e(i)\in M$. Dann wissen wir nach V6 dass $\Sigma^{e(i)}\cap O=\emptyset$.
    Wie oben skizziert können alle anderen Wörter der Länge $e(0),\dots, e(i-1)$ in Polynomialzeit erfragt werden.
    Wir haben damit alle relevanten Wörter von $O\setminus C$ erfasst und können mittels einem trivialen PSPACE-Algorithmus entscheiden ob $M_a^O(x)$ oder $M_b^O(x)$ akzeptiert.
    
    Wir betrachten im Folgenden also nur den schwierigen Fall mit $e(i)\not\in M$.
    Hier gilt die Behauptung 5.
    Wir werden diese Eigenschaft ausnutzen und iterativ Mengen $W, W'$ aufbauen, welche für die Berechnungen $M_a^O(x), M_b^O(x)$ relevant sind, bis wir alle solchen relevanten Wörter gefunden haben.
    Das machen wir je abwechselnd für $M_a^O(x)$ und $M_b^O(x)$.
    Betrachte dafür folgende Subroutine:

    \noindent%
    \SetKwProg{Fn}{Function}{:}{}%
    \SetKw{Assert}{assert}%
    \begin{algorithm}[H]
        \Assert{$e(i)\not\in M$}\;
        $W\gets\emptyset,\, W'\gets\emptyset$\;
        \For{$k$ von $0$ bis $\max\{p_a(|x|), p_b(|x|)\}+1$}{
            $P_a\gets$ eine $(W, W')$ respektierende akzeptierende Berechnung $P$ von $M_a$ auf $x$ mit $|P^\mathrm{all}\cap\Sigma^{e(i)}-(W\cup W')|$ minimal, oder $\bot$ falls keine existiert\;
            $P_b\gets$ eine $(W, W')$ respektierende akzeptierende Berechnung $P$ von $M_b$ auf $x$ mit $|P^\mathrm{all}\cap\Sigma^{e(i)}-(W\cup W')|$ minimal, oder $\bot$ falls keine existiert\;
            \lIf{$P_a= \bot$}{\Return{„$x\in L_b$“}}
            \lIf{$P_b= \bot$}{\Return{„$x\in L_a$“}}
            \tcc{ab hier sind $P_a, P_b$ je zwei $(W, W')$ respektierende akzeptierende Berechnungen}
            \If{alle $q\in P_a^\mathrm{all}$ mit $|q|=e(i)$ sind in $W\cup W'$}{
                \Return{„$x\in L_a$“}
            }
            \If{alle $q\in P_b^\mathrm{all}$ mit $|q|=e(i)$ sind in $W\cup W'$}{
                \Return{„$x\in L_b$“}
            }
            \ForEach{$q\in P_a^\mathrm{all}\cup P_b^\mathrm{all}$ mit $|q|=e(i)$}
            {
                \lIf{$q\in O$}{$W\gets W\cup\{q\}$}
                \lIf{$q\not\in O$}{$W'\gets W'\cup\{q\}$}
            }
        }
        \Return{„$x\not\in L_a\cup L_b$“}
    \end{algorithm}
Es ist leicht zu sehen dass der Algorithmus eine polynomielle Laufzeitschranke einhält.
Wir beobachten die Invariante dass $W\subseteq O\cap\Sigma^{e(i)}$ und $W'\subseteq \overline{O}\cap\Sigma^{e(i)}$. 

Wir zeigen zunächst dass der Algorithmus keine falsch-positiven Fehler macht.
Für den ersten Fall nehme an dass der Algorithmus mit „$x\in L_a$“ terminiert aber es gilt $x\not\in L_a$ und $x\in L_b$.
Terminiert der Algorithmus in Z.~6, dann war $P_b=\bot$, was nach obiger Invariante bedeutet dass $M_b^O(x)$ ablehnt (denn sonst existiert immer eine $(W, W')$ respektierende akzeptierende Berechnung); Widerspruch zur Annahme.

Terminiert der Algorithmus in Z.~8, können wir den Widerspruch $x\in L_a$ zeigen: Sei $v$ das Orakel der $(W, W')$ respektierenden akzeptierenden Berechnung $P$ von $M_a(x)$. Es ist nun leicht zu sehen dass $v$ und $O$ auf $P_a^\mathrm{all}$ übereinstimmen. Damit gilt auch dass $M_a^O(x)$ akzeptiert und damit $x\in L_a$.

Der symmetrische Fall mit $L_b$ läuft analog. Damit macht der Algorithmus also zumindest schon keine falsch-positiven Fehler.
\medskip

Es verbleibt zu zeigen dass der Algorithus keine falsch-negativen Fehler macht.
Wir zeigen dies für den Fall dass $x\in L_a$, der andere Fall $x\in L_b$ läuft analog.
Sei hierfür $P_a^*$ der längste akzeptierende Rechenweg von $M_a^O(x)$.
Beob. mit obiger Invariante dass $P_a^*$ auch immer ein $(W,W')$ respektierender akzeptierender Rechenweg ist.
Nachdem der Algorithmus keine falsch-positven Fehler macht, sind die Bedingungen in Zz.~5 und 10 nie erfüllt.

Wir zeigen nun, dass nach $\leq p_j(|x|)+1$ vielen Iterationen auch die Bedingung in Z.~7 erfüllt ist.
Hierfür zeigen wir, dass $|P_a^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|$ in jeder Iteration um $\geq 1$ abnimmt. Da $|P_a^{*\mathrm{all}}|\leq p_j(|x|)$ ist nach $\leq p_j(|x|)+1$ vielen Iterationen $|P_a^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|=0$.
Nach $\leq p_j(|x|)+1$ vielen Iterationen wird also in Z.~3 eine Berechnung $P_a$ ausgewählt, bei der alle $q\in P_a^{\mathrm{all}}$ mit $|q|=e(i)$ in $W\cup W'$ liegen. Dann ist die Bedingung in Z.~7 erfüllt und der Algorithmus terminiert akzeptierend.

Steht der Algorithmus in Z.~13, dann gilt sowohl für das ausgewählte $P_b$, als auch für $P_a^*$ dass beide je eine (nicht notwendigerweise identische) Orakelfrage der Länge $e(i)$ enthalten, welche nicht in $W\cup W'$ liegt. (Andernfalls  wäre $P_a$ in Z.~3 anders ausgewählt worden.)
Damit ist Behauptung~4 anwendbar. Also haben diese zwei Berechnungen eine identische Orakelfrage $q\in P_b^\mathrm{all}\cap P_a^{*\mathrm{all}}\cap \Sigma^{e(i)}$ gemeinsam, welche nicht in $W\cup W'$ liegt.
Diese wird in den Zz.~13--16 dann auch irgendwann der Menge $W\cup W'$ hinzugefügt.
Damit nimmt auch $|P_a^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|$ um $\geq 1$ ab, wie behauptet.
\end{proof}

\clearpage

\noindent
\textbf{Gegeben:}
\begin{itemize}
    \item Betrachte Wortmenge $X$ mit $n$ Elementen.
    \item Alle Maschinen $m\in \mathcal M$ wollen ein für sie geeignetes Wort $x\in X_m\subseteq X$ zugewiesen bekommen.
    \item Die Maschinen in $\mathcal M$ bilden Paare: für jedes $m\in\mathcal M$ gibt es ein $\overline{m}\in M$ mit $X_m\cupdot X_{\overline{m}} = X$. Damit gilt $|X_m|+|X_{\overline{m}}|=n$.
    \item Es gibt $p$ viele Paare, also $|\mathcal M|=2p$.
    \item Außerdem sind die beiden Mengen ungefähr gleich groß: es gibt ein festes $q$ sodass $q< |X_m|< n-q$ für alle $m$ gilt.
    \item Gewisse Wörter stehen gegenseitig in Konflikt: Wenn $\{a,b\}\in \mathcal K$, dann stehen $a,b\in X$ in Konflikt.
    \item Jedes Wort $x$ steht zu höchstens $r$ anderen Wörtern in Konflikt.
\end{itemize}

\noindent
\textbf{Gesucht:} Menge $X'\subseteq X$ sodass keine zwei Wörter in $X'$ in Konflikt stehen, sowie für jede $m\in\mathcal M$ gilt $X_m\cap X' \neq \emptyset$.

\noindent
\textbf{Idee Konstruktion:}
\begin{itemize}
    \item Konstruiere einen Graphen $G$.
    \item Zeichne für jede Maschine $m\in\mathcal M$ einen Cluster $G_m$.
        Dieser Cluster hat die Knoten $(m,x_1), (m,x_2), \dots$ wobei $x_i\in X_m$, und keine Kanten.
    \item Verbinde Knoten über die Clusters hinaus: Wenn $(m,x)$ ein Knoten von $G_m$, und $(m',x')$ ein Knoten von $G_{m'}$ ist mit $m\neq m'$, und $\{x,x'\}\not\in\mathcal K$, dann verbinde diese zwei Knoten. 
    \item Existiert eine Clique mit $|\mathcal{M}|$ Knoten in $G$, dann existiert auch die gesuchte Teilmenge $X'$.
    \item Der Graph hat folgende Anzahl an Knoten:
        \[ |V(G)| = \sum_{\text{Paar $m,\overline{m}$ aus $\mathcal M$}} |V(K_{m})|+|V(K_{\overline{m}})|= \sum_{\text{Paar $m,\overline{m}$ aus $\mathcal M$}} |X_m|+|X_{\overline{m}}| = pn. \]
    \item Die Anzahl der Kanten können wir folgendermaßen abschätzen: Sei $(m,x)$ ein Knoten. Dieses $x$ ist zu mindestens $n-r$ Wörtern nicht in Konflikt.
        Sei $y$ ein solches Wort sodass $x$ und $y$ nicht in Konflikt stehen..
        Für jedes Paar $m', \overline{m'}\in\mathcal M$ mit $m\not\in \{m',\overline{m'}\}$ ist nun $x'\in X_m$ oder $x'\in X_{\overline{m}}$.
        
        Also ist $(m,x)$ entweder zu $(m',y)$ oder $(\overline{m'},y)$ inzident in $G$.
        Es gibt $p-1$ viele solche Paare, also ist $d((m,x))\geq (p-1)(n-r)$.

        Nach Handschlagssatz also
        \[ |E| = \sum_{(m,x)\in V} d((m,x)) \geq |V(G)|(p-1)(n-r)/2 =\frac{(pn)^2-pn^2-p^2rn}{2}. \]
    \item Wir zeigen nun $|E|>(1-1/(2p))(pn)^2/2$. Nach dem Satz von Turán existiert dann eine Clique mit $2p$ vielen Knoten.
        Es gilt
        \begin{align*}
            \implies & 1/p-r/n < 1/(2p)\\
            \implies & 1-1/p-r/n > 1-1/(2p)\\
            \implies & \left(1-1/p-r/n\right){(pn)^2} > (1-1/(2p))(pn)^2\\
            \implies & {(pn)^2-pn^2-p^2rn} > (1-1/(2p))(pn)^2\\
            \implies & \frac{(pn)^2-pn^2-p^2rn}{2} > (1-1/(2p))(pn)^2/2\\
            \implies & |E|>(1-1/(2p))(pn)^2/2
        \end{align*}



    %\item Zeichne für jede Maschine $m\in\mathcal M$ eine Clique $K_m$.
        %Diese hat die Knoten $(m,x_1), (m,x_2), \dots$ wobei $x_i\in X_m$.
    %\item Verbinde Knoten über die Cliquen hinaus: Wenn $(m,x)$ ein Knoten von $K_m$, und $(m',x')$ ein Knoten von $K_{m'}$ ist, und $\{x,x'\}\in\mathcal K$, dann verbinde diese zwei Knoten. 
    %\item Existiert eine unabhängige Menge mit $|\mathcal{M}|$ Knoten in $G$, dann existiert auch die gesuchte Teilmenge $X'$.
    %\item Der Graph hat folgende Anzahl an Knoten:
        %\[ |V(G)| = \sum_{\text{Paar $m,\overline{m}$ aus $\mathcal M$}} |V(K_{m})|+|V(K_{\overline{m}})|= \sum_{\text{Paar $m,\overline{m}$ aus $\mathcal M$}} |X_m|+|X_{\overline{m}}| = pn. \]
    %\item Zur Kantenzahl können wir den Beitrag der Inter-Cliquen-Kanten wie folgt abschätzen:
        %Für jedes Paar $m,\overline{m}$, o.B. $|X_m|\leq |X_{\overline{m}}|$ aus $\mathcal M$ gilt
        %\begin{gather*}
            %|E(K_{m})|+|E(K_{\overline{m}})| = {|X_m|\choose 2} + {|X_{\overline{m}}|\choose 2} = {|X_m|\choose 2} +  {(n-|X_m|)\choose 2}\\
            %\leq {n\choose 2} - |X_m|n\leq {n\choose 2}-qn = \frac{n(n-1-2q)}{2}\leq \frac{n^2}{2}-q.  
        %\end{gather*}
        %Also gilt für die Gesamtzahl an Kanten:
        %\[ |E(G)|\leq  \frac{pn^2}{2}-pq+??? . \]
    %\item Der komplementäre Graph $\overline{G}$ hat dann folgende Anzahl an Kanten
        %\begin{gather*}
            %|E(\overline{G})|\geq {pn\choose 2} - \left(\frac{pn^2}{2}-pq\right) = \frac{(pn)^2-pn}{2} - \frac{pn^2}{2}+\frac{2pq}{2} \\
        %\end{gather*}
\end{itemize}

\clearpage

\begin{tabular}{rccccl}
\toprule
{} & \hDisjNP & \hDisjCoNP &   \hUP &   $\neg Q$ &        oracle \\
\midrule
0  &    $-$ &    ($-$) &  $-$ &    $-$ &  BGS          \\
1  &    $-$ &      $-$ &  $-$ &    $+$ &  Dingel       \\
2  &    $-$ &    ($-$) &  $+$ &    $-$ &  at least as hard as $\hUP\not\Rightarrow\hDisjNP$             \\
3  &    $-$ &      $-$ &  $+$ &    $+$ &               \\
4  &    $-$ &      $+$ &  $-$ &    $-$ &  inconsistent \\
5  &    $-$ &      $+$ &  $-$ &  ($+$) &  Khaniki             \\
6  &    $-$ &      $+$ &  $+$ &    $-$ &  inconsistent \\
7  &    $-$ &      $+$ &  $+$ &  ($+$) &  at least as hard as $\hUP\not\Rightarrow\hDisjNP$             \\
8  &    $+$ &    ($-$) &  $-$ &    $-$ &  Sec. 3       \\
9  &    $+$ &      $-$ &  $-$ &    $+$ &               \\
10 &    $+$ &    ($-$) &  $+$ &    $-$ &  O1           \\
11 &    $+$ &      $-$ &  $+$ &    $+$ &  Dose20a      \\
12 &    $+$ &      $+$ &  $-$ &    $-$ &  inconsistent \\
13 &    $+$ &      $+$ &  $-$ &  ($+$) &  O2           \\
14 &    $+$ &      $+$ &  $+$ &    $-$ &  inconsistent \\
15 &    $+$ &      $+$ &  $+$ &  ($+$) &  EEG          \\
\bottomrule
\end{tabular}


\clearpage
\subsection*{Orakel mit $\hSAT$ und $\neg Q'$}
\setcounter{theorem}{0}

Wir verstehen die relativierte Version von $\hSAT$ als die Nicht-Existenz eines p-optimalen Beweissystems zur Menge $\mathrm{SAT}^O$.
Das ist die Menge der erfüllbaren aussagenlogischen Formeln, welche zusätzlich die Prädikate $\texttt{query}_m(a_1, a_2, \dots, a_m)$ verdenden darf.
Interpretation: $\texttt{query}_m(a_1, a_2, \dots, a_m)$ evaluiert zu 1 genau dann wenn $a_1a_2\cdots a_m\in O$.

Nach Dingel wissen wir:
\begin{lemma}
    Sei $f, g\in\FP^O$ mit $g(\Sigma^*)\subseteq f(\Sigma^*)$.  Wird $g$ nicht von $f$ p-simuliert, also
    \[ \forall h\in\FP^O\,\exists x\in\Sigma^*.\, f(h(x)) \neq g(x), \]
    dann ist $f$ nicht p-optimal für $f(\Sigma^*)$.
\end{lemma}

Sei $e(0)=2, e(i+1)=2^{e(i)}$. (Doppelt exponentiell!)
Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmengen von $e(\mathbb N)$. (Ebenen $H_m$ gehören zum Zeugen-Beweissytem $g_m$)

Idee: wir erreichen, dass alle Funktionen $T_j\in\FP$ entweder kein Beweissystem für relativiertes $\mathrm{SAT}$ sind, oder dass diese nicht das folgende Zeugen-Beweisystem $g_m$ p-simulieren (wobei $m$ von $T_j$ abhängig ist).
Wir setzen
\[ g_m(x) = \begin{cases} „\texttt{query}_n(a_1, \dots, a_n)“ & \text{falls $x=0^n$ und $n\in H_m$} \\ „a_1 \lor \neg a_1“ & \text{sonst}. \end{cases}\]
Fakt: gilt $O\cap \Sigma^n\neq \emptyset$ für alle $n\in H_m$, dann ist $g_m(\Sigma^*)\subseteq \mathrm{SAT}^O$.

Wollen wir also erreichen, dass $T_j$ mit $T_j(\Sigma^*)=\mathrm{SAT}^O$ nicht p-optimal ist, genügt es für alle Kandidaten $T_r$ an Übersetzungsfunktionen zu sichern, dass $T_j(T_r(0^n))\neq g_m(0^n)$ für geeignetes $n\in H_m$, und gleichzeitig $O\cap \Sigma^n\neq \emptyset$ für alle $n\in H_m$.

Die Aussage $\neg Q'$ ist äquivalent zur Aussage, dass alle Paare aus $\DisjCoNP$ auch \P-separierbar sind.
Versuche daher in der Konstruktion zunächst möglichst Paare an coNP-Maschinen zu zerstören, i.e. dass beide Maschinen ablehnen.
Ist das nicht möglich, werden wir durch eine Codierung das Akzeptanzverhalten dieses Paars in das Orakel eintragen.

Für die Kodierung definieren wir injektiv den Codewort $c(a,b,x)\coloneqq 0^a10^b10^l10^p1x$ mit $p=p_a(|x|)+p_b(|x|)$, $l\in \mathbb N$ minimal, sodass $l\geq 7/8 |c(a,b,x)|$ und $c(a,b,x)$ ungerade Länge hat. Auf diese Weise enthält ein Codewort das Wort $x$ als Information und ist auf ausreichende Länge aufgefüllt. Wir bezeichnen jedes Wort der Form $c(\cdot, \cdot, \cdot)$ als \emph{Codewort}. Hierdurch werden die folgenden Eigenschaften garantiert:
\begin{claim} Für alle $a,b\in\mathbb N$, $x\in\Sigma^*$ gilt folgendes:
\begin{enumerate}
\item $|c(a,b,x)| \not\in H_m$ für jedes $m$.
\item Für feste $a,b$ ist die Funktion $x \mapsto c(a,b,x)$ polynomialzeit-berechenbar und polynomialzeit-invertierbar bezüglich $|x|$.
\item Relativ zu einem beliebigen Orakel ist die Ausführungszeit von $M_a(x)$ und $M_b(x)$ beide auf $<|c(a,b,x)|/2$ beschränkt.
\item Für jedes partielle Orakel $w\in\Sigma^*$ gilt, wenn $c(a,b,x)\leq |w|$, dann sind $M_a^w(x)$ und $M_b^w(x)$ definit.
\end{enumerate}
\end{claim}

Für ein \DisjCoNP-Paar $(\overline{L(M_a)}, \overline{L(M_b)})$ setzen wir $c(a,b,x) \in O$ genau dann wenn $M_a(x)$ akzeptiert.
Entsprechend ist $c(a,b,c)\not\in O$ genau dann wenn $M_b(x)$ akzeptiert.
Das ist ausreichend, um dieses Paar zu P-separieren, denn $S=\{x \mid c(a,b,x)\in O\}$ ist ein Separator.
Es gilt $\overline{L(M_b)}\subseteq S$: für $x\in \overline{L(M_b)}$ muss gelten dass $M_a(x)$ akzeptiert (denn ansonsten ist das Paar nicht disjunkt), und nach Codierung ist $c(a,b,x)\in O$ und daher $x\in S$.

Ebenso gilt $\overline{L(M_a)}\subseteq \overline{S}$: äquivalent zu $S \subseteq L(M_a)$, was nach Konstruktion sofort klar ist.
\medskip

Der Zerstörung eines Beweissystems $T_j$ ordnen wir Task $\tau^1_j$ zu, der Diagonalisierung gegen Übersetzungsfunktion $T_r$ ordnen wir $\tau^1_{j,r}$ zu.
Der Zerstörung eines \DisjCoNP-Paares $(\overline{L(M_a)}, \overline{L(M_b)})$ ordnen wir den Task $\tau^2_{a,b}$ zu.

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^1_{n}, \tau^2_{a,b}$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

Ein Orakel $w\in\Sigma^*$ ist $t$-valide wenn $t\in\mathcal T$ und folgendes gilt:
\begin{enumerate}[label={V\arabic*}]
    %\item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2$.\\
    %    (Orakel $w$ ist dünn auf den Stufen der Länge $e(\cdot)$.)
    \item Wenn $t(\tau^1_{j})=0$, dann existiert ein $z$ sodass $T_j^w(z)\not\in \SAT^w$ und das definitiv.\\
        ($T_j$ kein Beweissystem für \SAT{} relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv ablehnen.\\
        (Wenn $t(\tau^2_{a,b})=0$, dann $(\overline{L(M_a)}, \overline{ L(M_b)})\not\in \DisjCoNP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^1_{j})=m$, dann gilt für alle $n\in H_m$ dass $\Sigma^n\cap w\neq \emptyset$.\\
        (Wenn $0<t(\tau^1_{j})=m$, dann ist $g_m\subseteq \SAT^w$.)
    \item Wenn $0<t(\tau^2_{a,b})\leq c(a,b,x)<|w|$, dann ist $M_a(x)^w$ definit. Die Berechnung akzeptiert wenn $c(a,b,x)\in w$, und lehnt ab wenn $c(a,b,x)\not\in w$.\\
        (Wenn $t(\tau^1_{j})>0$, dann codieren wir, von Wort $t(\tau^1_{j})$ an, die Menge $L(M_a)$ in das Orakel.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^1_{j,r}$ immer nach $\tau^1_{j}$ kommt.
Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_j$: Setze $t'=t_{s-1}\cup\{\tau^1_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_{s-1})$ sodass $w_{s-1}$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^1_{j}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 2.)

        (Bedeutung: falls möglich, zerstöre das Beweissystem für \SAT. Ist das nicht möglich, ordne diesem Beweissystem eine Menge an Stufen an, in der wir die Diagonalisierung für $g_m \not\leq^p T_j$ durchführen können.)


    \item $\tau^2_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^2_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten setze $t_s\coloneqq t_{s-1}\cup \{ \tau^2_{a,b}\mapsto n \}$ wobei $n>|w_{s-1}|,\max\{ \img(t_{s-1} \}$.
        Damit ist $t_s$ injektiv auf dem Support, und $w_{s-1}$ ist $t_s$-valide.
        Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 2.)

        (Bedeutung: falls möglich, mach dass $M_a$ und $M_b$ beide ablehnen. Ist das nicht möglich, verlange ab diesem Punkt dass die Menge $L(M_a)$ in das Orakel hineincodiert wird.)

    \item $\tau^1_{j,r}$: Wir wissen dass $t_{s-1}(\tau^1_{j})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in H_m$ die Folgende Aussage gilt: $z\in w_s\cap\Sigma^n$ und $T_j(T_r(0^n))\neq g_m(0^n)$ (=„$\mathtt{query}(a_1, \dots a_n)$“)  (Das ist möglich nach Behauptung 3.)

\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $y\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
    Insbesonderte gilt folgendes: Sei $s\in\mathbb N$, $(w_0, t_0), \dots, (w_s,t_s)$ definiert und sei $w\in \Sigma^n$ ein $t_s$-valides Orakel mit $w\sqsupseteq w_s$ und setze $z=|w|$. dann existiert ein $y\in\{0,1\}$ sodass $wy$ auch $t_s$-valide ist.
    \begin{enumerate}[label=(\roman*)]
        \item Wenn $z=c(a,b,x)$ und $0<t_s(\tau^1_j)\leq z$, dann ist $w1$ auch $t_s$-valide wenn $M_a^w(x)$ akzeptiert,
            und $w0$ ist $t_s$-valide wenn $M_b^w(x)$ akzeptiert.
        \item Wenn ein $\tau^2_{a,b}$ existiert mit $0<t_s(\tau^2_{a,b})=m$ und ein $n\in H_m$ existiert sodass $|z|=n$, sowie $|z+1|>n$, dann ist $w1$ ein $t_s$-valides Orakel.
        \item In allen anderen Fällen ist $w0$ und $w1$ ein $t_s$-valides Orakel.
    \end{enumerate}
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^1_{j,r}$ ist möglich. Sei $t_{s-1}(\tau^1_{j})=m>0$. dann existiertein $t_{s-1}$-valides $w\sqsupsetneq w_{s-1}$ und ein $n\in H_m$, sodass
    \begin{itemize}[nosep]
        \item $w\cap\Sigma^n\neq \emptyset$ (und daher $g_m(0^n)\in\SAT^u$), und
        \item $T_j^w(T_r^w(0^n))\neq g_m(0^n)$.
    \end{itemize}
\end{claim}
Im Folgenden werden wir diese Behauptung direkt beweisen, indem wir ein solches $w$ explizit konstruieren. Hierfür fixieren wir $j$, $r$ und $m$.
Sei $\hat{s}<s-1$ die Stufe, in welcher der Task $\tau^1_j$ bearbeitet wurde.
Sei
\[ \gamma(n) = p_j(p_r(n))+p_r(n) \]
die Laufzeit der Berechnug $T_j^u(T_r^u(z))$ mit Eingabe $z$ der Länge $n$a.
Beobachte, dass wenn $Q$ die Menge an Orakelfragen einer Berechnung $T_j^u(T_r^u(0^n))$ (relativ zu einem beliebigen Orakel) ist, dann ist $\ell(Q)\leq \gamma(n)$.

Sei im Folgenden $n\in H_m$ das kleinste $n$ sodass $w_{s-1}$ keine Wörter der Länge $n$ definiert, und 
\[ \cdots \tag{\ast} \]
Wir können nun mittels Behauptung~2 das Orakel $w_{s-1}$ nun so lange zu $u$ erweitern bis $u$ genau alle Wörter dr Länge $<n$ definiert. Dieses Orakel $u$ ist $t_{s-1}$-valide.

Für $X \subseteq \Sigma^n$ definieren wir $u(X)\sqsupsetneq u$, das für alle Wörter der Länge $\leq \gamma (n)$ definiert ist und sodass $u(X) \cap \Sigma^n = X$.
Wieder assoziieren wir mit $u(X)$ einen Abhängigkeitsgraphen $G(X)$, wie schon in z.B. EEG eingesetzt.
Für $X\neq\emptyset$ ist das klar, da $u(X)$ dann ja auch ein $t_{s-1}$-valides Orakel ist. (Insbesondere ist V3 nicht verletzt). Der Abhängigkeitsgraph hat in diesem Sinne nur „korrekte“ Codewörter.

Für $X=\emptyset$ ist das nicht klar, da $u(\emptyset)$ eben nicht $t_{s-1}$-valide ist, ist ja gerade V3 verletzt. Die „korrekten“ Codewörter können wir wie oben behanden. Für die „inkorrekten“ Codewörter $c(a,b,x)$ (bei der sowohl $M_a$ als auch $M_b$ ablehnen) werden wir die Zugehörigkeit zu $u(\emptyset)$ durch ein „Majoritätskriterium“ festlegen, aber werden im Abhängigkeitsgraph keine ausgehenden Kanten einzeichnen. Die Definition lässt zu, dass  das Orakel zumindest $t_{\hat{s}}$-valide ist.
\medskip

Vor der konkreten Definition hier das ungefähre Vorgehen: Relativ zu dem pathologischen $u(\emptyset)$ wird $T_j(T(r(0^n))$ die Ausgabe $y$ berechnen, wobei $y\neq g_m(0^n)$. (Ansonsten hätte $\tau^1_j$ den Transduktor $T_j$ als Beweissystem ausgeschlossen.)
%Diese Ungleichheit gilt, weil andernfalls $u(\emptyset)$ eine geeignete Erweiterung in der ursprünglichen Bearbeitung von Task $\tau^1_j$ in Stufe $\hat{s}$ war. Denn dann hätte $T_j$ die Formel $y=g_m(0^n)\not\in \SAT^{u(\emptyset)}$ ausgeben und $T_j$ wäre kein Beweissystem mehr.
%
Sei nun $Q$ die Menge an Orakelfragen auf dieser obigen Berechnung.
Betrachte nun die transitive Menge an Orakelfragen $Q^+=R_{G(\emptyset)}(Q)$.

Am liebsten würden wir jetzt ein $\alpha\in\Sigma^n$, was nicht in $Q^+$ liegt,
und dann hoffen dass auch $T_j(T(r(0^n))$ relativ zu $u(\{\alpha\})$ die Ausgabe $y$ berechnet.
Das klappt tatsächlich, falls $Q^+$ keine inkorrekten Codewörter bzgl. $u(\emptyset)$ enthält.
Dann sind wir sofort fertig.

Im anderen Fall stimmt das leider nicht: die inkorrekten Codewörter in $Q^+$ haben nicht im Mechanismus des Abhängigkeitsgraphs mitgespielt.
Das bedeutet, $u(\emptyset)$ und $u(\{\alpha\})$ stimmen im Allgemeinen nicht auf den inkorrekten Codewörtern in $Q^+$ überein.

Seien $z_1, \dots, z_k$ die inkorrekten Codewörter aus $Q^+$. Als Alternative werden wir Wörter $\beta_1, \dots, \beta_k\in \Sigma^n-Q^+$ mit folgenden Eigenschaften finden:

(A1) Für alle $1\leq i\leq k$ gilt $z_i\in u(\emptyset)$ genau dann wenn $z_i\in u(\{\beta_i\})$, i.e. $u(\emptyset)$ und $u(\{\beta_i\})$ stimmen auf $z_i$ überein.

(A2) Die $\beta_1, \dots$ kommen sich nicht in die Quere. Sei für $1\leq l\leq k$ die Menge $Q^+_i=R^+_{G(\{\beta_i\})}(z_i)$ die Orakelwörter, von welcher die Zugehörigkeit von $z_i$ zu $u(\{\beta_i\})$ abhängig ist.
Beobachte dass bzgl. $u(\{\beta_i\})$ das Codewort $\beta_i$ korrekt ist.
Die Aussage ist nun, dass $\beta_{i'}\not\in Q^+_i$ für alle $i'\neq i$.

Betrachte nun $u(\{\beta_1, \dots, \beta_k\})$. Nach A2 folgt, dass $u(\{\beta_i\})$ und $u(\{\beta_1, \dots, \beta_k\})$ auf $Q^+_i$ übereinstimmen, und damit auf $z_i$.
Nach A1 folgt dann, dass $u(\{\beta_1, \dots, \beta_k\})$ mit $u(\emptyset)$ auf $z_i$ übereinstimmt.
Nachdem das für alle $i$ gilt, stimmt $u(\{\beta_1, \dots, \beta_k\})$ mit $u(\emptyset)$ auf allen inkorrekten Codewörtern überein.
Die korrekten Codewörter stimmen schon deshalb überein, weil ja $\beta_1, \dots\not\in Q^+$.

Abschließend stimmt also $w=u(\{\beta_1, \dots, \beta_k\})$ mit $u(\emptyset)$ auf $Q^+$ überein, und damit läuft die Rechnung $T_j(T(r(0^n))$ identisch auf Orakel $w$.
Die Berechnung wird die Ausgabe $y\neq g_m(0^n)$ ausgeben.
Außerdem ist $w\cap\Sigma^n=\{\beta_1, \dots\}\neq \emptyset$ und wir haben beide Aussagen der Behauptung erreicht.


\paragraph{Definition of $u(X)$, $G(X)$:} Sei $X\subseteq\Sigma^n$. Wir konstruieren $u(X)$ und $G(X)=(V,E)$ induktiv. Fixiere die Knotenmenge $V=\Sigma^{\leq\gamma(n)}$.
Basisklauseln: 
\begin{enumerate}[label=(\arabic*)]
    \item Für $z\in \Sigma^{<n}$, setze $z\in u(X)$ genau dann wenn $z\in u$.
    \item Für $z\in \Sigma^{n}$, setze $z\in u(X)$ genau dann wenn $z\in X$.
\end{enumerate}
Induktive Klauseln: Sei $z\in\Sigma^{\leq \gamma(n)}$, $|z|>n$ und $u(X)$ für Wörter $<z$ definiert.

\begin{enumerate}[label=(\arabic*),resume*]
\item Wenn $z=c(a,b,x)$ für geeignete $a,b,x$ mit $0<t_s(\tau^1_{a,b})\leq z$, und \emph{mindestens eine} der Berechnungen $M^{{u(X)}}_{a}(x)$ oder $M_{b}^{{u(X)}}(x)$ akzeptiert, gehe wie folgt vor:

Markiere den Knoten $z$ als \emph{korrektes Codewort}.
Wenn $M_a^{{u(X)}}(x)$ akzeptiert, dann definiere $z\in u(X)$.
Setze $(z,q)\in E$ für alle Orakelfragen $q$ auf dem linkesten akzeptierenden Pfad von $M_a^{u(X)}(x)$.

Anderenfalls akzeptiert $M_b^{{u(X)}}(x)$, und definiere dann $z\not\in u(X)$.
Setze $(z,q)\in E$ für alle Orakelfragen $q$ auf dem linkesten akzeptierenden Pfad von $M_b^{u(X)}(x)$.

\item Anderenfalls, wenn $z=c(a,b,x)$ für geeignete $a,b,x$ mit $0<t_s(\tau^1_{a,b})\leq z$, und \emph{keine} der Berechnugen $M^{{u(X)}}{a}(x)$ oder $M{b}^{{u(X)}}(x)$ akzeptiert, gehe wie folgt vor:

Markiere den Knoten $z$ als \emph{inkorrektes Codewort}.
Definiere $Q^z_\mathrm{in} \coloneqq \{ \xi\in\Sigma^n \mid z\in u({\xi}) \}$, $Q^z_\mathrm{out} \coloneqq \{ \xi\in\Sigma^n \mid z\not\in u({\xi})\}$.

Wenn $|Q^z_\mathrm{out}|\leq |Q^z_\mathrm{in}|$, definiere $z\in u(X)$.  Anderenfalls, definiere $z\not\in u(X)$.
Es werden insbesondere keine Kanten hinzugefügt.

\item Anderenfalls, $z\not\in u(X)$.
\end{enumerate}
Extremale Klausel: (6) Es sind keine weiteren Kanten in $E$.

Wiederholen wir die folgenden Definitionen, die in Klausel (4) verwendet wurde:  
\begin{equation*}
Q_\mathrm{in}^z\coloneqq {\xi\in\Sigma^n \mid z\in u({\xi})},\quad Q_\mathrm{out}^z\coloneqq {\xi\in\Sigma^n \mid z\not\in u({\xi})}.
\end{equation*}
Beob. dass  $Q_\mathrm{in}^z, Q_\mathrm{out}^z$ die Menge $\Sigma^n$ partitioniert.


Wir stellen einige Behauptungen bezüglich $u(X), G(X)$ auf.
\begin{claim}
\begin{enumerate}
\item Wann immer $X\neq\emptyset$, ist $u(X)$ wohldefiniert, ist $t_{s-1}$-gültig und $G(X)$ enthält keine inkorrekten Codewörter. (Kann jedoch Wörter der Form $c(\cdot,\cdot,\cdot)$ enthalten, die nicht als korrekte Codewörter markiert sind.)
\item Für jedes beliebige $X\subseteq \Sigma^n$ ist $u(X)$ für alle Wörter der Länge $\leq \gamma(n)$ wohldefiniert, $u(X) \cap \Sigma^n = X$ und $u(X) \sqsupsetneq u\sqsupseteq w_{s-1}$.
\item Wann immer $s'<\hat{s}$, ist $u(\emptyset)$ auch $t_{s'}$-gültig.
\item Sei $z=c(a,b,x)$ ein korrektes Codewort in $G(X)$. Die folgenden Aussagen sind äquivalent: (a) $z\in u(X)$, (b) $M_a^{u(X)}$ akzeptiert, (c) $M_a^{u(X)}$ akzeptiert oder $M_b^{u(X)}$ lehnt ab.
\item $G(X)$ bildet einen gerichteten azyklischen Graphen (der nicht unbedingt verbunden ist). Insbesondere gilt für jede gerichtete Kante vom Knoten $a$ nach $b$, dass $a>b$.
\end{enumerate}
\end{claim}


\begin{claim}
    Sei $X\subseteq\Sigma^n$ und $Q\subseteq\Sigma^{\leq \gamma(n)}$.
    Dann gilt $\ell(R_{G({X})}(Q)) \leq 2\cdot \ell(Q)$.
\end{claim}


\clearpage

\subsection*{Orakel mit $\NP=\coNP$ und $\hSAT$ und alle Paare aus $\DisjNP$ sind $\P$-separierbar}
\setcounter{theorem}{0}

Wir verstehen die relativierte Version von $\hSAT$ als die Nicht-Existenz eines p-optimalen Beweissystems zur Menge $\mathrm{SAT}^O$.
Das ist die Menge der erfüllbaren aussagenlogischen Formeln, welche zusätzlich die Prädikate $\texttt{query}_m(a_1, a_2, \dots, a_m)$ verdenden darf.
Interpretation: $\texttt{query}_m(a_1, a_2, \dots, a_m)$ evaluiert zu 1 genau dann wenn $a_1a_2\cdots a_m\in O$.

Nach Dingel wissen wir:
\begin{lemma}
    Sei $f, g\in\FP^O$ mit $g(\Sigma^*)\subseteq f(\Sigma^*)$.  Wird $g$ nicht von $f$ p-simuliert, also
    \[ \forall h\in\FP^O\,\exists x\in\Sigma^*.\, f(h(x)) \neq g(x), \]
    dann ist $f$ nicht p-optimal für $f(\Sigma^*)$.
\end{lemma}

Sei $e(0)=2, e(i+1)=2^{e(i)}$. (Doppelt exponentiell!)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.

%Sei hier $\{H_{j,r}\}_{m,r\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmengen von $e(\mathbb N)$, mit folgender Eigenschaft:
%\[ e(i)\in H_{j,r} \implies t_j(t_r(e(i))) < 2^{e(i)} \]
%(Ebenen $H_{j,r}$ gehören zum Zeugen-Beweissytem $g_j$ und Übersetzungsfunktion $T_r$.)
%Diese sollen in Polynomialzeit invertierbar sein im Sinne dass
%\[ f(n) = \begin{cases} (j,r) & n\in H_{j,r} \\ \text{n.d.} & \text{sonst} \end{cases} \]
%in $\FP$ ist.
%Zur Einfachheit schreiben wir $H_j = \bigcup_r H_{j,r}$.
Sei hier $h\colon \mathbb N\times \mathbb N\to e(\mathbb N)$ eine injektive Funktion mit folgender Eigenschaft:
\[ h(j,r)=e(i) \implies t_j(t_r(e(i))) < 2^{e(i)}. \]
(Wörter der Länge $h(j,r)$ ist die Ebene zugehörig zum Zeugen-Beweissytem $g_j$ und Übersetzungsfunktion $T_r$.)
Diese soll in Polynomialzeit berechenbar und invertierbar sein.
Zur Einfachheit schreiben wir $H_j = \{ h(j,r) \mid r\in\mathbb N\}$.


\paragraph{Idee für $\hSAT$:} wir erreichen, dass alle Funktionen $T_j\in\FP$ entweder kein Beweissystem für relativiertes $\mathrm{SAT}$ sind, oder dass diese nicht das folgende Zeugen-Beweisystem $g_j$ p-simulieren (wobei $m$ von $T_j$ abhängig ist).
Wir setzen
\[ \phi_n = „\texttt{query}_n(a_1, \dots, a_n)“ \]
und damit ist
\[ \phi_n \in \SAT^O \iff \exists w\in O\cap \Sigma^n. \]
Sei dann
\[ g_j(x) = \begin{cases} \phi_n & \text{falls $x=0^n$ und $n=h(j,r)$} \\ „a_1 \lor \neg a_1“ & \text{sonst}. \end{cases}\]
Fakt: gilt $O\cap \Sigma^n\neq \emptyset$ für alle $n\in H_j$, dann ist $g_j(\Sigma^*)\subseteq \mathrm{SAT}^O$.

Wollen wir also erreichen, dass das („inhärente“) Beweissystem $T_j$ mit $T_j(\Sigma^*)=\mathrm{SAT}^O$ nicht p-optimal ist, genügt es für alle Kandidaten $T_r$ an Übersetzungsfunktionen zu sichern, dass $T_j(T_r(0^n))\neq g_j(0^n)$ für geeignetes $n=h(j,r)$, und gleichzeitig $O\cap \Sigma^n\neq \emptyset$ für fast alle $n\in H_j$.

Wir können dieses Vorgehen sogar noch abschwächen: für jede \emph{Funktion} (und nicht Beweissystem) $T_j$ und Übersetzungsfunktion $T_r$ bestimmen wir in \emph{jeder} Stufe $n=h(j,r)$ die Ausgabe $y=T_j(T_r(0^n))$ (relativ zu einem Orakel $w$ mit $w\cap\Sigma^n=\emptyset$.
\begin{itemize}
    \item Falls $y=\phi_n$ lassen wir die Stufe $n$ leer, und $T_j$ ist dann sicher kein Beweissystem.
    \item Falls $y\neq \phi_n$ setzen wir (mindestens) ein Wort $\alpha\in\Sigma^n$ in die Stufe $n$ ein welches nicht erfragt wurde. Dann hat $T_r$ nicht den $g_j$-Beweis für $\phi_n$ in einen $T_j$-Beweis übersetzt.
\end{itemize}
Dieses Vorgehen hat den Vorteil, dass die Entscheidung $O\cap\Sigma^{e(i)}\,\smash{\stackrel{?}{=}}\,\emptyset$ in $\P^O$ liegt: Bestimme $j,r$ sodass $e(i)=n=h(j,r)$. Teste ob $T_j(T_r(0^n))=\phi_n$, aber beantworte hierbei Orakelfragen der Länge $n$ negativ, alle anderen leitest Du weiter.



\paragraph{Idee für P-Separierung von $\DisjNP$:} 
Es reicht im Wesentlichen aus, so viele DisjNP-Paare wie möglich zu zerstören. 
Um nun ein Paar $(L(M_a^O), L(M_b^O))$ zu P-separieren reicht es aus, den Inhalt einer relevanten Stufe $O\cap\Sigma^{e(i)}$ zu bestimmen. 
Wie oben können wir schon in $\P^O$ erkennen, ob $O\cap\Sigma^{e(i)}=\emptyset$.
Falls ja sind wir schon fertig.

Falls nein, können wir über $C$ können wir akzeptierende Berechnungen eines Paars $(L(M_a^O), L(M_b^O))$ bestimmen und iterativ uns die relevanten Stufen $e(\cdot)$ rekonstruieren.
Wir machen hierbei in jeder Iteration Fortschritt, weil sonst das Orakel $O$ so hätte konstruiert werden können, dass sowohl $M_a^O$ als auch $M_b^O$ eine Eingabe akzeptieren.

%\paragraph{Idee für $\NP=\coNP$:} 
%Wir werden in der Konstruktion in $e(\cdot)$-Stufen höchstens ein Wort einsetzen. Mit dem obigen Entscheidungsalgorithmus für $O\cap\Sigma^n\,\smash{\stackrel{?}{=}}\,\emptyset$ können wir sogar in $\NP^O$ die Menge $O\cap\Sigma^{e(i)}$ rekonstruieren. Teste ob $O\cap\Sigma^{e(i)}= \emptyset$, wenn ja bist Du fertig und kannst $\emptyset$ ausgeben. Wenn nein, rate nichtdeterinistisch ein $w\in\Sigma^{e(i)}$ und teste ob $w\in O$. Falls nein, lehne ab, falls ja, gebe $\{w\}$ aus, und nach Konstruktion ist dann genau $\{w\}=O\cap\Sigma^{e(i)}$.

%Zur Erinnerung: die Entscheidung ob (NPTM) $M^C(x)$ ablehnt ist in $\mathrm{PSPACE}^C=\P^C\subseteq \P^O$ lösbar.
%Um also zu testen, ob $M^O(x)$ ablehnt, können wir in $\NP^O$ die Inhalte der Stufen $e(0), e(1), \dots e(i)$ bestimmen und in $D$ zusammenfassen. Dann gilt
%\[ M^O(x) \text{ lehnt ab} \iff  M^{C\cup D}(x) \text{ lenht ab} \iff M'^C(x) \text{ lenht ab}, \]
%wobei $N'$ aus $N$ hervorgeht wenn $D$ in $N$ „hineincodiert“ wird.

%Da die letzte Aussage in $\P^O$ ist, können wir also in $\NP^O$ entscheiden ob $M^O(x)$ ablehnt.
%Damit hätten wir $\NP^O=\coNP^O$.


\paragraph{Konstruktion} 
%Definiere die Tasks $\tau_{a,b}$.
%Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, die Tasks der Form $\tau_{a,b}$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

Ein Orakel $w\in\Sigma^*$ ist $t$-valide wenn $t\in\mathcal T$ und Folgendes gilt:
\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    \item Für alle $n=e(i)$ gilt: wenn $n\not\in\img h$, dann gilt $w\cap \Sigma^n=\emptyset$.
    \item Wenn $T_j^w(T_r^w(0^n))$ definit ist, dann gilt 
        \[ w\cap\Sigma^{n} = \emptyset \iff T_j^w(T_r^w(0^n))=\phi_n. \]
    %\item Wenn $x<|w|$ und $|x|=e(i)$ aber $|x|\not\in \img h$ für alle $j,r$, dann gilt $x\not\in w$.
    \item Für alle $n=e(i)$ gilt: wenn $i\not\in\img t$, dann gilt $|w\cap \Sigma^n|\leq 1$.
    \item Wenn $t(\tau^1_{a,b})=i$, dann existiert ein $z\in \Sigma^*$ und je ein definitiv akzeptierender Rechenweg von $M_a^w(z)$ mit Orakelfragen $Q_a$, bzw. von  $M_b^w(z)$ mit Orakelfragen $Q_b$.
        Außerdem existieren $\alpha\in Q_a$, $\beta\in Q_b$ und ein $\gamma$ sodass $w\cap\Sigma^{e(i)} = \{\alpha,\beta,\gamma\}$.
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^2_{a,b,r}$ immer nach $\tau^2_{a,b}$ kommt.
%Wir sagen dass ein Task $\tau$ \emph{priorisierter} als Task $\tau'$ ist, wenn $\tau$ in $T$ vor $\tau'$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

%Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun die Tasks $\{\tau_{(1)}, \tau_{(2)}, \dots, \tau_{(s)}\}$ behandelt -- $\tau^{(s)}$ kommt dazu. Je nach Typ von Task $\tau^{(s)}$ führen wir nun Folgendes durch:
Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.


\clearpage
\section*{Überlegungen zu Genericity}
\setcounter{theorem}{0}

%  \begin{definition}
%      \begin{enumerate}
%          \item Eine \emph{(Cohen-)Bedingung} ist eine partielle Funktion $\sigma\colon \Sigma^*\to \{0,1\}$ mit $\dom(\sigma)$ endlich.
%          \item Zwei Bedingungen $\sigma_1, \sigma_2$ sind \emph{widerspruchsfrei} wenn die Bilder auf $\dom(\sigma_1)\cap\dom(\sigma_2)$ übereinstimmen.
%          \item Mit $\sigma\subseteq \sigma'$ meinen wie wir üblich dass $\dom(\sigma)\subseteq \dom(\sigma')$ und $\sigma(x)=\sigma'(x)$ für alle $x\in \dom(\sigma)$.
%      \end{enumerate}
%  \end{definition}
%  
%  \begin{definition}
%      Wir nennen eine nichtleere Menge $\mathcal G$ an Bedingungen eine(n Begriff der) Generizität, wenn $\mathcal G$ Folgendes erfüllt:
%      \begin{enumerate}
%          \item (Verzweigung.) Für alle $\sigma\in\mathcal G$ existieren mindestens zwei Bedingungen $\tau_1, \tau_2\in\mathcal G$ sodass $\sigma \subseteq \tau_1, \tau_2$.
%          \item (Generisch.) Für alle $\sigma\in\mathcal G$, alle $a\in\Sigma^*\setminus \dom(\sigma)$ existiert eine Bedingung $\sigma'\in\mathcal G$ mit $\sigma\subseteq \sigma'$ und $a\in\dom(\sigma')$. (Können „erweitern“; „Löcher füllen“)
%          \item (Einfachheit.) Wenn $\sigma_1, \sigma_2\in G$ widerspruchsfrei sind, dann ist auch $\sigma_1\cup \sigma_2\in G$.
%      \end{enumerate}
%  \end{definition}
%  
%  Definiere bspw. \emph{Cohen}-Generizität über die Menge \[\{ \sigma \mid \sigma\colon \Sigma^*\to\{0,1\}, \dom(\sigma) \text{ endl.} \} \]
%  aller Cohen-Bedingungen. Bspw. ist auch folgende $\hUP$-Generizität ein geeigneter Begriff der Generizität: Eine $\hUP$-Bedingung $\sigma$ ist eine Cohen-Bedingung für welche gilt:
%  \begin{itemize}[nosep]
%      \item wenn $\sigma(x)=1$, dann $|x|=e(i)$ für geeignetes $i$ („lückenhaft“); und 
%      \item für alle $n$ gilt: existiert ein $y\in\Sigma^n$ mit $\sigma(y)=1$, dann $z\neq y\implies \sigma(z)=0$ für alle $z\in\Sigma^n$ („UP“).
%  \end{itemize}
%  Definiere die $\hUP$-Generizität über alle $\hUP$-Bedingungen.
%  Insbesondere ist dieser Begriff der Generizität einfach: Seien $\sigma_1, \sigma_2$ zwei widerspruchsfreie $\hUP$-Bedingungen. Damit ist $\sigma_1\cup \sigma_2$ schon mal lückenhaft.
%  Angenommen $\sigma'=\sigma_1\cup\sigma_2$ ist nicht „UP“, dann existieren $y_1,y_2\in\Sigma^n$, $y_1\neq y_2$, $\sigma'(y_1)=\sigma'(y_2)=1$.
%  Ohne Beschränkung gilt $\sigma_1(y_1)=1$, und weil $\sigma_1$ „UP“ ist, gilt $\sigma_1(y_2)=0$. Dann muss aber $\sigma_2(y_2)=1$, damit $\sigma_1$ und $\sigma_2$ nicht widerpruchsfrei wie gewählt.
%  %\begin{itemize}[nosep]
%      %\item Verzweigung: wähle ein $a\in\Sigma^*\setminus \dom(\sigma)$, definiere $\tau_1=\sigma\cup \{a\mapsto 0\}$, $\tau_2=\sigma\cup \{a\mapsto 1\}$.
%      %\item Generizität: definiere $\sigma' = \sigma\cup\{a\mapsto 0\}$.
%      %\item Einfachheit: klar
%  %\end{itemize}
%  
%  \begin{definition}
%      Sei $\mathcal G$ ein Begriff von Generizität (also eine Menge an Bedingungen).
%      \begin{enumerate}
%          \item Eine Bedingung $\sigma$ \emph{erzwingt} nun eine Aussage $\phi$ (hier ein PA-Satz mit zusätzlichem unären Prädikat $\mathtt{query}$ ), wenn $\sigma\Vdash_{\mathcal{G}}{} \phi$ („$\phi$ wahr für jedes Orakel $O\supseteq \sigma$“). 
%          \item wir nennen die $\mathcal G$-Generizität \emph{stark genug, um $\phi$ zu erzwingen} wenn für jede Bedingung $\sigma\in G$ eine zweite Bedingung $\sigma'\in G$ existiert mit $\sigma'\supseteq \sigma$ und $\sigma'\Vdash_{\mathcal G}{} \phi$.
%      \end{enumerate}
%  \end{definition}
%  
%  \begin{definition}
%      Sei $\mathcal G$ ein Begriff von Generizität. Ein Orakel $O$ ist $\mathcal G$-generisch wenn es eine widerspruchsfreie Menge an Bedingungen $\{\sigma_1, \sigma_2, \dots\}\subseteq\mathcal G$ gibt sodass \begin{itemize}
%          \item $\bigcup \sigma_i = O$, und
%          \item $\bigcup \dom(\sigma_i)=\Sigma^*$ (also ist $O$ total), und
%          \item jede Aussage $\phi$ für welche  $\mathcal G$ stark genug zu erzwingen ist, auch durch ein $\sigma_i$ erzwungen wird.
%      \end{itemize}
%  \end{definition}
%  
%  \begin{lemma}[Fenner, Fortnow, Kurtz]
%      \begin{enumerate}
%          \item Für jeden Begriff von Generizität $\mathcal G$ existiert ein $\mathcal G$-generisches Orakel $O$.
%          \item Für jedes $\mathcal G$-generische Orakel $O$ gilt: $\omega[O] \vDash \phi$ genau dann wenn $\mathcal G$ stark genug ist, um $\phi$ zu erzwingen.
%      \end{enumerate}
%  \end{lemma}
%  
%  \begin{corollary}
%      Sei $\mathcal G$ ein Begriff von Generizität. Falls $\mathcal G$ stark genug ist, $\phi$ zu erzwingen (also jedes $\sigma\in \mathcal G$ zu einem $\sigma'\in G, \sigma'\supseteq \sigma$ erweitert werden kann, sodass $\sigma'$ die Aussage $\phi$ erzwingt), dann ist $\phi$ wahr für jedes $\mathcal G$-generische Orakel (was nach vorigem Lemma existiert).
%  \end{corollary}
%  
%  \subsubsection*{Beispiel: relativ zu einem UP-generischen Orakel hat UP keine vollständige Menge}
%  
%  Wir haben bereits gesehen, dass der die oben definierten UP-Bedingungen einen Begriff der Generizität bilden. Zur Erinnerung: Eine $\hUP$-Bedingung $\sigma$ ist eine Cohen-Bedingung für welche gilt:
%  \begin{itemize}[nosep]
%      \item wenn $\sigma(x)=1$, dann $|x|=e(i)$ für geeignetes $i$ („lückenhaft“); und 
%      \item für alle $n$ gilt: existiert ein $y\in\Sigma^n$ mit $\sigma(y)=1$, dann $z\neq y\implies \sigma(z)=0$ für alle $z\in\Sigma^n$ („UP“).
%  \end{itemize}
%  
%  Definiere folgende Aussage
%  \[ \phi_{i,j} : (\exists n)[ M_i(T_j(0^n)) \text{ akz.} \iff (\exists x)[|x|=n\land X(x)]]. \]
\begin{definition}\begin{itemize}
    \item Eine \emph{Bedingung} ist eine partielle Funktion von $\omega \to \{0,1\}$ mit endlichem Definitionsbereich.
        \item Zwei Bedingungen $\sigma,\tau$ nennen wir \emph{konsistent} wenn $\sigma\cup\tau$ auch eine Bedingung ist, d.h. $a\in\dom(\sigma)\cup\dom(\tau)\implies \sigma(a)=\tau(a)$.
    \item Eine Bedingung $\tau$ \emph{erweitert} eine Bedingung $\sigma$ ($\tau\succeq \sigma$) falls $\dom(\sigma)\subseteq\dom(\tau)$ und $\sigma(a)=\tau(a)$ für alle $a\in\dom(\sigma)$.
    Wenn $\sigma\neq\tau$ schreiben wir auch $\tau\succ\sigma$.
    \item Wir überführen diese Notation auch auf Teilmengen von $\omega$ welche wir als totale Funktionen von $\omega\to\{0,1\}$ identifizieren.
    Wir schreiben also $A\succ \sigma$ falls $A(a)=\sigma(a)$ für alle $a\in\dom(\sigma)$.
\end{itemize}
\end{definition}

\begin{definition}
    Ein \emph{Begriff der Generizität} $\mathcal G$ ist eine nichtleere Klasse an Bedingungen mit folgenden Eigenschaften:
    \begin{enumerate}
        %\item (Verzweigung.) Für alle $\gamma\in\mathcal G$ existieren mindestens zwei Bedingungen $\tau_1, \tau_2\in\mathcal G$ mit $\tau_1,\tau_2\succ \gamma$ und $\tau_1\neq\tau_2$.
        \item (Generizität.) Für alle $\gamma\in\mathcal G$, alle $a\in \omega\setminus\dom(\gamma)$ existiert eine Bedingung $\gamma'\in\mathcal G$ mit $\gamma'\succ \gamma$ mit $a\in\dom(\gamma')$.
        \item (Grundlegend.) Sind $\sigma_1, \sigma_2\in\mathcal G$ konsistent, dann ist auch $\sigma_1\cup\sigma_2\in\mathcal G$.
    \end{enumerate}
    Die Bedingungen $\gamma\in \mathcal G$ nennen wir auch $\mathcal G$-\emph{Bedingungen}.
\end{definition}
%Nach Bedingung (1) sind $\mathcal G$-Bedingungen abgeschlossen im Raum $2^\omega$ (bzgl. Cantor-Topologie).

Sei im Folgenden $\mathcal G$ ein beliebiger aber fester Begriff von Generizität.
Im Folgenden ist $\mathcal L_{\mathrm{PA}}[X]$ die Sprache der Peano-Arithmetik ($=$, $+$, $\times$, $S$, $0$), mit einem zusätzlichen unären Prädikatsymbol $X$.
Sei $\mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ die Menge der Sätze in $\mathcal L_{\mathrm{PA}}[X]$.
Ohne Beschränkung sind die einzigen logischen Operationen $\neg, \lor, \exists$.
Für $n\in\omega$ bezeichnen wir mit $\overline{n}$ den Term $\underbrace{SS\cdots S}_{n}0$ in $\mathcal L_{\mathrm{PA}}[X]$.

Die $\mathcal G$-Forcing-Relation $\Vdash$ auf $\mathcal G\times \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$  wird durch eine einfache Rekursion über die Struktur von Formeln definiert, die im Wesentlichen Tarskis Wahrheitsdefinition entspricht, außer im Fall der Negation. Eine Bedingung $\tau$ \emph{erweitert} eine Bedingung $\gamma$, wenn $\tau\succ\gamma$ . Die Intuition hinter dem Begriff „erweitert“ ist, dass $\tau$ das Orakel vollständiger spezifiziert als $\gamma$. Somit besagt die Klausel (5) grob, dass $\neg\phi$ erzwungen wird, wenn wir $\phi$ niemals erzwingen können, indem wir unsere Annäherung an das Orakel verfeinern.

\begin{definition}[Forcing-Relation]
Die Variablen $\gamma$ und $\tau$ erstrecken sich über $\mathcal G$. Es gilt:
\begin{align*}
    \gamma\Vdash\phi &\iff \phi\text{ wahr im Standardmodell $\omega$ und $\phi$ atomar und $X$ kommt nicht in $\phi$ vor},\\
    \gamma\Vdash X(\overline n)&\iff(\forall A\succ\gamma).A(n)=1,\\
    \gamma\Vdash \phi\lor\psi &\iff\gamma\Vdash\phi\text{ oder } \gamma\Vdash \psi,\\
    \gamma\Vdash(\exists x)\phi &\iff \text{es existiert ein $a\in\omega$ sodass } \gamma\Vdash \phi[x/\overline{a}],\\
    \gamma\Vdash \neg\phi &\iff (\forall \tau\succeq \gamma).\,\tau\not\Vdash\phi.
\end{align*}
\end{definition}

\begin{definition}
    Wir schreiben $G\Vdash \phi$ wenn ein $\gamma\in \mathcal G$ existiert mit $G\succ \gamma$ und $\gamma\Vdash\phi$.
\end{definition}

\begin{definition}
    Eine Menge $G\subseteq\omega$ ist \emph{$\mathcal G$-generisch} wenn folgende Eigenschaften erfüllt sind:
    \begin{enumerate}
        \item Für alle $\sigma_1, \sigma_2\in \mathcal G$ gilt: wenn $G\succ \sigma_1, \sigma_2$ (also insb. auch konsistent), dann existiert auch eine Bedingung $\tau\in\mathcal G$ sodass $G\succ\tau\succeq\sigma_1\cup\sigma_2$.
        \item Für jeden Satz $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt $G\Vdash \phi\lor\neg\phi$, es existiert also ein $\gamma\in\mathcal G$ mit $G\succ \gamma$ und $\gamma\Vdash \phi\lor\neg\phi$.

        \item Für alle $n\in\omega$ existiert ein $\gamma\in\mathcal G$ mit $G\succ\gamma$ und $n\in\dom(\gamma)$.
    \end{enumerate}
\end{definition}

\begin{lemma}[Existenz von generischen Mengen]
    Für jeden Begriff der Generizität $\mathcal G$, jedes $\gamma\in\mathcal G$ existiert eine $\mathcal G$-generische Menge $G\succ \gamma$.
    (Da $\mathcal G$ nichtleer, existiert also immer eine $\mathcal G$-generische Menge.)
\end{lemma}
\begin{proof}
    Sei $\{\phi_i\}_{i\in\omega}$ eine Aufzählung aller Sätze in $\mathcal L_{\mathrm{PA}}[X]$. 
    Starte mit $\gamma_{-1}=\gamma$. Für jedes $i\geq 0$, gegeben $\gamma_{i-1}$, wähle ein $\sigma\in\mathcal G$ mit $\sigma\succeq\gamma_{i-1}$ und sodass $\sigma \Vdash \phi_i\lor\neg\phi_i$. Dieses $\sigma$ existiert: angenommen kein $\sigma\in\mathcal G$, $\sigma\succeq\gamma_{i-1}$ existiert mit $\sigma\Vdash \phi_i$. Dann gilt nach Definition $\gamma_{i-1}\Vdash\neg\phi_i$; setze $\sigma=\gamma_{i-1}$.

    Falls $i\not\in\dom(\sigma)$, setze $\gamma_i\in\mathcal G$ mit $\gamma_i\succ\sigma$ und $i\in\dom(\gamma_i)$. Diese existiert nach 2(1).
    Andernfalls, setze $\gamma_i=\sigma$.



    %Sei $\mathbb G=\{\delta\in\mathcal G \mid \exists i.\gamma_i \succeq\delta \}$. Wir geben nun eine Funktion $A\colon\mathbb N\to\{0,1\}$ sodass $A\succ \delta$ für alle $\delta\in\mathbb G$. Nach Konstruktion efüllt $A$ dann (2), und (1) folgt aus Grundlegendheit von $\mathcal G$.

    %Beobachte wie alle partiellen Funktionen in $\mathbb G$ paarweise konsistent sind: gilt $\delta, \delta'\in\mathbb G$, dann existieren auch $i,j\in\mathbb N$ mit $\gamma_i\succeq \delta$, $\gamma_j\succeq \delta'$. Ohne Beschränkung $i<j$, damit gilt $\gamma_j\succ\gamma_i\succeq\delta$, also $\gamma_j\succeq \delta, \delta'$ und dann können nicht $\delta$, $\delta'$ inkonsistent sein.

    %Nachdem die Menge aller partiellen Funktionen abzählbar ist, können wir die Elemente von $\mathbb G$ mit $\{\delta_i\}_{i\in\mathbb N}$ aufzählen.
    Wir definieren nun
    \[ G(n) = \gamma_n(n). \]
    Wir haben immer $n\in\dom(\gamma_n)$ (sogar $0,1,\dots, n\in\dom(\gamma_n)$) und damit ist $A$ wohldefiniert.
    Ferner gilt $A\succ\gamma_i$ für alle $i$: angenommen $A\not\succ\gamma_i$, dann existiert ein $k\in\dom(\gamma_i)$ und $\gamma_i(k)\neq G(k)=\gamma_k(k)$.
    Gleichzeitig ist aber $k\in\dom(\gamma_k)$ und entweder $\gamma_i\preceq \gamma_k$ oder $\gamma_k\preceq \gamma_i$. In beiden Fällen gilt $\gamma_i(k)=\gamma_k(k)$; Widerspruch zu oben.
    Also gilt (2).

    Damit gilt auch (3): Für beliebiges $n\in\omega$ existiert $\gamma_n\in\mathcal G$ mit $G\succ \gamma_n$ und $n\in\dom(\gamma_n)$.
    Die Eigenschaft (1) folgt unmittelbar aus Grundlegendheit bzw. 2(2).
\end{proof}

\begin{lemma}[Erzwingen ist Wahrheit]
    Sei $G$ eine $\mathcal G$-generische Menge. 
    Für alle $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt:
    $G\Vdash \phi$ genau dann wenn $\omega[G]\vDash \phi$.
\end{lemma}
\begin{proof}
    Induktion über die Struktur der Formeln. Variablen $\gamma, \gamma', \tau$ gehen über $\mathcal G$. Variable $A$ geht über $\{0,1\}^{\mathbb{N}}$.
    \begin{itemize}
        \item Lemma klar wenn $\phi$ atomar ist und $X$ nicht in $\phi$ vorkommt.
        \item Falls $\phi=X(\overline n)$ dann haben wir
            \begin{align*}
                G\Vdash X(\overline n) &\iff (\exists \gamma, \gamma\prec G).\,\gamma\Vdash X(\overline n)\\
                             &\iff (\exists \gamma, \gamma\prec G)(\forall A\succ \gamma),\, A(n)=1\\
                             &\iff G(n)=1 \\
                             &\iff \omega[G]\vDash X(\overline n),
            \end{align*}
            wobei die ersten zwei Äquivalenzen aus Definition folgen.
            %Ebenso
            %\begin{align*}
                %G\not\Vdash X(\overline n) &\implies (\forall \gamma', \gamma'\prec G).\,\gamma'\not\Vdash X(\overline n)\\
                                           %%&\implies (\exists \gamma, \gamma\prec G).\,\gamma\Vdash \neg X(\overline n)\\
                                           %%&\implies (\exists \tau,\tau\prec G).\,n\in\dom(\tau)\land \tau\not\Vdash X(\overline n)\\
                                           %%&\implies G(n)=0 \implies \omega[G]\vDash \neg X(\overline n). 
                                           %&\implies (\forall \gamma',\gamma'\prec G).\,n\not\in\dom(\gamma')\lor \gamma'(n)=0\\
                                           %&\implies (\exists \tau,\tau\prec G).\,\tau(n)=0\\
                                           %&\implies \tau(n)=G(n)=0 \implies \omega[G]\vDash \neg X(\overline n). 
            %\end{align*}
            %Zweite Implikation ist Definition.
            Rückrichtung dritter Äquivalenz folgt aus der Existenz eines $\gamma\prec G$ mit $n\in\dom(\gamma)$ nach 4(3).
        \item Lemma klar für Disjunktionen und Existenzquantor: Induktionsannahme verwenden.
        \item Für Negationen gilt: 
            \begin{align*}
                G\not\Vdash \neg\phi &\implies (\forall \gamma', \gamma'\prec G).\,\gamma'\not\Vdash \neg\phi\\
                                     &\implies (\exists \gamma, \gamma\prec G).\,\gamma\Vdash \phi\\
                                     &\implies G\Vdash\phi \implies \omega[G]\Vdash \phi.
            \end{align*}
            Die zweite Implikation gilt, denn für ein $\gamma\in \mathcal G, \gamma\prec G$ gilt nach Definition 4(2) dass $\gamma\Vdash \phi\lor \neg \phi$.
            Wenn also nach Voraussetzung für alle solche $\gamma'$ schon $\gamma'\not\Vdash \neg\phi$, dann muss $\gamma\Vdash \phi$.
            \begin{align*}
                G\Vdash \neg\phi &\implies (\exists \gamma, \gamma\prec G).\,\gamma\Vdash \neg\phi\\
                                     &\implies (\forall \gamma', \gamma'\prec G).\,\gamma'\not\Vdash \phi\\
                                     &\implies G\not\Vdash\phi \implies \omega[G]\not\Vdash \phi.
            \end{align*}
            Um die zweite Implikation zu sehen, nimm ann dass eine $\mathcal G$-Bedingung $\gamma'\prec G$ existiert mit $\gamma'\Vdash\phi$.
            Dann gilt $\gamma, \gamma'\prec G$ und nach Definition 4(1) existiert eine $\mathcal G$-Bedingung $\tau$ mit $\gamma\cup\gamma'\preceq\tau\prec G$.
            Dann haben wir aber $\tau\Vdash \phi$ und $\tau\Vdash\neg\phi$. Aus Letzterm folgt insbesondere $\tau\not\Vdash\phi$; Widerspruch zu Ersterem. Letzte Implikation ist Induktionsannahme. \qedhere
    \end{itemize}
\end{proof}
Unter dieser Definition von Forcing gilt insbesondere:
\begin{itemize}
    \item $\gamma\Vdash\phi\implies\gamma\Vdash\neg\neg\phi$ (\emph{“strong forcing implies weak forcing”}): Induktion über Formeln).
\end{itemize}

\begin{lemma}
    Für alle $\gamma\in\mathcal G$ und alle $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt:
    \[ \gamma\Vdash\neg\phi \iff (\forall\text{$\mathcal G$-generischen $G\succ\gamma$}).\, \omega[G]\not\vDash \phi. \]
    In anderen Worten: $\gamma\Vdash\neg\phi$ genau dann wenn $\phi$ unter allen generischen Erweiterungenen von $\gamma$ als falsch interpretiert wird.
\end{lemma}
\begin{proof}
    Sei $\gamma\Vdash\neg\phi$. Das bedeutet dass für alle $\mathcal G$-Bedingungen $\tau$ mit $\tau\succeq\gamma$ auch $\tau\not\Vdash \phi$ gilt.
    Nimm jetzt an dass eine $\mathcal G$-generische Menge $G\succ\gamma$ existiert mit $\omega[G]\vDash\phi$.
    Nach Lemma 6 gilt $G\Vdash\phi$, nach Definition existiert ein $\sigma\prec G$ mit $\sigma\Vdash\phi$.

    Nun sind $\gamma$ und $\sigma$ konsistent: gilt $a\in\dom(\gamma)\cap\dom(\sigma)$ dann gilt $\gamma(a)=G(a)=\sigma(a)$.
    Nach Definition 2(2) ist also auch $\tau'=\gamma\cup\sigma\in\mathcal G$ und wir haben $\tau'\succeq\gamma$ und $\tau'\Vdash\phi$; Widerspruch zu oben.

    Für die andere Richtung sei $\gamma\not\Vdash\neg\phi$. Dann existiert eine Bedingung $\tau$ mit $\tau\succeq\gamma$ und $\tau\Vdash\phi$.
    Nach Lemma 5 existiert eine $\mathcal G$-generische Menge $G\succ \tau$. Nach Lemma 6 gilt $\omega[G]\vDash\phi$.
\end{proof}

Beachte dass $\omega[G]\not\vDash\neg\phi$ genau dann wenn $\omega[G]\vDash\phi$. Wir haben dadurch
\begin{corollary}
    Für alle $\gamma\in\mathcal G$ und alle $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt:
    $\gamma\Vdash\neg\neg\phi$ genau dann wenn $\omega[G]\vDash\phi$ für alle $\mathcal G$-generischen $G\succ\gamma$.
\end{corollary}
\begin{corollary}
    Für alle $\gamma\in\mathcal G$ und alle $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt:
    Ist die Menge an $\mathcal G$-Bedingungen, welche $\phi$ erzwingen, dicht, also
    \[ (\forall \gamma\in\mathcal G)(\exists \tau\in\mathcal G, \tau\succeq\gamma).\,\tau\Vdash\phi, \]
    dann wird unter allen $\mathcal G$-generischen Mengen der Satz $\phi$ als wahr interpretiert.
\end{corollary}
\begin{proof}
    Sei $G$ eine beliebige $\mathcal G$-generische Menge.
    Es existiert eine Bedingung $\sigma\in\mathcal G$ mit $G\succ \sigma$; das folgt schon aus Definition 4(2) für einen beliebigen Satz, z.B. $\phi=X(\overline 0)$.
    Nach Voraussetzung gilt für diese Bedingung dass
    \[ (\forall\gamma\in\mathcal G, \sigma\preceq\gamma)(\exists \tau\in\mathcal G,\gamma\preceq\tau).\,\tau\Vdash\phi, \text{ also  } \sigma\Vdash\neg\neg\phi. \]
    Nach vorigem Lemma gilt dann $\omega[G]\vDash \phi$.
\end{proof}

%Im Folgenden ist sogar eher dienlich statt $\phi$ zu erzwingen, $\neg\neg \phi$ zu erzwingen. Zeigen wir 


\subsection*{Beispiel: BGS-Konstruktion}

Es ist unmittelbar klar, dass die Menge
\[ L(G) = \{ 0^n \mid \exists x\in G, |x|=n \} \in \NP^G \]
liegt.
Wir zeigen nun, wie sich durch Forcing ein Orakel $G$ angeben lassen kann, sodss $L(G)$ nicht in $\P^G$ liegt.
Dafür werden wir als Begriff der Generizität die \emph{Cohen}-Generizität (im Folgenden $\mathcal G$) verwenden, welche aus allen partiellen Funktionen mit endlichem Definitionsbereich besteht.

Wir zeigen nun, dass für jedes
\[ \phi_i \colon \neg„L(M^X_i)=L(X)“.  \] %(\exists n)[M^X_i(0^n) \text{ lehnt ab} \leftrightarrow (\exists x)(|x|=n\land X(x))] \]
die jeweilige Menge, welche $\phi_i$ erzwingt, dicht ist. (Maschine $M_i^X$ ist eine deterministische Poly-OTM.) Nach 9 sind wir dann fertig und es existiert ein $\mathcal G$-generische Orakel mit $\P^G\neq \NP^G$.

Sei daher $\gamma\in\mathcal G$. Wir müssen zeigen dass ein $\tau\succeq \gamma$ existiert dass in $\mathcal G$ liegt und $\tau\Vdash \phi_i$. 
Zunächst wählen wir ein $n\in\omega$ sodass $\gamma$ keine Wörter der Länge $n$ definiert, und sodass $2^n>p_i(n)$.

Nun wollen wir ein $\sigma$ angeben sodass $M_i^\sigma(0^n)$ definiert ist -- hier ist $M_i^\sigma(0^n)$ so definiert dass Queries $q$ mit $\sigma(q)$ beantwortet werden, und falls $q\not\in\dom(\sigma)$, dann ist $M_i^\sigma(0^n)$ nicht definiert.

Das lösen wir, in dem wir, wenn immer ein noch nicht definierter Query $q$ gestellt wird, $\sigma(q)=0$ setzen. Präziser: starte mit $\sigma_0=\gamma$.
Setze für $k>0$
\[ \sigma_k = \begin{cases}
    \sigma_{k-1} \cup \{q\mapsto 0\} & \text{\parbox{28em}{falls $M_i^{\sigma_{k-1}}(0^n)$ nicht definiert und $q\not\in\dom(\sigma_{k-1})$ der erste undef. Query auf dem Rechenweg ist}}\\[1.0em]
    \sigma_{k-1} & \text{sonst}.
\end{cases}
\]
Sei $\sigma=\sigma_N$ mit $N=t_i(n)$. Hierfür ist $M_i^\sigma(0^n)$ definiert, existieren ja höchstens $N$ viele Queries auf jedem Rechenweg.

Ist nun $M_i^\sigma(0^n)$ akzeptierend, dann setze
\[ \tau(x) =\begin{cases} \sigma(x) & \text{für $x\in\dom(\sigma)$}\\0&\text{für $x\in\Sigma^n$, $x\not\in\dom(\sigma)$}\\\text{undef.} & \text{sonst}.\end{cases} \]
Dann ist $\tau\in\mathcal G$ (endliche Definitionsmenge), und für alle $A\succ \tau$ haben wir $\omega[A]\not\vDash \text{„$L(M_i^X)=L(X)$“}$:
Denn $\omega[A] \vDash „M_i^X(0^n)\text{ akz.}“$ ($A$ und $\gamma$ stimmen auf den Orakelfragen überein) und $\omega[A] \vDash „0^n\not\in L(X)“$ ($A(x)=\gamma(x)=0$ für alle $x\in\Sigma^n$).

Also haben wir nach Lemma 8 dass $\tau\Vdash \neg„L(M_i^X)=L(X)“$ bzw. $\tau\Vdash\phi_i$ wie gewünscht.

Symmetrisch falls $M_i^\sigma(0^n)$ ablehnt. Sei $a\in\Sigma^*$ mit $a\not\in\dom(\sigma)$ (existiert da $2^n>t_i(n)$), und setze 
\[ \tau(x) =\begin{cases} \sigma(x) & \text{für $x\in\dom(\sigma)$}\\0&\text{für $x\in\Sigma^n$, $x\neq a$, $x\not\in\dom(\sigma)$}\\1&\text{für $x=a$}\\\text{undef.} & \text{sonst}.\end{cases} \]
Wir haben für alle $A\succ\tau$ dass $\omega[A] \vDash „M_i^X(0^n)\text{ abl.}“$  und $\omega[A] \vDash „0^n\in L(X)“$ ($A(a)=\gamma(a)=1$ für $a\in\Sigma^n$).
Wiedernach Lemma 8 dann $\tau\Vdash\phi_i$ wie gewünscht.

%Erweitere iterativ durch 2(1) die Lücken in $\gamma$ zu $\gamma'$, bis $\dom(\gamma')$ ein initiales Segment von $\omega$ ist. Die Bedingung $\gamma$ spezifiziert also alle Wörter $x<w$ für ein $w\in\omega$.

\subsection*{Relativierung von Forcing}

Die oben beschriebenen Definitionen und Ergebnisse bezüglich Forcing können einfach relativiert werden. Sei $B\subseteq \omega$. Forcing und Wahrheit relativ zu $B$ definieren wir wie im unrelativierten Fall, aber erweitern die Sprache $\mathcal L_{\mathrm{PA}}[X]$ und das Standardmodell $\omega$ um ein zweiteres unäres Prädikat $B$ zu $\mathcal L_{\mathrm{PA}}[B,X]$ bzw. $\omega^B$ mit Prädikat $B$ interpretiert über Menge $B$. Dann können wir z.B. über „$\mathcal G$-generisch relativ zu $B$“ sprechen.

Außerdem können zwei unäre Prädikate in arithmetischen Formel in ein einziges Prädikat überführt werden, mittels des Join-Operators $\oplus$: 
\[ A\oplus B = \{0x\mid x\in A\}\cup\{1x\mid x\in B\}. \]
Gegeben Formel $\phi$ über $\mathcal L_{\mathrm{PA}}[X,B]$ können wir effektiv eine Formel $\psi$ über $\mathcal L_{\mathrm{PA}}[X]$ finden sodass für alle $A,B\in\omega$ gilt:
\[ \omega^B[A] \vDash \phi \text{ genau dann wenn } \omega[A\oplus B]\vDash \psi. \]

TODO wie geht der Trick mit Re-Relativierung bzgl. QBF?


\subsection*{Beispiel: keine UP-vollständige Menge und $\neg Q$}

Eine generische Konstruktion, welche vollständige Elemente einer Klasse ausschließt, ist komplizierter. Hier liegt ein Abhängigkeitsverhältnis zwischen Maschinen und den Zeugensprachen vor. (Wenn Sprache in $\UP$, dann auch entsprechende Zeugensprache in $\UP$.)
Aber auch hier können wir analog zu dem sonst üblichen Vorgehen von Dose/Glaßer/Egidy fahren und „falls möglich, zerstöre Maschine, ansonsten sichere dass die entsprechende Zeugensprache in $\UP$ und schließe Reduktionen aus“.


Definiere $\tower(1)=2$, $\tower(n+1)=2^{2^{\tower(n)}}$.
Definiere polynomialzeitberechenbare und -in-\linebreak{}vertierbare Familie $\{H_{i}\}_{i\in\omega}$ wobei
\[ H_{i} \subseteq \{ \tower(n) \mid n\in\omega \} \]
und alle Mengen der Familie sind paarweise disjunkt.
Definiere folgende Familie an Zeugenpaaren $\{(L^0_{i,j}(A), L^1_{i,j}(A)) \}_{i,j\in\omega}$ abhängig von $A\subseteq\omega$:
\begin{gather*}
    L^0_{i,j}(A) = \{ 0^n \mid n\in H_{i,j}, \text{ es existiert ein $x\in\Sigma^n$ mit $x\in A$ und $x$ endet mit $0$} \}\\
    L^1_{i,j}(A) = \{ 0^n \mid n\in H_{i,j}, \text{ es existiert ein $x\in\Sigma^n$ mit $x\in A$ und $x$ endet mit $1$} \}.
\end{gather*}
Wir haben $(L^0_{i,j}(A), L^1_{i,j}(A))\in\DisjNP^A$ genau dann wenn kein $n\in H_{i,j}$ existiert dass sowohl $x0\in A$ und $y1\in A$ mit je einem $x,y\in\Sigma^{n-1}$.


Definiere nun folgenden Begriff der Generizität $\mathbf{DisjNPC}$: Eine Bedingung $\gamma$ ist in $\mathbf{DisjNPC}$
genau dann wenn 
\begin{enumerate}
    \item wenn immer $\gamma(x)=1$, dann gilt $|x|=\tower(n)$ für ein $n\in\omega$, und
    \item $\gamma$ kann zu einem Orakel $A$ erweitert werden sodass für alle $i,j\in\omega$ gilt:
\begin{gather*}
(L(N_i^A), L(N_j^A))\in\DisjNP^A\rightarrow (L^0_{i,j}(A), L^1_{i,j}(A))\in\DisjNP^A . \tag{\ast}
\end{gather*}
\end{enumerate}
%Insbesondere ist $\epsilon$, die nirgends definierte Funktion, eine $\mathbf{DisjNPC}$-Bedingung.
%Hieraus folgt sofort dass jedes $\mathbf{DisjNPC}$-generisches $G$ die (analoge) Aussage ($\ast$) erfüllt. Erfüllt $G$ diese Aussage nicht, dann existiert ein $i,j\in \omega$ sodass $(L^0_{i,j}(G), L^1_{i,j}(G))\not\in\DisjNP^G $ und $(L(N_i^A), L(N_j^A))\in\DisjNP^G$. 

Betrachte folgende Aussage:
\[ \phi_{i,j,r}\colon \neg„(L(N_i^X), L(N_j^X))\in\DisjNP^X“ \lor \neg„(L^0_{i,j}(X), L^1_{i,j}(X))\leqmpp(L(N_i^X), L(N_j^X))\text{ via }T^X_r“. \]
Es gilt also $\phi_{i,j,r}$ genau dann wenn das Paar $N_i, N_j$ nicht komplementär akzeptiert, oder wenn der Transduktor $T_r$ nicht die Reduktion vom Zeugenpaar auf Paar $N_i, N_j$ leisten kann.

\begin{claim}
Gilt \[ \epsilon\Vdash \neg\neg\phi_{i,j,0}, \neg\neg\phi_{i,j,1}, \dots \]
dann ist relativ aller $\mathbf{DisjNPC}$-generischen $G$ das Paar $(L(N_i^G), L(N_j^G))$ nicht vollsändig für $\DisjNP^G$. 
\end{claim}
\begin{proof}
    Also sei im Folgenden \[ \epsilon \Vdash\neg\neg„(L(N_i^X), L(N_j^X))\in\DisjNP^X“. \]
    Dann gilt für alle $\mathbf{DisjNPC}$-generischen Orakel wie in 9 dass
    \[ \omega[G] \vDash „(L(N_i^X), L(N_j^X))\in\DisjNP^X“. \]
    Angenommen es existiert ein $\mathbf{DisjNPC}$-generisches $G$  mit
    \[ (L^0_{i,j}(G), L^1_{i,j}(G))\not\in\DisjNP^G \]
    dann liegt das explizit an $n\in H_{i,j}$, $x,y,\in\Sigma^{n-1}$ sodass $x0\in A$ und $y1\in A$.
    Sei nun $\gamma$ eine $\mathbf{DisjNPC}$-Bedingung sodass $x0,y1\in\dom(\gamma)$. Diese existiert nach 4(3).
    Es lässt sich nun verifizieren dass
    \[ \gamma \Vdash „\text{ex. $n\in H_{i,j}$, $x,y\in\Sigma^{n-1}$, und $x0,y1\in X$}“ \]
    und damit 
    \[ \gamma \not\Vdash „(L^0_{i,j}(X), L^1_{i,j}(X))\in\DisjNP^X“. \]
    Es ist auch leicht zu sehen dass das auch für alle $\tau\succeq\gamma$ gilt, damit haben wir auch
    \[ \gamma \Vdash \neg„(L^0_{i,j}(A), L^1_{i,j}(X))\in\DisjNP^X“, \]
    und nach Lemma 8 gilt also 
    \[ \omega[G'] \not\vDash „(L^0_{i,j}(A), L^1_{i,j}(X))\in\DisjNP^X“\quad\text{ für alle $\mathbf{DisjNPC}$-gen. $G'\succ \gamma$.} \]
    Nun kann aber $\gamma$ keine $\mathbf{DisjNPC}$-Bedingung sein:
    relativ zu allen $\mathbf{DisjNPC}$-generischen $G'\succ \gamma$ gilt einerseits dass \[ (L^0_{i,j}(G'), L^1_{i,j}(G'))\not\in\DisjNP^{G'}, \]
    und andererseits gilt wegen oben
    \[ (L(N_i^{G'}), L(N_j^{G'}))\in\DisjNP^{G'}. \]
    Das Widerspricht der Eigenschaft (2), es existiert kein
   


    %Sei $G$ ein beliebiges $\mathbf{DisjNPC}$-generisches Orakel.
    %Falls das Paar $(L(N_i^G), L(N_j^G))$ nicht in $\DisjNP^G$ liegt, sind wir sofort fertig.

    %Andernfalls gilt 
\end{proof}

Entweder (a) es liegt nicht in $\DisjNP^G$, oder (b) es liegt in $\DisjNP^G$ und kein Transduktor kann das Zeugenpaar $(L^0_{i,j}(X), L^1_{i,j}(X))$ hierauf reduzieren. 
%Im Fall (b) also 
%\[ \omega[G]\not\vDash \neg „(L(N_i^X), L(N_j^X))\in\DisjNP^X“. \]
Angenommen 
\[ (L^0_{i,j}(G), L^1_{i,j}(G))\not\in\DisjNP^G \]
dann liegt das explizit an $n\in H_{i,j}$, $x,y,\in\Sigma^{n-1}$ sodass $x0\in A$ und $y1\in A$.
Sei nun $\gamma$ eine $\mathbf{DisjNPC}$-Bedingung sodass $x0,y1\in\dom(\gamma)$. Diese existiert nach 4(3).
Es lässt sich nun verifizieren dass
\[ \gamma \Vdash „\text{ex. $n\in H_{i,j}$, $x,y\in\Sigma^{n-1}$, und $x0,y1\in X$}“ \]
und damit 
\[ \gamma \not\Vdash „(L^0_{i,j}(X), L^1_{i,j}(X))\in\DisjNP^X“. \]
Es ist auch leicht zu sehen dass das auch für alle $\tau\succeq\gamma$ gilt, damit haben wir auch
\[ \gamma \Vdash \neg„(L^0_{i,j}(A), L^1_{i,j}(X))\in\DisjNP^X. \]
Nach Lemma 8 folgt damit dass für alle $\mathbf{DisjNPC}$-generischen $G'\succ\gamma$, also insbesondere auch $G$ gilt dass
\[ \omega[G] \not\vDash „(L^0_{i,j}(A), L^1_{i,j}(X))\in\DisjNP^X. \]


\end{document}
