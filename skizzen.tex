\documentclass[nofonts]{uebung}
%\setmainfont{NewCM10-Book}[ItalicFont={NewCM10-BookItalic}, BoldFont={NewCM10-Bold}]
%\setmathfont{NewCMMath-Book}
\usepackage[left=2cm,top=2cm, bottom=2cm,right=6cm,marginparwidth=4cm]{geometry}
\setmainfont{Latin Modern Roman}
\usepackage{unicode-math}
\setmathfont{Latin Modern Math}
\setmathfont[version=lm,range={\setminus}, Scale=MatchUppercase]{STIX Two Math}


\setmainlanguage{german}
\setotherlanguage{english}

\usepackage[authordate,maxbibnames=999,maxnciteames=5,backend=biber,language=german]{biblatex-chicago}
\addbibresource{bibliography.bib}
\SetCiteCommand{\parencite}
\renewcommand{\mkccitation}[1]{ #1}

\usepackage{amsthm}
\newtheorem{theorem}{Satz}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Behauptung}
\newtheorem{corollary}[theorem]{Korollar}
\newtheorem{observation}[theorem]{Beobachtung}
\newtheorem{property}[theorem]{Eigenschaft}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}


\setlist[enumerate]{label=(\roman*), itemsep=0pt}
\newlist{thmenum}{enumerate}{1}
\setlist[thmenum]{label=\textup{(\roman*)},ref=\thetheorem\textup{(\roman*)},itemsep=0pt}
\setlist[itemize]{itemsep=0pt}
\setlist{beginpenalty=10000, midpenalty=10000}

\newlist{statements}{enumerate}{1}
\setlist[statements]{resume,label=(A\arabic*)}

\usepackage{turnstile}

\def\P{\ensuremath{\mathrm{P}}}
\def\NP{\ensuremath{\mathrm{NP}}}
\def\NE{\ensuremath{\mathrm{NE}}}
\def\NEE{\ensuremath{\mathrm{NEE}}}
\def\FP{\ensuremath{\mathrm{FP}}}
\def\UP{\ensuremath{\mathrm{UP}}}
\def\DisjNP{\ensuremath{\mathrm{DisjNP}}}
\def\DisjCoNP{\ensuremath{\mathrm{DisjCoNP}}}
\def\DisjUP{\ensuremath{\mathrm{DisjUP}}}
\def\DisjCoUP{\ensuremath{\mathrm{DisjCoUP}}}
\def\coNP{\ensuremath{\mathrm{coNP}}}
\def\coNE{\ensuremath{\mathrm{coNE}}}
\def\coNEE{\ensuremath{\mathrm{coNEE}}}
\def\coUP{\ensuremath{\mathrm{coUP}}}
\def\NPcoNP{\ensuremath{\mathrm{NP}\cap\mathrm{coNP}}}
\def\TFNP{\ensuremath{\mathrm{TFNP}}}
\def\TALLY{\ensuremath{\mathrm{TALLY}}}
\def\NPMV{\ensuremath{\mathrm{NPMV}}}
\def\NPMVt{\ensuremath{\mathrm{NPMV_t}}}
\def\NPSV{\ensuremath{\mathrm{NPSV}}}
\def\NPSVt{\ensuremath{\mathrm{NPSV_t}}}
\def\NPbV{\ensuremath{\mathrm{NPbV}}}
\def\NPbVt{\ensuremath{\mathrm{NPbV_t}}}
\def\NPkV{\ensuremath{\mathrm{NP}k\mathrm{V}}}
\def\NPkVt{\ensuremath{\mathrm{NP}k\mathrm{V_t}}}
\def\TAUT{\ensuremath{\mathrm{TAUT}}}
\def\SAT{\ensuremath{\mathrm{SAT}}}
\def\PF{\ensuremath{\mathrm{PF}}}
\def\PSPACE{\ensuremath{\mathrm{PSPACE}}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\img}{img}
\DeclareMathOperator{\supp}{supp}
\def\hUP{\ensuremath{\mathsf{UP}}}
\def\hDisjNP{\ensuremath{\mathsf{DisjNP}}}
\def\hDisjCoNP{\ensuremath{\mathsf{DisjCoNP}}}
\def\hNPcoNP{\ensuremath{\mathsf{NP}{}\cap{}\mathsf{coNP}}}
\def\hCON{\ensuremath{\mathsf{CON}}}
\def\hSAT{\ensuremath{\mathsf{SAT}}}
\def\hTFNP{\ensuremath{\mathsf{TFNP}}}
\def\leqmpp{\ensuremath{\leq_\mathrm{m}^\mathrm{pp}}}
\def\leqmp{\ensuremath{\leq_\mathrm{m}^\mathrm{p}}}
\DeclareMathOperator{\tower}{tower}


\begin{document}
\renewcommand{\phi}{\varphi}

%\renewcommand{\thesubsection}{\arabic{subsection}}
\numberwithin{theorem}{section}

\section{Orakelkonstruktion $\hDisjNP$, $\hUP$, und $Q$ ($O_1$)}

U.a. Verbesserung der Konstruktion von Khaniki ($\hCON^N\land \TFNP=\FP$, i.e $Q$).

Konstruktion wie bei DG.

Sei $e(0)=2, e(i+1)=2^{e(i)}$. Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmenge von $e(\mathbb N)$. (Ebenen $H_m$ gehören zur Zeugensprache bzgl. DisjNP-Maschinenpaar $M_a, M_b$.)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.
Definiere folgende Zeugensprachen:
        \begin{gather*}
            A_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O \text{ und $x$ endet mit $0$} \}\\
            B_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O \text{ und $x$ endet mit $1$} \}\\
            C_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O  \}
        \end{gather*}
        Fakt: wenn $|O\cap \Sigma^{n}|\leq 1$ für alle $n\in H_m$, dann $(A_m^O, B_m^O)\in\DisjUP^O$.\\
        Wenn $|O\cap \Sigma^n|\leq 1$ für alle $n\in H_m$, dann $C_m^O \in \UP^O$.
\medskip

Idee: erreiche entweder dass $M_a$, $M_b$ nicht disjunkt akzeptieren (Task $\tau^1_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^1_{a,b,r}$ für Transduktor $F_r$).

Symmetrisch: erreiche das $M_a$ nicht kategorisch akzeptiert (Task $\tau^3_{a}$), oder dass die Zeugensprache $C_m$ nicht auf $L(M_a)$ reduzierbar ist (Task $\tau^2_{a,r}$ für Transduktor $T_r$).

Gleichzeitig versuchen wir für möglichst viele $M_j$ erreichen, dass diese nicht total sind. (Task $\tau^2_j$)
%Dies hat in gewisser Weise Priorität über die o.g. Diagonalisierung.
Am Ende sind die verbleibenden totalen Maschinen $M^O_j$ sehr speziell, denn sie sind auch für gewisse Teilmengen von $O$ total.
In Kombination mit dem Fakt dass $\P^C=\mathrm{PSPACE}^C$ können wir relevante Wörter in $O-C$ errechnen und so einen akzeptierenden Weg von $M^O_j(x)$ ausgeben -- damit erzielen wir $Q$.
\medskip

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^1_j, \tau^2_{a,b}, \tau^3_a$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

Ein Orakel $w\in\Sigma^*$ ist $t$-valide wenn $t\in\mathcal T$ und folgendes gilt:
\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    \item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2$.\\
        (Orakel $w$ ist dünn auf den Ebenen der Länge $e(\cdot)$.)
    \item Wenn $t(\tau^1_j)=0$, dann existiert ein $z$ sodass $M_j^w(z)$ definitiv ablehnt.\\
        ($L(M_j)\neq \Sigma^*$ relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv akzeptieren.\\
        (Wenn $t(\tau^2_{a,b})=0$, dann $L(M_a)\cap L(M_b)\neq \emptyset$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^2_{a,b})=m$, dann gilt für alle $n\in H_m$ dass $|\Sigma^{n}\cap w|\leq 1$.\\
        (Wenn $0<t(\tau^2_{a,b})=m$, dann $(A_m,B_m)\in\DisjNP$.)
    \item Wenn $t(\tau^3_{a})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ definitiv auf zwei Rechenwegen akzeptiert.\\
        (Wenn $t(\tau^3_{a})=0$, dann $L(M_a)\not\in \UP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^3_{a})=m$, dann gilt für alle $n\in H_m$ dass $|\Sigma^n\cap w|\leq 1$.\\
        (Wenn $0<t(\tau^3_{a})=m$, dann $C_m\in\UP$.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^2_{a,b,r}$ immer nach $\tau^2_{a,b}$ kommt, sowie $\tau^3_{a,r}$ immer nach $\tau^3_a$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_j$: Setze $t'=t_{s-1}\cup\{\tau^1_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.1.)

    \item $\tau^2_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^2_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^2_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.1.)

    \item $\tau^2_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^2_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in A_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
            \item $0^n\in B_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
        \end{itemize} (Das ist möglich nach Behauptung 1.2.)

    \item $\tau^3_{a}$: Setze $t'=t_{s-1}\cup\{\tau^3_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^3_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^3_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 1.1.)

    \item $\tau^3_{a,r}$: Wir wissen dass $t_{s-1}(\tau^3_{a})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in C_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
            \item $0^n\not\in C_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ akzeptiert relativ zu $w_s$ definitiv.
        \end{itemize} (Das ist möglich nach Behauptung 1.3.)
\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $b\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^2_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^2_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}
\begin{proof}[Skizze.]
    Widerspruchsbeweis. Erweitere $w_{s-1}$ mit Behauptung 1.1 so weit zu $u$, dass genau alle Wörter der Länge $<n=e(i)\in H_m$ definiert sind, wobei das $i$ hinreichend groß gewählt wird. Sei $u(X), X\subseteq \Sigma^n$ das Orakel was entsteht, wenn die Ebene $e(i)$ mit genau den Wörtern aus $X$ gefüllt wird, bzw. $u(X)=u\cup X \cup C$. Beob. dass $u(X), |X|\leq 1$ auch $t_{s-1}$-valide ist.

    Nach Annahme gilt
    \begin{itemize}
        \item für gerades $\alpha\in \Sigma^n$ gilt $0^n\in A_m^{u(\{\alpha\})}$ und daher akzeptiert $M_a(F_r(0^n))$ definitiv relativ zu $u(\{\alpha\})$.
        \item für ungerades $\beta\in \Sigma^n$ gilt $0^n\in B_m^{u(\{\alpha\})}$ und daher akzeptiert $M_b(F_r(0^n))$ definitiv relativ zu $u(\{\beta\})$.
    \end{itemize}
    Kombinatorische Standardmethoden zeigen dann, dass relativ zu $u(\{\alpha,\beta\})$ mit geeignetem geraden $\alpha$, ungeradem $\beta$ sowohl $M_a(F_r(0^n))$ also auch $M_b(F_r(0^n))$ relativ zu $u(\{\alpha,\beta\})$ akzeptieren.
    Damit wäre aber auch $u(\{\alpha,\beta\})$ ein geeignetes Orakel in der Bearbeitung von Task $\tau^2_{a,b}$ und wir hätten $t_{s-1}(\tau^2_{a,b})=0$.
\end{proof}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^3_{a,r}$ ist möglich: gilt $t_{s-1}(\tau^3_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}
\begin{proof}[Skizze.]
    Widerspruchsbeweis symmetrisch zu Behauptunng 2. Betrachte wieder die identisch definierten Orakel $u(X)$.
    Nach Annahme gilt
    \begin{itemize}
        \item es gilt $0^n\in C_m^{u(\emptyset)}$ und daher lehnt $M_a(F_r(0^n))$ definitiv relativ zu $u(\emptyset)$ ab. [Das ist wichtig um zu zeigen dass es zwei \emph{unterschiedliche} Berechnungen gibt.]
        \item für gerades $\alpha\in \Sigma^n$ gilt $0^n\in C_m^{u(\{\alpha\})}$ und daher akzeptiert $M_a(F_r(0^n))$ definitiv relativ zu $u(\{\alpha\})$.
        \item für ungerades $\beta\in \Sigma^n$ gilt $0^n\in C_m^{u(\{\beta\})}$ und daher akzeptiert $M_a(F_r(0^n))$ definitiv relativ zu $u(\{\beta\})$.
    \end{itemize}
    Sei für $\xi\in\Sigma^n$ die Menge $Q_\xi$ die Menge an Orakelfragen auf dem akzeptierenden Rechenweg von $M_a(F_r(0^n))$ relativ zu $u(\{\xi\})$.
    Es gilt $\xi\in Q_\xi$, denn andernfalls würde $u(\emptyset)$ und $u(\{\xi\})$ auf $Q_\xi$ übereinstimmen und wir hätten dass auch $M_a(F_r(0^n))$ relativ zu $u(\emptyset)$ akzeptiert. Das widerspricht der Annahme.

    Kombinatorische Standarmethoden zeigen dann, dass es ein gerades $\alpha$, ungerades $\beta$ gibt mit $\alpha\not\in Q_\beta$, $\beta\not\in Q_\alpha$ und so $M_a(F_r(0^n))$ relativ zu $u(\{\alpha,\beta\})$ auf zwei Rechenwegen akzeptiert, je mit Orakelfragen $Q_\alpha$ und $Q_\beta$. Diese Rechenwege sind nicht gleich, da $\alpha\in Q_\alpha$ nach obiger Behauptung, aber $\beta\not\in Q_\beta$.

    Damit wäre aber auch $u(\{\alpha,\beta\})$ ein geeignetes Orakel in der Bearbeitung von Task $\tau^3_{a}$ und wir hätten $t_{s-1}(\tau^3_{a})=0$.
\end{proof}

Damit ist die Konstruktion möglich. Sei $O=\lim_{s\to\infty} w_s$.

\begin{claim}
    Kein Paar aus $\DisjNP^O$ ist $\leqmpp$-hart für $\DisjUP$.
\end{claim}

\begin{claim}
    Keine Menge aus $\UP^O$ ist $\leqmp$-vollständig.
\end{claim}


\begin{claim}
    Sei $M_j$ eine totale Maschine, d.h. $L(M^O)=\Sigma^*$.
    Es existiert eine Länge $n$ mit folgender Eigenschaft: 
    falls $T\subseteq O$ mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern $\leq n$ übereinstimmt, dann $L(M_j^T)=\Sigma^*$.
\end{claim}
\begin{proof}[Skizze.]
    Sei $s$ die Stufe bei der $\tau^1_j$ bearbeitet wurde. Setze $n=|w_{s-1}|$.
    Wir zeigen nun, dass dieses $n$ die behauptete Eigenschaft erfüllt.
    Angenommen, dies gilt nicht, dann existiert ein $T\subseteq O$ dass mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern $\leq n$ übereinstimmt, aber für ein Wort $z$ lehnt $M_j^T(z)$ ab.
    Sei $t'=t_{s-1}\cup \{\tau^1_j\mapsto 0\}$ und sei $v=T\cap\Sigma^{m}$ wobei $m\geq p_j(|x|), n+1$. 
    Beob. dass $M_j^v(z)$ definitiv ablehnt.

    Wir zeigen, das $v$ auch $t'$-valide ist;  damit wäre $v$ eine geeignete Erweiterung in Stufe $s$ und wir hätten $t_s=t'$. 
    Das bedeutet nach V3, dass $M_j^{w_s}(z)$ definitiv ablehnt, damit auch $M_j^O(z)$ ablehnt, was der Voraussetzung widerspricht.

    Wir zeigen dass $v$ auch $t'$-valide ist:
    V1, V2, V5, V7 sind sofort erfüllt nach Definition von $T$ als Teilmenge von $O$ bzw. übereinstimmend mit $O$ auf Wörtern der Länge $\neq e(\cdot)$.
    Da $v\sqsupsetneq w_{s-1}$, sind auch V4 und V6 erfüllt, außer der neue V3-Fall von $t'(\tau_j^2)=0$.

    Aber auch hier erfüllen wir entsprechende Instanz von V3, da ja $M_j^v(z)$ definitiv ablehnt.
\end{proof}

\begin{claim}
    Sei $M_j$ eine totale Maschine, d.h. $L(M_j^O)=\Sigma^*$. Dann existiert eine Funktion $g\in \FP^O$ sodass $g(x)$ einen akzeptierenden Rechenweg von $M^O_j(x)$ ausgibt. Damit gilt nach Definition die Hypothese $Q$ relativ zu $O$.
\end{claim}
\begin{proof}[Skizze.]
    Es reicht aus, dass $g\in\FP^O$ nur Wörter hinreichender Länge verarbeiten muss.
    Sei $n$ hinreichend groß, sodass diese vorige Behauptung 1.6 erfüllt ist.
    Damit gilt: wenn $T\subseteq O$ mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern der Länge $\leq n$ übereinstimmt, dann $L(M_j^T)=\Sigma^*$.

    Sei also nun ein solches $x$ gegeben. 
    Wir werden obige Eigenschaft ausnutzen und iterativ eine Menge $D\subseteq O$ an Orakelwörtern der Länge $e(\cdot)$ aufbauen, welche für die Berechnung $M_j^O(z)$ relevant ist, bis wir alle solchen relevanten Wörter gefunden haben.
    Wir starten hierbei mit der Menge aller Orakelwörter in $O$, welche Länge $\leq n$  und Länge $=e(\cdot)$ haben.
    Beob. dass damit $C\cup D\subseteq O$ und mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern der Länge $\leq n$ übereinstimmt, also auch $L(M_j^{C\cup D})=\Sigma^*$.
    Da uns $D$ vorliegt, können wir sogar diese Orakelwerte in $M$ hineincodieren, sodass $\smash{M'^C_j(z)}$ äquivalent arbeitet. Und da $\smash{\P^C=\mathrm{PSPACE}^C}$, können wir in $\FP^O$ auch einen akzeptierenden Rechenweg von $M'^C_j(x)$ bestimmen.

    \noindent
    \SetKwFor{Loop}{repeat}{}{end}
    \begin{algorithm}[H]
        $D\gets \{ w\mid w\in O, |w|\leq n, \exists i.|w|=e(i)\}$\;
        \Loop{}{
            Sei $\alpha$ ein akzeptierender Rechenweg auf $M_j^{C\cup D}(x)$ und $Q$ die Menge an Orakelfragen\;
            \eIf{existiert eine Frage $q\in Q$ für die $q\in O-C$ aber $q\not\in D$}
            {
                $D\gets D \cup \{q\}$\;
            }
            {
                \Return{$\alpha$}
            }
        }
    \end{algorithm}

    Korrektheit: Beobachte zunächst die Invariante dass $D\subseteq O\cap \{ w \mid \exists i.|w|=e(i)\}$.
    Wie oben argumentiert gilt außerdem, dass $C\cup D\subseteq O$ und mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern der Länge $\leq n$ übereinstimmt. Damit $L(M_j^{C\cup D})=\Sigma^*$ und insbesondere existiert dann auch ein akzeptierender Rechenweg auf $M_j^{C\cup D}(x)$, und Zeile 3 wohldefiniert.

    Terminiert nun der Algorithmus mit einem Rechenweg $\alpha$, wissen wir auch dass für alle Orakelfragen $q\in Q$ entweder $q\in C$ gilt oder $q\not\in O$ oder $q\in O, D$ gilt.
    Damit stimmt $C\cup D$ mit $O$ auf $Q$ überein, und auch $M_j^O(x)$ akzeptiert mit Rechenweg $\alpha$.

    Laufzeit: Wir zeigen dass der Algorithmus in polynomiell beschränkter deterministischer Zeit (abhängig von $|x|$) relativ zu $O$ arbeitet. 
    Wir wissen, dass für jede Orakelfrage $q\in Q$ gilt, dass $|q|\leq p_j(|x|)$.
    Zusammen mit o.g. Invariante gilt $D\subseteq O\cap \{w \mid \exists i.|w|=e(i)\leq p_j(|x|)\}$.
    Nach V2 gilt damit $\ell(D)\leq p_j(|x|)\cdot p_j(|x|)\cdot 2$, denn in den je $\leq p_j(|x|)$ Ebenen der Länge $e(i)\leq p_j(|x|)$ existieren höchstens zwei Wörter der Länge $e(i)\leq p_j(|x|)$.
    Damit folgt auch unmittelbar, dass der Algorithmus nach höchstens polynomiell vielen Iterationen terminiert.

    Zeile 3 kann damit auch in polynomiell beschränkter deterministischer Zeit berechnet werden. Wie oben skizziert kann der Rechenweg in deterministisch polynomieller Zeit abh. von $|x|$ und $\ell(D)$ relativ zu $C$ bestimmt werden.
    Nach Konstruktion ist leicht zu sehen, dass dieser Rechenweg dann auch relativ zu $O$ bestimmt werden kann.
\end{proof}

\clearpage

\section{Orakel mit $\hDisjCoNP$ und $\hDisjNP$ und $\P=\UP$ ($O_2$)}

Sei $e(0)=2, e(i+1)=2^{2^{e(i)}}$. (Doppelt exponentiell!) Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmenge von $e(\mathbb N)$. (Ebenen $H_m$ gehören zur Zeugensprache bzgl. Disj(Co)NP-Maschinenpaar $M_a, M_b$.)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.
Definiere folgende Zeugensprachen:
\begin{gather*}
    A_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{für alle $x\in \Sigma^{n}$ gilt } x\in O \rightarrow \text{ $x$ endet mit $0$} \}\\
    B_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{für alle $x\in \Sigma^{n}$ gilt } x\in O \rightarrow \text{ $x$ endet mit $1$} \}\\
    D_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{es existiert ein $x\in \Sigma^{n}$ mit $x\in O$ und $x$ endet mit $0$} \}\\
    \begin{split} E_m^O \coloneqq &\{ 0^n \mid n\in H_m, \text{es existiert ein $x\in \Sigma^{n}$ mit $x\in O$ und $x$ endet mit $1$} \} \\ &\cup \overline{\{ z\in\Sigma^* \mid |z|=e(i) \text{ für ein $i$} \}} \end{split}
\end{gather*}
Fakt: $|O\cap \Sigma^n|\geq 1$ für alle $n\in H_m \implies (A_m^O, B_m^O)\in\DisjCoNP$.\\
Fakt: $O\cap \Sigma^{n-1}0\neq\emptyset$ genau dann wenn  $O\cap \Sigma^{n-1}1=\emptyset$ für alle $n\in H_m \implies \overline{D_m^O}=E_m^O$ und $(D_m^O, E_m^O)\in\DisjNP$ und $D_m^O\in\NP\cap\coNP$.
\medskip

Idee: erreiche entweder dass $M_a$, $M_b$ nicht disjunkt ablehnen (Task $\tau^2_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^2_{a,b,r}$ für Transduktor $F_r$).
Ebenso, für $\hDisjNP$, erreiche entweder dass $M_a$, $M_b$ nicht disjunkt akzeptieren (Task $\tau^3_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^3_{a,b,r}$ für Transduktor $F_r$).

Gleichzeitig versuchen wir für möglichst viele $M_j$ erreichen, dass diese nicht kategorisch sind. (Task $\tau^1_j$)
%Dies hat in gewisser Weise Priorität über die o.g. Diagonalisierung.
Am Ende sind die verbleibenden totalen Maschinen $M^O_j$ sehr speziell, denn sie sind auch für gewisse Teilmengen von $O$ kategorisch.
In Kombination mit dem Fakt dass $\P^C=\mathrm{PSPACE}^C$ können wir relevante Wörter in $O-C$ errechnen und so einen akzeptierenden Weg von $M^O_j(x)$ ausgeben -- damit entscheiden wir $L(M^O_j)$ und haben also auch $\P=\UP$.
\medskip

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^2_{a,b}, \tau^3_{a,b}, \tau^1_j$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

Ein Orakel $w\in\Sigma^*$ ist $t$-valide wenn $t\in\mathcal T$ und folgendes gilt:
\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    %\item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2$.\\
    %    (Orakel $w$ ist dünn auf den Stufen der Länge $e(\cdot)$.)
    \item Wenn $t(\tau^1_j)=0$, dann existiert ein $z$ sodass $M_j^w(z)$ auf zwei Rechenwegen akzeptiert.\\
        ($M_j$ nicht kategorisch relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv ablehnen.\\
        (Wenn $t(\tau^2_{a,b})=0$, dann $(\overline{L(M_a)}, \overline{ L(M_b)})\not\in \DisjCoNP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^2_{a,b})=m$, dann gilt für alle $n\in H_m$: wenn $w$ für alle Wörter der Länge $n$ definiert ist, dann $|\Sigma^n\cap w|\geq 1$.\\
        (Wenn $0<t(\tau^2_{a,b})=m$, dann $(A_m,B_m)\in\DisjCoNP$.)
    \item Wenn $t(\tau^3_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv akzeptieren.\\
        (Wenn $t(\tau^3_{a,b})=0$, dann $({L(M_a)}, { L(M_b)})\not\in \DisjNP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^3_{a,b})=m$, dann gilt für alle $n\in H_m$: wenn $w$ für alle Wörter der Länge $n$ definiert ist, dann entweder $|\Sigma^{n-1}0\cap w|=0$ oder $|\Sigma^{n-1}1\cap w|=0$ aber nicht beides.\\
        (Wenn $0<t(\tau^3_{a,b})=m$, dann $(D_m,E_m)\in\DisjNP, D_m\in\NP\cap\coNP$.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^2_{a,b,r}$ immer nach $\tau^2_{a,b}$, sowie $\tau^3_{a,b,r}$ immer nach $\tau^3_{a,b}$ kommt.
%Wir sagen dass ein Task $\tau$ \emph{priorisierter} als Task $\tau'$ ist, wenn $\tau$ in $T$ vor $\tau'$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

%Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun die Tasks $\{\tau_{(1)}, \tau_{(2)}, \dots, \tau_{(s)}\}$ behandelt -- $\tau^{(s)}$ kommt dazu. Je nach Typ von Task $\tau^{(s)}$ führen wir nun Folgendes durch:
Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_j$: Setze $t'=t_{s-1}\cup\{\tau^1_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 2.1.)

    \item $\tau^2_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^2_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^2_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 2.1.)

    \item $\tau^2_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^2_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in A_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ akzeptiert definitiv relativ zu $w_s$.
            \item $0^n\in B_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ akzeptiert definitiv relativ zu $w_s$.
        \end{itemize} (Das ist möglich nach Behauptung 2.2.)

    \item $\tau^3_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^3_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^3_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^3_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 2.1.)

    \item $\tau^3_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^3_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in D_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ lehnt definitiv relativ zu $w_s$ ab.
            \item $0^n\in E_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ lehnt definitiv relativ zu $w_s$ ab.
        \end{itemize} (Das ist möglich nach Behauptung 2.2.)
\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $b\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^2_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^2_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}
\begin{proof}[Skizze.]
    Direkter Beweis. %Sei $\hat{s}$ die Stufe, in der $\tau^1_{a,b}$ bearbeitet wurde. Beobachte dass $t_{s-1}$ auch $\hat{s}-1$-valide ist.
    Erweitere durch Beauptung 1 das Orakel $w_{s-1}$ so weit zu $u$, dass genau alle Wörter der Länge $<n=e(i)\in H_m$ definiert sind, wobei das $i$ hinreichend groß gewählt wird. Sei $u(X), X\subseteq \Sigma^n$ das Orakel was entsteht, wenn die Stufe $e(i)$ mit genau den Wörtern aus $X$ gefüllt wird, bzw. $u(X)=u\cup X\cup C$.

    Sei $\hat{s}$ die Stufe, in der $\tau^2_{a,b}$ bearbeitet wurde.
    Da nach Behauptung 2.1 $u$ auch $t_{s-1}$ valide ist, ist es auch $t_{\hat{s}-1}$-valide.
    Es ist sogar $u(\emptyset)$ auch $t_{\hat{s}-1}$-valide, denn $t_{\hat{s}-1}(\tau^2_{a,b})$ ist undefiniert.

    Sei $y=T_r(0^n)$.
    Wir wissen, dass eine der Maschinen $M_a(y)$ oder $M_b(y)$ relativ zu $u(\emptyset)$ akzeptieren muss.
    Andernfalls wäre $u(\emptyset)$ ein geeignetes Orakel zur Zerstörung des Paars $M_a$, $M_b$ in der Bearbeitung von Task $\tau^2_{a,b}$ und wir hätten $t_{s-1}(\tau^2_{a,b})=0$.

    Ohne Beschränkung akzeptiert also $M_a(y)^{u(\emptyset)}$ auf einem Rechenweg mit polynomiell vielen Orakelfragen $Q$.
    Wähle ein $\alpha\in \Sigma^n-Q$ was mit $0$ endet. Dann akzeptiert auch $M_a(y)^{u(\{\alpha\})}$ auf dem gleichen Rechenweg und $0^n\in A_m^{u(\{\alpha\})}$. Es ist leicht zu sehen, dass $u(\{\alpha\})$ auch $t_{s}$-valide ist.
\end{proof}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^3_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^3_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}

Damit ist die Konstruktion möglich. Sei $O=\lim_{s\to\infty} w_s$.

\begin{claim}
    Kein Paar aus $\DisjCoNP^O$ ist $\leqmpp$-vollständig.
\end{claim}
\begin{claim}
    Kein Paar aus $\DisjNP^O$ ist $\leqmpp$-hart für $\NP^O\cap\coNP^O$.
    Damit gilt im Übrigen dass keine Sprache aus $\NP^O\cap\coNP^O$ auch $\leqmp$-vollständig ist.
\end{claim}

Wir wollen nun zeigen, dass wir UP-Sprachen in P entscheiden können. Sei im Folgenden $M_j$ eine kategorische Maschine relativ zu $O$. Um $x\in L(M_j)$ zu entscheiden nutzen wir aus, dass $\mathrm{PSPACE}^C=\P^C$, um so iterativ eine Menge $D\subseteq O$ an Orakelwörtern der Länge $e(\cdot)$ aufbauen, welche für die Berechnung $M_j(x)$ relevant ist, bis wir nach einigen Iterationen alle solchen relevanten Wörter gefunden haben. 
Wir beschränken uns im Folgenden auf Eingaben hinreichender Länge, sodass es für $x$ ein eindeutiges $i$ gibt, sodass
\[ e(i-1) \leq \log(|x|) < e(i), \quad 2p_j(|x|)< 2^{e(i)-1} < e(i+1).\tag{\ast} \]

Wir definieren Folgendes: %Seien $W,W'\subseteq \{q\in \Sigma^*\mid \exists i.|q|=e(i)\}$ zwei disjunkte Mengen mit $W\subseteq O,$ $W'\subseteq \overline{O}$.
Eine \emph{$(U, W, W')$ respektierende akzeptierende Berechnung $P$ von $M_j$ auf Eingabe $x$} ist ein akzeptierender Rechenweg $P$ von $M_j(x)$ relativ zu einem Orakel $v\subseteq\Sigma^*$, wobei 
\[ U, W,W'\subseteq \Sigma^{e(i)}, \quad W\subseteq O, \quad W'\subseteq\overline{O} \]
und für $v$ gilt:
\begin{enumerate}[noitemsep,label=\arabic*.]
    \item $v$ ist definiert für genau die Wörter der Länge $\leq p_j(|x|)$.
    \item $v(q)=O(q)$ für alle $q$ mit $|q|\neq  e(i)$, wobei hier das $i$ diejenige eindeutige Zahl ist für die obigen Ungleichungen ($\ast$) bzgl. $|x|$ gelten.
    \item $v(q)=1$ für alle $q$ mit $q\in W$.
    \item $v(q)=0$ für alle $q$ mit $q\in W'$.
    \item $v(q)=1 \implies q\in U$ für alle $q\in\Sigma^{e(i)}$. [$v$ enthält auf Ebene $e(i)$ nur Wörter, die auch in $U$ vorkommen.]
\end{enumerate}

Sei $P^\mathrm{all}$ die Menge der Orakelfragen auf $P$, und sei $P^\mathrm{yes}=P^\mathrm{all}\cap v$, $P^\mathrm{no}=P^\mathrm{all}\cap \overline{v}$.
Beob. dass für festes $U=\Sigma^{e(i)}$ (bzw. $U=\Sigma^{e(i)-1}0$, $U=\Sigma^{e(i)-1}1$) wegen $\mathrm{PSPACE}^C=\P^C$ das Ermitteln einer $(U, W, W')$ respektierenden akzeptierenden Berechnung einfach in Polynomialzeit (abh. von $|x|$ und $\ell(W),\ell(W')$) relativ zu $O$ möglich ist: insbesondere stimmt $O$ mit $C$ auf Wörtern der Länge $\neq e(\cdot)$ überein, und alle anderen Wörter der Länge $e(0), e(1), \dots, e(i-1)$ können vorab mit Queries an $O$ in Polynomialzeit erfragt werden.
Entsprechende Belegungen von $v$ für Wörter der Länge $e(i)$ können z.B. in PSPACE enumeriert werden.

Sei $s$ die Stufe bei der $\tau^1_j$ betrachtet wurde.
Zusätzlich zur Einschränkung $(\ast)$ diskutieren wir ab jetzt nur noch Eingaben, für welche das Orakel $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert.
Sei $M=\bigcup \{ H_m \mid t_s(\tau^3_{a,b})=m>0 \}$ eine Menge an Ebenen, welche einer DisjNP-Zeugensprache \emph{in Stufe $s$} zugewiesen ist.
Beob. dass $M\in \P$, denn es sind höchstens endlich viele $H_m$ in der Vereinigung, welche je in $\P$ entscheidbar sind.
\marginnote{Wie Nutzen der Menge $U$ erklären?}


\begin{claim}
    %Sei $M_j$ eine kategorische Maschine relativ zu $O$.
    %Ab hinreichend großer Eingabelänge $n_0$ gilt für alle Eingaben $x$, $|x|\geq n_0$, alle $W, W'$:
    Seien $P_1, P_2$ zwei $(U, W, W')$ respektierenden akzeptierenden Berechnungen von $M_j$ auf Eingabe $x$.
    %Folgende Aussage gilt uneingeschränkt falls $e(i)\not\in M$, und sonst falls $e(i)\in M$ dann mit der Einschränkung dass $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$ gelten muss.
    Folgende Aussage gilt jeweils bezüglich dieser beiden Einschränkungen auf $U$:
    \begin{itemize}[nosep]
        \item $e(i)\in M$, sowie $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$,
        \item $e(i)\not\in M$ und $U=\Sigma^{e(i)}$.
    \end{itemize}

    Wenn $P^\mathrm{all}_1$ und $P^\mathrm{all}_2$ beide je eine (nicht notwendigerweise identische) Orakelfrage $q_1, q_2$ der Länge $e(i)$ enthalten, welche in $U-(W\cup W')$ liegt, dann haben diese zwei Berechnungen eine (identische) Orakelfrage $q$ der Länge $e(i)$ gemeinsam, welche in $U-(W\cup W')$ liegt.
\end{claim}
\begin{proof}[Skizze.]
    Wir beweisen zunächst den ersten Fall.
    Angenommen, dies gilt nicht, also sei $x$ sowie $U,W,W'\subseteq \Sigma^{e(i)}$, $W\subseteq O$, $W'\subseteq\overline{O}$ gegeben.
    Seien außerdem $P_1$ und $P_2$ zwei $(U, W, W')$ respektierenden akzeptierenden Berechnungen von $M_j$ auf Eingabe $x$,
    welche je eine Orakelfrage der Länge $e(i)$ enthalten, welche nicht in $W\cup W'$ liegt,
    aber keine Orakelfrage aus $U-(W\cup W')$ gemeinsam haben.
    Dann sind schon $P_1$ und $P_2$ verschieden.
    Seien ferner $v_1, v_2$ die zugehörigen Orakel, also für welche $M_j(x)$ akzeptiert und Eigenschaften~1--4 erfüllen.

    Wir werden nun ein $t_{s-1}$-valides Orakel $u\sqsupsetneq w_{s-1}$ konstruieren welches mit $v_1$ auf $P^\mathrm{all}_1$ übereinstimmt, und welches mit $v_2$ auf $P^\mathrm{all}_2$ übereinstimmt.
    Außerdem wird es auf Ebene $\Sigma^{e(i)}$ nur Wörter aus $U$ enthalten, woraus wir zeigen können dass $u$ sogar ein geeignetes Orakel zur Zerstörung der UP-Machine in der Bearbeitung von Task $\tau^2_{j}$ in Stufe $s$ ist, ohne Beschränkungen bzgl. DisjNP-Zeugensprachen zu verletzen. Insbesondere akzeptiert dann auch $M_j^O(x)$ auf den zwei verschiedenen Rechenwegen $P_1$, $P_2$, was der Voraussetzung widerspricht.

    %Setze $D=(\Sigma^{e(i)}\cap P^\mathrm{yes}_1) \cup (\Sigma^{e(i)}\cap P^\mathrm{yes}_2) \cup \{\alpha\}$ wobei $\alpha\in \Sigma^{e(i)}-(P^\mathrm{all}_1\cup P^\mathrm{all}_2)$.
    Sei $Y=(P^\mathrm{yes}_1\cup P^\mathrm{yes}_2)\cap\Sigma^{e(i)}$, und $N=(P^\mathrm{no}_1\cup P^\mathrm{no}_2)\cap\Sigma^{e(i)}$.
    Wir zeigen $Y\cap N = \emptyset$. (Das soll uns helfen nachzuweisen, dass ein geeignetes $u$ existieren kann.)
    Nehme an es gibt ein $q\in Y\cap N$ der Länge $e(i)$.
    \begin{itemize}[noitemsep]
        \item Ist $q\not\in U$ dann schon sofort dass $q\not\in P^\mathrm{yes}, P^\mathrm{yes}_2$ was $q\in N$ widerspricht.
        \item Ist $q\in W$ dann gilt schon sofort dass $q\not\in P^\mathrm{no}, P^\mathrm{no}_2$ was $q\in N$ widerspricht.
        \item Ist $q\in W'$ dann gilt schon sofort dass $q\not\in P^\mathrm{yes}, P^\mathrm{yes}_2$ was $q\in Y$ widerspricht.
        \item Andernfalls ist $q\in U-( W\cup W')$, dann gilt $q\in P^\mathrm{yes}_1\cap P^\mathrm{no}_2$ oder $q\in P^\mathrm{yes}_2\cap P^\mathrm{no}_1$.
            In beiden Fällen hätten wir aber, dass $P_1$ und $P_2$ eine Orakelfrage der Länge $e(i)$ teilen, welche in $U-(W\cup W')$ liegt. Das widerspricht der urpsrünglichen Annahme.
    \end{itemize}

    Es gilt also $Y\cap N =\emptyset$. Wir beobachten außerdem dass $Y\subseteq U$ nach Punkt~5 der Definition gilt. Wähle ein $\alpha\in U-N$. Dieses existiert da $|N|\leq 2p_j(|x|)<2^{e(i)-1} = |U|$ nach ($\ast$).
    Sei nun $u$ das Orakel was genau alle Wörter der Länge $\leq p_j(|x|)$ definiert sind, und
    \[ u(z)= \begin{cases} O(z) & \text{falls $|z|\neq e(i)$}\\ 1 & \text{falls $z=\alpha$} \\1 & \text{falls $z\in Y$} \\ 0&\text{sonst,} \end{cases}
    \]
    also wie $O^{\leq p_j(|x|)}$ aufgebaut ist, außer dass die Ebene $e(i)$ mit genau den Wörtern aus $Y$ gefüllt wird. bzw. $u\cap\Sigma^{e(i)} = Y\cup \{\alpha\}$.
    Es ist leicht zu sehen dass $u\sqsupsetneq w_{s-1}$.
    Beob. dass 
    \[ u\cap N = \Sigma^{e(i)}\cap u \cap N = (Y\cup \{\alpha\}) \cap N= Y\cap N=\emptyset.\]

    Das Orakel $u$ stimmt mit $v_1$ auf $P^\mathrm{all}_1$ überein. Sei hierfür $q\in P^\mathrm{all}_1$.
    Ist $|q|\neq e(i)$, dann gilt schon nach Definition $v_1(q)=O(q)=u(q)$. Sei daher im Folgenden $|q|=e(i)$.
    Ist $q\in P^\mathrm{yes}_1$, dann auch $q\in v_1$. Außerdem dann auch $q\in Y$, daher $q\in u$.
    Ansonsten ist $q\in P^\mathrm{no}_1$, dann auch $q\not\in v_1$. Außerdem dann auch $q\in N$, daher $q\not\in u$ nach obiger Beobachtung.
    
    Auf symmetrische Weise stimmt $u$ mit $v_2$ auf $P^\mathrm{all}_2$ überein.
    Wir zeigen nun dass $u$ auch $t_{s-1}$-valide ist.
    Nach obiger Argumentation wäre dann $u$ eine geeignete Erweiterung von $w_{s-1}$ für welche $M_j^O(x)$ nicht mehr kategorisch ist, was der Wahl von $M_j^O(x)$ widerspricht.

    Nach Konstruktion ist V1 erfüllt; V2, V3, V5 sind wegen $u\sqsupsetneq w_{s-1}$ erfüllt. Angenommen V3 ist verletzt. Dies kann nur an der Ebene $e(i)$ liegen. Aber dann wäre $e(i)\in H_{m}$ mit $m=t_{s-1}(\tau^2_{a,b})$ und $e(i) \not\in M$; Widerspruch zur Einschränkung.

    Angenommen V5 ist verletzt.
    Wieder kann das nur an der Ebene $e(i)$ liegen.
    Aber hier gilt $u\cap\Sigma^{e(i)}=Y\cap\{\alpha\}\subseteq U$ und nach Wahl von $U$ ist damit $|\Sigma^{n-1}0\cap w|=0$ oder $|\Sigma^{n-1}1\cap w|=0$ aber nicht beides, ist ja $\alpha\in u\cap\Sigma^{e(i)}$.
    \medskip

    Wir beweisen jetzt den zweiten Fall. Hier läuft die Konstruktion von $u$ identisch,
    und wieder gilt dass $u$ mit $v_1$ auf $P^\mathrm{all}_1$ übereinstimmt, sowie $u$ mit $v_2$ auf $P^\mathrm{all}_2$ übereinstimmt.
    Nach obiger Argumentation wäre dann $u$ eine geeignete Erweiterung von $w_{s-1}$ für welche $M_j^O(x)$ nicht mehr kategorisch ist, was der Wahl von $M_j^O(x)$ widerspricht.

    Nach Konstruktion ist V1 erfüllt; V2, V3, V5 sind wegen $u\sqsupsetneq w_{s-1}$ erfüllt. Angenommen V5 ist verletzt. Dies kann nur an der Ebene $e(i)$ liegen. Aber dann wäre $e(i)\in H_{m}$ mit $m=t_{s-1}(\tau^3_{a,b})$ und $e(i)\in M$; Widerspruch zur Einschränkung.

    Angenommen V3 ist verletzt.
    Wieder kann das nur an der Ebene $e(i)$ liegen.
    Aber hier gilt $u\cap\Sigma^{e(i)}=Y\cap\{\alpha\}$ und nach Wahl von $U$ ist damit $|\Sigma^{n}\cap w|>0$, ist ja $\alpha\in u\cap\Sigma^{e(i)}$.
\end{proof}

\begin{claim}
    $\P=\UP$ relativ zu $O$.
\end{claim}
\begin{proof}[Skizze.]
    Sei $S\in \UP^O$. Es existiert nach Definition eine Maschine $M_j$ mit $L(M_j)^O=S$.
    Wir zeigen für hinreichend lange $x$ wie man $x\in S$ in Polyonmialzeit relativ zu $O$ entscheiden kann.
    
    Sei im Folgenden $x$ hinreichend lange wie oben diskutiert, also für dieses $(\ast)$ mit eindeutigem $i$ gilt, sowie $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert, wobei $s$ die Stufe ist, bei der $\tau^2_j$ betrachtet wurde.
    Sei wieder $M=\bigcup \{ H_m \mid t_s(\tau^3_{a,b})=m>0 \}$.
    Für diese Maschine $M_j$ und eine solche Eingabe $x$ gilt dann Behauptung~2.6.

    Wir werden diese Eigenschaft ausnutzen und iterativ Mengen $W, W'$ aufbauen, welche für die Berechnung $M_j^O(x)$ relevant ist, bis wir alle solchen relevanten Wörter gefunden haben.
    Betrachte dafür zunächst folgende Subroutine:

    \noindent%
    \SetKwProg{Fn}{Function}{:}{}%
    \SetKw{Assert}{assert}%
    \begin{algorithm}[H]
        \Fn{Search($U$)}{
            \Assert{$e(i)\in M\implies (U=\Sigma^{e(i)-1}0 \lor U=\Sigma^{e(i)-1}1)$}\;
        $W\gets\emptyset,\, W'\gets\emptyset$\;
        \For{$k$ von $0$ bis $p_j(|x|)+1$}{
            $P\gets$ eine $(U, W, W')$ respektierende akzeptierende Berechnung $P$ von $M_j$ auf $x$ mit $|(P^\mathrm{all}\cap U)-(W\cup W')|$ minimal, oder $\bot$ falls keine existiert\;
            \If{$P=\bot$}
            {
                \Return{„$x\not\in S$“}
            }
            \If{alle $q\in P^\mathrm{all}$ mit $|q|=e(i)$ sind in $W\cup W'$}{
                \Return{„$x\in S$“}
            }
            \ForEach{$q\in P^\mathrm{all}$ mit $|q|=e(i)$}
            {
                %\lIf{$q\in O-U$}{\Return{„$x\not\in S$“}
                \lIf{$q\in O$}{$W\gets W\cup\{q\}$}
                \lIf{$q\not\in O$}{$W'\gets W'\cup\{q\}$}
            }
            %\If{$P$ ist immer noch eine $(W, W')$ respektierende akzeptierende Berechnung}
            %{
                %\Return{„$x\in S$“}
            %}
        }
        \Return{„$x\not\in S$“}
        }
    \end{algorithm}
    Es ist leicht zu sehen dass der Algorithmus eine polynomielle Laufzeitschranke einhält.
    Wir zeigen nun folgende Aussage: Wenn die Assertion in Z.~2 zutrifft dann macht der Algorithmus keinen falsch-positiv-Fehler. Falls zusätzlich $O\cap \Sigma^{e(i)}\subseteq U$, dann macht der Algorithmus keinen falsch-negativ-Fehler.

    Wir beobachten die Invariante dass $W\subseteq O\cap \Sigma^{e(i)}$ und $W'\subseteq \overline{O}\cap\Sigma^{e(i)}$. 
    Terminiert also der Algorithmus in Z.~10 mit „$x\in S$“ dann ist auch $x\in S$: Sei $v$ das Orakel der $(U, W, W')$ respektierenden akzeptierenden Berechnung $P$ von $M_j(x)$. Es ist nun leicht zu sehen dass $v$ und $O$ auf $P^\mathrm{all}$ übereinstimmen. Damit gilt auch dass $M_j^O(x)$ akzeptiert und damit $x\in S$.
    Der Algorithmus macht also schon mal keinen falsch-positiv-Fehler.

    Es verbleibt zu zeigen dass wenn $x\in S$ und  $O\cap \Sigma^{e(i)}\subseteq U$ dann der Algorithmus auch in Z.~10 mit „$x\in S$“ terminiert, also keinen falsch-negativ-Fehler macht.
    Sei hierfür $P^*$ der längste akzeptierende Rechenweg von $M_j^O(x)$.
    Beob. dass mit der o.\,g. Invariante sowie der Bedingung $O\cap\Sigma^{e(i)}\subseteq U$ gilt, dass $P^*$ auch immer ein $(U,W,W')$ respektierender akzeptierender Rechenweg ist.
    Damit ist die Bedingung in Z.~6 nie erfüllt.
    %Damit ist auch die Bedingugn in Z.~2 immer erfüllt und der Algorithmus terminiert sicher nicht ablehnend in Z.~12.
    Wir zeigen nun noch, dass nach $\leq p_j(|x|)+1$ vielen Iterationen auch die Bedingung in Z.~9 erfüllt ist.
    Hierfür zeigen wir, dass $|(P^{*\mathrm{all}}\cap U)-(W\cup W')|$ in jeder Iteration um $\geq 1$ abnimmt. Da $|P^{*\mathrm{all}}|\leq p_j(|x|)$ ist nach $\leq p_j(|x|)+1$ vielen Iterationen $|(P^{*\mathrm{all}}\cap U)-(W\cup W')|=0$.
    Nach $\leq p_j(|x|)+1$ vielen Iterationen wird also in Z.~5 eine Berechnung $P$ ausgewählt, bei der alle $q\in P^{\mathrm{all}}$ mit $|q|=e(i)$ in $W\cup W'$ liegen. Dann ist die Bedingung in Z.~10 erfüllt und der Algorithmus terminiert akzeptierend.

    Steht der Algorithmus in Z.~12, dann gilt sowohl für das ausgewählte $P$, als auch für $P^*$ dass beide je eine (nicht notwendigerweise identische) Orakelfrage der Länge $e(i)$ enthalten, welche nicht in $W\cup W'$ liegt. (Andernfalls  wäre $P$ in Z.~5 anders ausgewählt worden.)

    Sowohl $P$ als auch $P^*$ sind $(U, W, W')$ respektierende akzeptierende Rechenwege. Nachdem die Assertion gilt, ist Behauptung~2.6 anwendbar. Also haben diese zwei Berechnungen eine identische Orakelfrage $q\in P^\mathrm{all}\cap P^{*\mathrm{all}}\cap \Sigma^{e(i)}$ gemeinsam, welche in $U-(W\cup W')$ liegt.
    Diese wird in den Zz.~12--15 irgendwann der Menge $W\cup W'$ hinzugefügt.
    Damit nimmt auch $|(P^{*\mathrm{all}}\cap U)-(W\cup W')|$ um $\geq 1$ ab, wie behauptet.
    \medskip

    Betrachte nun folgenden Entscheidungsalgorithmus für $S=L(M_j^O)$.

    \noindent
    \begin{algorithm}[H]
        \setcounter{AlgoLine}{17}
        \eIf{$e(i)\in M$}
        {
            \uIf{{Search}($\,\Sigma^{e(i-1)0}$) = „$x\in S$“}
            {
                \Return{„$x\in S$“}
            }
            \uElseIf{{Search}($\,\Sigma^{e(i-1)1}$) = „$x\in S$“}
            {
                \Return{„$x\in S$“}
            }
            \Else{
                \Return{„$x\not\in S$“}
            }
        }
        {
            \Return \emph{Search}($\Sigma^{e(i)}$)\;
        }
        \medskip
    \end{algorithm}

    Es ist leicht zu überprüfen dass in allen Fällen die Subroutine so ausgeführt wird dass die Assertion immer erfüllt ist.
    Ebenso ist leicht zu sehen, dass dieser Algorithmus in Polynomialzeit läuft.

    Wir überprüfen nun Korrektheit in zwei Fällen.
    Im Fall $e(i)\not\in M$ rufen wir die Subroutine mit $U=\Sigma^{e(i)}$ auf, und nach obiger Argumentation macht \emph{Search} sowohl keinen falsch-positiv- also auch keinen falsch-negativ-Fehler.
    Der zurückgegebene Wert ist also korrekt.

    Im Fall $e(i)\in M$ bekommen wir in beiden Aufrufen von \emph{Search} zumindest keinen falsch-positiven Fehler. Wenn also in Zz.~20 oder 22 mit „$x\in S$“ terminiert wird, dann war auch $x\in S$.
    Fener wissen wir wegen $e(i)\in M$ und V6 dass entweder $O\cap\Sigma^{e(i)}\subseteq \Sigma^{e(i)-1}0$ oder $O\cap\Sigma^{e(i)}\subseteq \Sigma^{e(i)-1}1$.
    Wenn also $x\in S$, dann macht einer der Aufrufe von \emph{Search} in Zz.~19 oder 21 keinen falsch-negativ-Fehler und die zugehörige If-Bedingung wird positiv ausfallen, und der Algorithmus terminiert mit „$x\in S$“.
\end{proof}

\clearpage
\section{Orakelkonstruktion $\hDisjNP$, $\P=\UP$, und $Q$}

Sei $e(0)=2, e(i+1)=2^{2^{e(i)}}$. Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmenge von $e(\mathbb N)$. (Ebenen $H_m$ gehören zur Zeugensprache bzgl. DisjNP-Maschinenpaar $M_a, M_b$.)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.
Definiere folgende Zeugensprachen:
        \begin{gather*}
            A_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O \text{ und $x$ endet mit $0$} \}\\
            B_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{existiert $x\in \Sigma^{n}$ mit } x\in O \text{ und $x$ endet mit $1$} \}
        \end{gather*}
        Fakt: wenn $|O\cap \Sigma^{n-1}0|=0$ oder $|O\cap \Sigma^{n-1}1|=0$ für alle $n\in H_m$, dann $(A_m^O, B_m^O)\in\DisjNP^O$.
\medskip

Idee: erreiche entweder dass $M_a$, $M_b$ nicht disjunkt akzeptieren (Task $\tau^1_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^1_{a,b,r}$ für Transduktor $F_r$).

Gleichzeitig versuchen wir für möglichst viele $M_j$ erreichen, dass diese (a) nicht total sind (Task $\tau^2_j$), und diese (b) nicht kategorisch sind (Task $\tau^3_j$).
%Dies hat in gewisser Weise Priorität über die o.g. Diagonalisierung.
Am Ende sind die verbleibenden totalen Maschinen $M^O_j$ sehr speziell, denn sie sind auch für gewisse Teilmengen von $O$ total.
In Kombination mit dem Fakt dass $\P^C=\mathrm{PSPACE}^C$ können wir relevante Wörter in $O-C$ errechnen und so einen akzeptierenden Weg von $M^O_j(x)$ ausgeben -- damit erzielen wir $Q$ bzw. $\P=\UP$.
Besonders aufgepasst muss hier auf den $\UP$-Entscheidungsalgorithmus: im Korrektheitsbeweis müssen wir sicherstellen, dass höchstens polynomiell viele Wörter in eine Ebene gesetzt werden. Das ist etwas schwieriger, weil üblicherweise im Beweis bis zu $2\cdot p_j(|x|)$ Wörter eingesetzt werden (Menge $Y$); und dieses Polynom ist kann nicht von der Eingabelänge allein beschränkt werden da $j$ beliebig.

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^1_{a,b}, \tau^2_j$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    \item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2^{c}$ mit $c=|\{j\mid t(\tau^2_j)=0 \}|$.
        Ferner definiert $w$ alle Wörter der Länge $e(c)$.\\
        (Auf den Ebenen der Länge $e(\cdot)$ sind exponeniell so viele Wörter wie Tasks $\tau^2_j$ „negativ“ behandelt werden. Wir werden sehen dass mit dieser Eigenschaft das Orakel dünn auf Ebenen der Länge $e(\cdot)$ ist.)
    \item Wenn $t(\tau^1_j)=0$, dann existiert ein $z$ sodass $M_j^w(z)$ definitiv ablehnt.\\
        ($L(M_j)\neq \Sigma^*$ relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_j)=0$, dann existiert ein $z$ sodass $M_j^w(z)$ definitiv auf zwei Rechenwegen akzeptiert.\\
        ($M_j$ nicht kategorisch relativ zum finalen Orakel.)
    \item Wenn $t(\tau^3_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv akzeptieren.\\
        (Wenn $t(\tau^3_{a,b})=0$, dann $L(M_a)\cap L(M_b)\neq \emptyset$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^3_{a,b})=m$, dann gilt für alle $n\in H_m$ dass $|\Sigma^{n-1}0\cap w|=0$ oder $|\Sigma^{n-1}1\cap w|=0$.\\
        (Wenn $0<t(\tau^3_{a,b})=m$, dann $(A_m,B_m)\in\DisjNP$.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^3_{a,b,r}$ immer nach $\tau^3_{a,b}$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_j$: Setze $t'=t_{s-1}\cup\{\tau^1_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 3.1.)

    \item $\tau^2_j$: Setze $t'=t_{s-1}\cup\{\tau^2_j\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 3.1.)

    \item $\tau^3_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^3_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^3_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 3.1.)

    \item $\tau^3_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^2_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in A_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
            \item $0^n\in B_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ lehnt relativ zu $w_s$ definitiv ab.
        \end{itemize} (Das ist möglich nach Behauptung 3.2.)
\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $b\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^3_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^3_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}
\begin{proof}[Hinweis.]
    Unterschied ist V2. Trotzdem dürfen wir zwei Wörter in die Ebene einer Stufe $e(i)$ einsetzen, und verletzen dabei V2 nicht.
\end{proof}

Damit ist die Konstruktion möglich. Sei $O=\lim_{s\to\infty} w_s$.

\begin{claim}
    Kein Paar aus $\DisjNP^O$ ist $\leqmpp$-hart für $\DisjUP$.
\end{claim}


\begin{claim}
    Sei $M_j$ eine totale Maschine, d.h. $L(M^O)=\Sigma^*$.
    Es existiert eine Länge $n$ mit folgender Eigenschaft: 
    falls $T\subseteq O$ mit $O$ auf Wörtern der Länge $\neq e(\cdot)$ und Wörtern $\leq n$ übereinstimmt, dann $L(M_j^T)=\Sigma^*$.
\end{claim}

\begin{claim}
    Das Orakel $O$ ist dünn auf den Ebenen der Länge $e(i)$. Insbesondere gilt $|O\cap \Sigma^{e(i)}|\leq e(i)$ für alle $i$.
\end{claim}
\begin{proof}[Skizze.]
    Sein eine Ebene $e(i)$ beliebig.
    Sei $c_k=|\{j\mid t_{k}(\tau^2_j)=0 \}|$.
    Nachdem in der Folge $c_0, c_1, c_2, \dots$ die Terme immer um $\leq 1$ ansteigen, existiert ein kleinstes $s$ sodass $c_s=i$.
    Damit hat nach V2 das Orakel $w_s\sqsubsetneq O$ alle Wörter der Länge $c(i)$ definiert.
    Ferner gilt $|w_s\cap\Sigma^{e(i)}|\leq 2^{c_s}$.
    Also haben wir $|O\cap\Sigma^{e(i)}|=|w_s\cap\Sigma^{e(i)}|\leq 2^{i}\leq e(i)$.
\end{proof}

\begin{claim}
    Sei $M_j$ eine totale Maschine, d.h. $L(M_j^O)=\Sigma^*$. Dann existiert eine Funktion $g\in \FP^O$ sodass $g(x)$ einen akzeptierenden Rechenweg von $M^O_j(x)$ ausgibt. Damit gilt nach Definition die Hypothese $Q$ relativ zu $O$.
\end{claim}
\begin{proof}[Hinweis.]
    Wie im vorigen Abschnitt. Analog gilt für die Menge an erfassten Orakelwörtern $D$ nach V2: $\ell(D) \leq p_j(|x|)\cdot p_j(|x|)\cdot p_j(|x|)$ denn in den je $\leq p_j(|x|)$ Ebenen der Länge $e(i)\leq p_j(|x|)$ existieren nach Behauptung 3.5 höchstens $e(i)\leq p_j(|x|)$ Wörter der Länge $e(i)\leq p_j(|x|)$.
    Damit folgt auch, dass der Algorithmus nach höchstens polynomiell vielen Iterationen terminiert.
\end{proof}

Um $\UP$-Sprache $S=L(M_j^O)$ in $\P$ zu entscheiden, gehen wir wie in vorigem Abschnitt vor.
Sei $s$ die Stufe bei der $\tau^1_j$ betrachtet wurde.
Sei $c=|\{j\mid t_{s-1}(\tau^2_j)=0|$.
Wir beschränken uns im Folgenden wieder auf Eingaben hinreichender Länge, sodass es für $x$ ein eindeutiges $i$ gibt, sodass
\[ e(c+1)\leq e(i), \quad \leq e(i-1) \leq \log(|x|), \quad 2p_j(|x|)< 2^{e(i)-1} < e(i+1).\tag{\ast} \]

Zusätzlich zur Einschränkung $(\ast)$ diskutieren wir ab jetzt nur noch Eingaben, für welche das Orakel $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert.
Sei $M=\bigcup \{ H_m \mid t_s(\tau^3_{a,b})=m>0 \}$ eine Menge an Ebenen, welche einer DisjNP-Zeugensprache \emph{in Stufe $s$} zugewiesen ist.

Wir verfeinern die Definition einer \emph{$(U, W, W')$ respektierende akzeptierende Berechnung $P$ von $M_j$ auf Eingabe $x$}, und verlangen zusätzlich
\begin{enumerate}[label={\arabic*.},nosep]
    \setcounter{enumi}{5}
    \item $|v\cap \Sigma^{e(i)}|\leq 2^{c}$.
\end{enumerate}

\begin{claim}
    %Sei $M_j$ eine kategorische Maschine relativ zu $O$.
    %Ab hinreichend großer Eingabelänge $n_0$ gilt für alle Eingaben $x$, $|x|\geq n_0$, alle $W, W'$:
    Seien $P_1, P_2$ zwei $(U, W, W')$ respektierenden akzeptierenden Berechnungen von $M_j$ auf Eingabe $x$.
    %Folgende Aussage gilt uneingeschränkt falls $e(i)\not\in M$, und sonst falls $e(i)\in M$ dann mit der Einschränkung dass $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$ gelten muss.
    Folgende Aussage gilt jeweils bezüglich dieser beiden Einschränkungen auf $U$:
    \begin{itemize}[nosep]
        \item $e(i)\in M$ und $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$,
        \item $e(i)\not\in M$ und $U=\Sigma^{e(i)}$.
    \end{itemize}

    Wenn $P^\mathrm{all}_1$ und $P^\mathrm{all}_2$ beide je eine (nicht notwendigerweise identische) Orakelfrage $q_1, q_2$ der Länge $e(i)$ enthalten, welche in $U-(W\cup W')$ liegt, dann haben diese zwei Berechnungen eine (identische) Orakelfrage $q$ der Länge $e(i)$ gemeinsam, welche nicht in $W\cup W'$ liegt.
\end{claim}
\begin{proof}[Skizze.]
    Wieder beweisen wir zunächst den ersten Fall, der zweite Fall ist noch leichter.
    Wir konstruieren ein $u$ ähnlich wie im originalen Beweis, verzichten aber auf das zusätzliche Wort $\alpha$, also sodass $u\cap\Sigma^{e(i)}=Y\subseteq U$.

    Es gilt dass $u$ mit $v_1$ auf $P^\mathrm{all}_1$ übereinstimmt, sowie $u$ mit $v_2$ auf $P^\mathrm{all}_2$ übereinstimmt.
    Sei $t'=t_{s-1}\cup \{\tau^2_j\mapsto 0\}$.
    Wir zeigen dass $u$ auch $t'$-valide ist
    Damit wäre $u$ dann eine geeignete Erweiterung von $w_{s-1}$ in Bearbeitung von Task $\tau^2_j$, für welche $M_j^O(x)$ nicht mehr kategorisch ist, was der Wahl von $M_j^O(x)$ widerspricht.

    Beob. dass $|P^\mathrm{yes}_1|,|P^\mathrm{yes}_2|\leq 2^{c}$,
    damit gilt $|u\cap\Sigma^{e(i)}|=|Y|\leq 2^{c+1}$.
    Aber nun gilt $c'=|\{j\mid t'(\tau^2_j)=0\}|=c+1$, damit $|u\cap\Sigma^{e(i)}|\leq 2^{c'}$.
    Außerdem definiert $u$ nach Konstruktion alle Wörter der Länge $e(i)\geq e(c+1)=e(c')$ und $u$ erfüllt damit auf jeden Fall V2.
    Es ist nun auch leicht zu sehen, dass V1, V3, V4, V5, V6 erfüllt sind, daher ist $u$ wie behauptet $t'$-valide.
    \medskip
\end{proof}

Damit gilt mit gleichem Verfahren

\begin{claim}
    $\P=\UP$ relativ zu $O$.
\end{claim}

\clearpage
\section{Orakel mit $\hDisjCoNP$ und alle Paare aus $\DisjNP$ sind $\P$-separierbar ($O_3$)}

Sei $e(0)=2, e(i+1)=2^{2^{e(i)}}$. (Doppelt exponentiell!) Sei hier $\{H_m\}_{m\in\mathbb N}$ eine Familie von paarweise disjunkten, unendlichen Teilmenge von $e(\mathbb N)$. (Ebenen $H_m$ gehören zur Zeugensprache bzgl. DisjCoNP-Maschinenpaar $M_a, M_b$.)
Starte mit $\mathrm{PSPACE}$-vollständiger Menge $C$ welche keine Wörter der Länge $e(\cdot)$ enthält.
Definiere folgende Zeugensprachen:
\begin{gather*}
    A_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{für alle $x\in \Sigma^{n}$ gilt } x\in O \rightarrow \text{ $x$ endet mit $0$} \}\\
    B_m^O \coloneqq \{ 0^n \mid n\in H_m, \text{für alle $x\in \Sigma^{n}$ gilt } x\in O \rightarrow \text{ $x$ endet mit $1$} \}
\end{gather*}
Fakt: $|O\cap \Sigma^n|\geq 1$ für alle $n\in H_m \implies (A_m^O, B_m^O)\in\DisjCoNP$.
\medskip

Idee: erreiche entweder dass $M_a$, $M_b$ nicht disjunkt ablehnen (Task $\tau^2_{a,b}$), oder dass das Zeugenpaar $(A_m,B_m)$ nicht auf $(L(M_a),L(M_b))$ reduzierbar ist (Task $\tau^2_{a,b,r}$ für Transduktor $F_r$).

Gleichzeitig versuchen wir für möglichst viele Paare $M_a, M_b$ zu erreichen, dass diese nicht disjunkt akzeptieren. (Task $\tau^1_{a,b}$)
%Dies hat in gewisser Weise Priorität über die o.g. Diagonalisierung.
Am Ende sind die verbleibenden Maschinenpaare $M_a^O, M_b^O$ sehr speziell, denn sie sind auch für gewisse Teilmengen von $O$ kategorisch.
In Kombination mit dem Fakt dass $\P^C=\mathrm{PSPACE}^C$ können wir relevante Wörter in $O-C$ errechnen und so $L(M_a^O)$ von $L(M_b^O)$ trennen.
\medskip

Sei wie üblich $t\in \mathcal T$ wenn der Definitionsbereich endlich ist, nur die Tasks der Form $\tau^1_{a,b}, \tau^2_{a,b}$ enthält, $t$ diese Tasks auf $\mathbb N$ abbildet, und injektiv auf dem Support ist.

Ein Orakel $w\in\Sigma^*$ ist $t$-valide wenn $t\in\mathcal T$ und folgendes gilt:
\begin{enumerate}[label={V\arabic*}]
    \item Wenn $x<|w|$ und $|x|\not\in e(\mathbb N)$, dann gilt $x\in w\iff x\in C$.\\
        (Orakel $w$ und $C$ stimmen auf Wörtern mit Länge $\neq e(\cdot)$ überein.)
    %\item Für alle $n=e(i)$ gilt $|w\cap \Sigma^n|\leq 2$.\\
    %    (Orakel $w$ ist dünn auf den Stufen der Länge $e(\cdot)$.)
    \item Wenn $t(\tau^1_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv akzeptieren.\\
        ($M_a, M_b$ nicht disjunkt relativ zum finalen Orakel.)
    \item Wenn $t(\tau^2_{a,b})=0$, dann existiert ein $z$ sodass $M_a^w(z)$ und $M_b^w(z)$ definitiv ablehnen.\\
        (Wenn $t(\tau^2_{a,b})=0$, dann $(\overline{L(M_a)}, \overline{ L(M_b)})\not\in \DisjCoNP$ relativ zum finalen Orakel.)
    \item Wenn $0<t(\tau^2_{a,b})=m$, dann gilt für alle $n\in H_m$: wenn $w$ für alle Wörter der Länge $n$ definiert ist, dann $|\Sigma^n\cap w|\geq 1$.\\
        (Wenn $0<t(\tau^2_{a,b})=m$, dann $(A_m,B_m)\in\DisjCoNP$.)
\end{enumerate}

Sei $T$ eine abzählbare Aufzählung der o.g. Tasks sodass $\tau^2_{a,b,r}$ immer nach $\tau^2_{a,b}$ kommt.
%Wir sagen dass ein Task $\tau$ \emph{priorisierter} als Task $\tau'$ ist, wenn $\tau$ in $T$ vor $\tau'$ kommt.

[ . . . Üblicher Text zur stufenweisen Erweiterung von $w_s$ und $t_s$ . . . ]

%Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun die Tasks $\{\tau_{(1)}, \tau_{(2)}, \dots, \tau_{(s)}\}$ behandelt -- $\tau^{(s)}$ kommt dazu. Je nach Typ von Task $\tau^{(s)}$ führen wir nun Folgendes durch:
Wir definieren nun Stufe $s>0$, diese startet mit einem $t_{s-1}\in\mathcal T$ und eine $t_{s-1}$-validen Orakel $w_{s-1}$ welche nun den kleinsten Task bearbeitet, welcher noch in $T$ ist. Dieser wird unmittelbar nach der Bearbeitung aus $T$ entfernt. In der Bearbeitung wird das Orakel strikt verlängert.
\begin{itemize}

    \item $\tau^1_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^1_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$.

        Ansonsten setze $t_s\coloneqq t_{s-1}$ und setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 4.1.)

    \item $\tau^2_{a,b}$: Setze $t'=t_{s-1}\cup\{\tau^2_{a,b}\mapsto 0\}$. Existiert ein $t'$-valides Orakel $v\sqsupsetneq w_{s-1}$, dann setze $t_s\coloneqq t'$ und $w_s\coloneqq v$. Entferne außerdem alle Tasks der Form $\tau^2_{a,b,r}$ von $T$.

        Ansonsten wähle ein hinreichend großes $m\not\in \img(t_s)$ sodass $w_s$ kein Wort der Länge $\min H_m$ definiert. Setze $t_s\coloneqq t_{s-1}\cup \{ \tau^2_{a,b}\mapsto m \}$; damit ist $w_{s-1}$ auch $t_s$-valide. Setze $w_s\coloneqq w_{s-1}y$ für geeignetes $y\in\{0,1\}$ sodass $w_s$ auch $t_s$-valide ist. (Das ist möglich nach Behauptung 4.1.)

    \item $\tau^2_{a,b,r}$: Wir wissen dass $t_{s-1}(\tau^2_{a,b})=m>0$. Setze $t_s=t_{s-1}$ und wähle ein $t_s$-valides Orakel $w_s\sqsupsetneq w_{s-1}$ sodass bezüglich einem $n\in\mathbb N$ eine der folgenden Aussagen gilt:
        \begin{itemize}[nosep,endpenalty=10000]
            \item $0^n\in A_m^v$ für alle $v\sqsupseteq w_s$ und $M_a(F_r(0^n))$ akzeptiert definitiv relativ zu $w_s$.
            \item $0^n\in B_m^v$ für alle $v\sqsupseteq w_s$ und $M_b(F_r(0^n))$ akzeptiert definitiv relativ zu $w_s$.
        \end{itemize} (Das ist möglich nach Behauptung 4.2.)
\end{itemize}

\begin{claim}
    Für jedes $t\in\mathcal T$ und jedes $t$-valide $w$ existiert ein $b\in\{0,1\}$ sodass $wb$ auch $t$-valide ist.
\end{claim}

\begin{claim}
    Die Bearbeitung eines Tasks $\tau^2_{a,b,r}$ ist möglich: gilt $t_{s-1}(\tau^2_{a,b})=m>0$, dann lässt sich $w_{s-1}$ so zu $t_{s-1}$-validem $u\sqsupsetneq w_{s-1}$ erweitern, dass eine der o.g. Fälle eintritt.
\end{claim}

Damit ist die Konstruktion möglich. Sei $O=\lim_{s\to\infty} w_s$.

\begin{claim}
    Kein Paar aus $\DisjCoNP^O$ ist $\leqmpp$-vollständig.
\end{claim}

Wir wollen nun zeigen, dass wir disjunkte Paare von NP-Sprachen in P separieren können. Sei im Folgenden $M_a, M_b$ ein komplementär akzeptierendes Paar an Maschine relativ zu $O$. Um die Sprachen zu trennen nutzen wir aus, dass $\mathrm{PSPACE}^C=\P^C$, um so iterativ eine Menge $D\subseteq O$ an Orakelwörtern der Länge $e(\cdot)$ aufbauen, welche für die Berechnungen $M_a(x), M_b(x)$ relevant ist, bis wir nach einigen Iterationen alle solchen relevanten Wörter gefunden haben. 
Wir beschränken uns im Folgenden auf Eingaben hinreichender Länge, sodass es für $x$ ein eindeutiges $i$ gibt, sodass
\[ e(i-1) \leq \log(|x|) < e(i), \quad p_a(|x|)+p_b(|x|)< 2^{e(i)} < e(i+1).\tag{\ast} \]

Wir definieren Folgendes: %Seien $W,W'\subseteq \{q\in \Sigma^*\mid \exists i.|q|=e(i)\}$ zwei disjunkte Mengen mit $W\subseteq O,$ $W'\subseteq \overline{O}$.
Sei $j\in \{a,b\}$
Eine \emph{$(W, W')$ respektierende akzeptierende Berechnung $P$ von $M_j$ auf Eingabe $x$} ist ein akzeptierender Rechenweg $P$ von $M_j(x)$ relativ zu einem Orakel $v\subseteq\Sigma^*$, wobei 
\[ W,W'\subseteq \Sigma^{e(i)}, \quad W\subseteq O, \quad W'\subseteq\overline{O} \]
und für $v$ gilt:
\begin{enumerate}[noitemsep,label=\arabic*.]
    \item $v$ ist definiert für genau die Wörter der Länge $\leq p_j(|x|)$.
    \item $v(q)=O(q)$ für alle $q$ mit $|q|\neq  e(i)$, wobei hier das $i$ diejenige eindeutige Zahl ist für die obigen Ungleichungen ($\ast$) bzgl. $|x|$ gelten.
    \item $v(q)=1$ für alle $q$ mit $q\in W$.
    \item $v(q)=0$ für alle $q$ mit $q\in W'$.
    %\item $v(q)=1 \implies q\in U$ für alle $q\in\Sigma^{e(i)}$. [$v$ enthält auf Ebene $e(i)$ nur Wörter, die auch in $U$ vorkommen.]
\end{enumerate}

Sei $P^\mathrm{all}$ die Menge der Orakelfragen auf $P$, und sei $P^\mathrm{yes}=P^\mathrm{all}\cap v$, $P^\mathrm{no}=P^\mathrm{all}\cap \overline{v}$.
Beob. dass  das Ermitteln einer $(W, W')$ respektierenden akzeptierenden Berechnung einfach in Polynomialzeit (abh. von $|x|$ und $\ell(W),\ell(W')$) relativ zu $O$ möglich ist: insbesondere stimmt $O$ mit $C$ auf Wörtern der Länge $\neq e(\cdot)$ überein, und alle anderen Wörter der Länge $e(0), e(1), \dots, e(i-1)$ können vorab mit Queries an $O$ in Polynomialzeit erfragt werden.
Entsprechende Belegungen von $v$ für Wörter der Länge $e(i)$ können z.B. in PSPACE enumeriert werden.

Sei $s$ die Stufe bei der $\tau^1_{a,b}$ betrachtet wurde.
Zusätzlich zur Einschränkung $(\ast)$ diskutieren wir ab jetzt nur noch Eingaben, für welche das Orakel $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert.


\begin{claim}
    %Sei $M_j$ eine kategorische Maschine relativ zu $O$.
    %Ab hinreichend großer Eingabelänge $n_0$ gilt für alle Eingaben $x$, $|x|\geq n_0$, alle $W, W'$:
    Seien $P_a, P_b$ je $(W, W')$ respektierenden akzeptierenden Berechnungen von $M_a$ bzw. $M_b$ auf Eingabe $x$.
    %Folgende Aussage gilt uneingeschränkt falls $e(i)\not\in M$, und sonst falls $e(i)\in M$ dann mit der Einschränkung dass $U=\Sigma^{e(i)-1}0$ oder $U=\Sigma^{e(i)-1}1$ gelten muss.
    Wenn $P^\mathrm{all}_a$ und $P^\mathrm{all}_b$ beide je eine (nicht notwendigerweise identische) Orakelfrage $q_a, q_b$ der Länge $e(i)$ enthalten, welche in $\Sigma^{e(i)}-(W\cup W')$ liegt, dann haben diese zwei Berechnungen eine (identische) Orakelfrage $q$ der Länge $e(i)$ gemeinsam, welche nicht in $W\cup W'$ liegt.
\end{claim}
\begin{proof}[Skizze.]
    Angenommen, dies gilt nicht, also sei $x$ sowie $W,W'\subseteq \Sigma^{e(i)}$, $W\subseteq O$, $W'\subseteq\overline{O}$ gegeben.
    Seien außerdem $P_a$ und $P_b$ je zwei $(W, W')$ respektierenden akzeptierenden Berechnungen von $M_a$, $M_b$ auf Eingabe $x$,
    welche je eine Orakelfrage der Länge $e(i)$ enthalten, welche nicht in $W\cup W'$ liegt,
    aber keine Orakelfrage aus $\Sigma^{e(i)}-(W\cup W')$ gemeinsam haben.
    Dann sind schon $P_a$ und $P_b$ verschieden.
    Seien ferner $v_a, v_b$ die zugehörigen Orakel, also für welche $M_j(x)$ akzeptiert und Eigenschaften~1--4 erfüllen.

    Wir werden nun ein $t_{s-1}$-valides Orakel $u\sqsupsetneq w_{s-1}$ konstruieren welches mit $v_a$ auf $P^\mathrm{all}_b$ übereinstimmt, und welches mit $v_b$ auf $P^\mathrm{all}_b$ übereinstimmt.
    Außerdem wird es auf Ebene $\Sigma^{e(i)}$ mindestens ein Wort enthalten, woraus wir zeigen können dass $u$ sogar ein geeignetes Orakel zur Zerstörung dieses DisjNP-Machinenpaars in der Bearbeitung von Task $\tau^1_{a,b}$ in Stufe $s$ ist, ohne Beschränkungen bzgl. DisjCoNP-Zeugensprachen zu verletzen. Insbesondere akzeptiert dann sowohl $M_a^O(x)$ als auch $M_b^O(x)$ was der Voraussetzung widerspricht.

    Sei $Y=(P^\mathrm{yes}_a\cup P^\mathrm{yes}_b)\cap\Sigma^{e(i)}$, und $N=(P^\mathrm{no}_a\cup P^\mathrm{no}_b)\cap\Sigma^{e(i)}$.
    Wir zeigen $Y\cap N = \emptyset$. (Das soll uns helfen nachzuweisen, dass ein geeignetes $u$ existieren kann.)
    Nehme an es gibt ein $q\in Y\cap N$ der Länge $e(i)$.
    \begin{itemize}[noitemsep]
        \item Ist $q\in W$ dann gilt schon sofort dass $q\not\in P^\mathrm{no}_a, P^\mathrm{no}_b$ was $q\in N$ widerspricht.
        \item Ist $q\in W'$ dann gilt schon sofort dass $q\not\in P^\mathrm{yes}_a, P^\mathrm{yes}_b$ was $q\in Y$ widerspricht.
        \item Andernfalls ist $q\in  W\cup W'$, dann gilt $q\in P^\mathrm{yes}_a\cap P^\mathrm{no}_b$ oder $q\in P^\mathrm{yes}_a\cap P^\mathrm{no}_b$.
            In beiden Fällen hätten wir aber, dass $P_a$ und $P_b$ eine Orakelfrage der Länge $e(i)$ teilen, welche in $W\cup W'$ liegt. Das widerspricht der urpsrünglichen Annahme.
    \end{itemize}

    Es gilt also $Y\cap N =\emptyset$. Wähle ein $\alpha\in \Sigma^{e(i)}-N$. Dieses existiert da $|N|\leq p_a(|x|)+p_b(|x|)<2^{e(i)}$ nach ($\ast$).
    Sei nun $u$ das Orakel was genau alle Wörter der Länge $\leq p_j(|x|)$ definiert sind, und
    \[ u(z)= \begin{cases} O(z) & \text{falls $|z|\neq e(i)$}\\ 1 & \text{falls $z=\alpha$} \\1 & \text{falls $z\in Y$} \\ 0&\text{sonst,} \end{cases}
    \]
    also wie $O^{\leq p_j(|x|)}$ aufgebaut ist, außer dass die Ebene $e(i)$ mit genau den Wörtern aus $Y$ gefüllt wird. bzw. $u\cap\Sigma^{e(i)} = Y\cup \{\alpha\}$.
    Es ist leicht zu sehen dass $u\sqsupsetneq w_{s-1}$.
    Beob. dass 
    \[ u\cap N = \Sigma^{e(i)}\cap u \cap N = (Y\cup \{\alpha\}) \cap N= Y\cap N=\emptyset.\]

    Das Orakel $u$ stimmt mit $v_a$ auf $P^\mathrm{all}_a$ überein. Sei hierfür $q\in P^\mathrm{all}_a$.
    Ist $|q|\neq e(i)$, dann gilt schon nach Definition $v_a(q)=O(q)=u(q)$. Sei daher im Folgenden $|q|=e(i)$.
    Ist $q\in P^\mathrm{yes}_a$, dann auch $q\in v_a$. Außerdem dann auch $q\in Y$, daher $q\in u$.
    Ansonsten ist $q\in P^\mathrm{no}_a$, dann auch $q\not\in v_a$. Außerdem dann auch $q\in N$, daher $q\not\in u$ nach obiger Beobachtung.
    
    Auf symmetrische Weise stimmt $u$ mit $v_b$ auf $P^\mathrm{all}_b$ überein.
    Wir zeigen nun dass $u$ auch $t_{s-1}$-valide ist.
    Nach obiger Argumentation wäre dann $u$ eine geeignete Erweiterung von $w_{s-1}$ für welche $M_a^O(x)$ und $M_b^O(x)$ akzeptieren, also nicht mehr disjunkt, was der Wahl von $M_a, M_b$ widerspricht.

    Nach Konstruktion ist V1 und V2 erfüllt; V3 ist wegen $u\sqsupsetneq w_{s-1}$ erfüllt.
    Angenommen V4 ist verletzt.
    Wieder kann das nur an der Ebene $e(i)$ liegen.
    Aber hier gilt $|u\cap\Sigma^{e(i)}|=|Y\cap\{\alpha\}|\geq 1$.
\end{proof}

\begin{claim}
    Zu jedem disjunkten \NP-Paar $(L_a, L_b)$ existiert ein Separator aus $\P$.
\end{claim}
\begin{proof}
    Sei $L_a, L_b\in\NP^O, L_a\cap L_b=\emptyset$. Es existiert nach Definition ein Paar an Maschinen $M_a, M_b$ mit $L(M_a^O)=L_a$, $L(M_b^O)=L_b$.
    Wir zeigen für hinreichend lange $x$ wie man $L_1$ von $L_2$ in Polyonmialzeit relativ zu $O$ trennen kann.
    
    Sei im Folgenden $x$ hinreichend lange wie oben diskutiert, also für dieses $(\ast)$ mit eindeutigem $i$ gilt, sowie $w_{s-1}$ keine Wörter der Länge $e(i)$ definiert, wobei $s$ die Stufe ist, bei der $\tau^1_{a,b}$ betrachtet wurde.

    Wir werden diese Eigenschaft ausnutzen und iterativ Mengen $W, W'$ aufbauen, welche für die Berechnungen $M_a^O(x), M_b^O(x)$ relevant sind, bis wir alle solchen relevanten Wörter gefunden haben.
    Das machen wir je abwechselnd für $M_a^O(x)$ und $M_b^O(x)$.
    Betrachte dafür folgende Subroutine:

    \noindent%
    \SetKwProg{Fn}{Function}{:}{}%
    \SetKw{Assert}{assert}%
    \begin{algorithm}[H]
        $W\gets\emptyset,\, W'\gets\emptyset$\;
        \For{$k$ von $0$ bis $\max\{p_a(|x|), p_b(|x|)\}+1$}{
            $P_a\gets$ eine $(W, W')$ respektierende akzeptierende Berechnung $P$ von $M_a$ auf $x$ mit $|(P^\mathrm{all}\cap\Sigma^{e(i)})-(W\cup W')|$ minimal, oder $\bot$ falls keine existiert\;
            $P_b\gets$ eine $(W, W')$ respektierende akzeptierende Berechnung $P$ von $M_b$ auf $x$ mit $|(P^\mathrm{all}\cap\Sigma^{e(i)})-(W\cup W')|$ minimal, oder $\bot$ falls keine existiert\;
            \lIf{$P_a= \bot$}{\Return{„$x\in L_b$“}}
            \lIf{$P_b= \bot$}{\Return{„$x\in L_a$“}}
            \tcc{ab hier sind $P_a, P_b$ je zwei $(W, W')$ respektierende akzeptierende Berechnungen}
            \If{alle $q\in P_a^\mathrm{all}$ mit $|q|=e(i)$ sind in $W\cup W'$}{
                \Return{„$x\in L_a$“}
            }
            \If{alle $q\in P_b^\mathrm{all}$ mit $|q|=e(i)$ sind in $W\cup W'$}{
                \Return{„$x\in L_b$“}
            }
            \ForEach{$q\in P_a^\mathrm{all}\cup P_b^\mathrm{all}$ mit $|q|=e(i)$}
            {
                \lIf{$q\in O$}{$W\gets W\cup\{q\}$}
                \lIf{$q\not\in O$}{$W'\gets W'\cup\{q\}$}
            }
        }
        \Return{„$x\not\in L_a\cup L_b$“}
    \end{algorithm}
Es ist leicht zu sehen dass der Algorithmus eine polynomielle Laufzeitschranke einhält.
Wir beobachten die Invariante dass $W\subseteq O\cap\Sigma^{e(i)}$ und $W'\subseteq \overline{O}\cap\Sigma^{e(i)}$. 

Wir zeigen zunächst dass der Algorithmus keine falsch-positiven Fehler macht.
Für den ersten Fall nehme an dass der Algorithmus mit „$x\in L_a$“ terminiert aber es gilt $x\not\in L_a$ und $x\in L_b$.
Terminiert der Algorithmus in Z.~6, dann war $P_b=\bot$, was nach obiger Invariante bedeutet dass $M_b^O(x)$ ablehnt (denn sonst existiert immer eine $(W, W')$ respektierende akzeptierende Berechnung); Widerspruch zur Annahme.

Terminiert der Algorithmus in Z.~8, können wir den Widerspruch $x\in L_a$ zeigen: Sei $v$ das Orakel der $(W, W')$ respektierenden akzeptierenden Berechnung $P$ von $M_a(x)$. Es ist nun leicht zu sehen dass $v$ und $O$ auf $P_a^\mathrm{all}$ übereinstimmen. Damit gilt auch dass $M_a^O(x)$ akzeptiert und damit $x\in L_a$.

Der symmetrische Fall mit $L_b$ läuft analog. Damit macht der Algorithmus also zumindest schon keine falsch-positiven Fehler.
\medskip

Es verbleibt zu zeigen dass der Algorithus keine falsch-negativen Fehler macht.
Wir zeigen dies für den Fall dass $x\in L_a$, der andere Fall $x\in L_b$ läuft analog.
Sei hierfür $P_a^*$ der längste akzeptierende Rechenweg von $M_a^O(x)$.
Beob. mit obiger Invariante dass $P_a^*$ auch immer ein $(W,W')$ respektierender akzeptierender Rechenweg ist.
Nachdem der Algorithmus keine falsch-positven Fehler macht, sind die Bedingungen in Zz.~5 und 10 nie erfüllt.

Wir zeigen nun, dass nach $\leq p_j(|x|)+1$ vielen Iterationen auch die Bedingung in Z.~7 erfüllt ist.
Hierfür zeigen wir, dass $|P_a^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|$ in jeder Iteration um $\geq 1$ abnimmt. Da $|P_a^{*\mathrm{all}}|\leq p_j(|x|)$ ist nach $\leq p_j(|x|)+1$ vielen Iterationen $|P_a^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|=0$.
Nach $\leq p_j(|x|)+1$ vielen Iterationen wird also in Z.~3 eine Berechnung $P_a$ ausgewählt, bei der alle $q\in P_a^{\mathrm{all}}$ mit $|q|=e(i)$ in $W\cup W'$ liegen. Dann ist die Bedingung in Z.~7 erfüllt und der Algorithmus terminiert akzeptierend.

Steht der Algorithmus in Z.~13, dann gilt sowohl für das ausgewählte $P_b$, als auch für $P_a^*$ dass beide je eine (nicht notwendigerweise identische) Orakelfrage der Länge $e(i)$ enthalten, welche nicht in $W\cup W'$ liegt. (Andernfalls  wäre $P_a$ in Z.~3 anders ausgewählt worden.)
Damit ist Behauptung~4.4 anwendbar. Also haben diese zwei Berechnungen eine identische Orakelfrage $q\in P_b^\mathrm{all}\cap P_a^{*\mathrm{all}}\cap \Sigma^{e(i)}$ gemeinsam, welche nicht in $W\cup W'$ liegt.
Diese wird in den Zz.~13--16 dann auch irgendwann der Menge $W\cup W'$ hinzugefügt.
Damit nimmt auch $|P_a^{*\mathrm{all}}\cap \Sigma^{e(i)}-(W\cup W')|$ um $\geq 1$ ab, wie behauptet.
\end{proof}

\clearpage
\section{Generische Orakelkonstruktionen}
\refsection

Generische Orakel geben uns ein alternatives Framework, um unsere Orakelkonstruktionen zu beschreiben. Wie die sonst von Christian, Titus, Fabian, \dots{} konstruierten Orakel setzen generische Orakel eine Form von „existentiell quantifizierter Erweiterung“ um (etwa: „existiert eine endliche Erweiterung dass die Maschine $M$ die Eigenschaft $X$ nicht erfüllt, erweitere genau so, ansonsten gilt für alle Erweiterungen $\neg X$ und hieraus ergibt sich die Möglichkeit, Eigenschaft $Y$ zu erhalten“).
Hinzu kommt, dass es oft möglich ist zu zeigen, dass eine bestimmte Eigenschaft (bspw. Kollaps oder Trennung von Klassen) relativ zu \emph{jedem} generischen Orakel gilt. Das macht es einfacher, Orakel zu konstruieren, die mehrere Eigenschaften auf einmal erfüllen.
Hinzu kommt, dass -- im Gegensatz zur sonst bei uns üblichen Konstruktion  -- die generischen Orakelkonstruktionen die eigentliche \emph{Konstruktion} im Beweis abstrahieren; die Beweise der Teilaussagen erfolgen ohne Mitdenken der sonst üblichen „zeitlichen Dimension“ einer stufenweisen Konstruktion.

Wir bauen hier auf Beschreibungen von \textcite{fortnow_complexity_2011} auf. Diese vereinfachen ein allgemeineres Framework der Generizität von \textcite{fenner_oracle_2003}, auf welches im Folgenden auch Bezug genommen wird.
Zur generellen Idee:

\begin{foreigndisplaycquote}{english}{fortnow_complexity_2011}
Many oracle constructions proceed by finite extensions: at each stage of the construction, some requirement is to be satisfied (e.g. “the $i$-th polynomial-time machine does not accept some fixed relativizable language $L(O)$”), and we satisfy it by specifying the oracle on finitely many more strings, leaving those strings we have previously specified untouched. In this paper, a generic oracle is one built by finite extensions which also satisfies Murphy’s law: “anything which can happen will happen”. More prosaically, a generic oracle is built by interleaving all finite extension arguments that are “interleavable”.
\end{foreigndisplaycquote}

Das werden wir im Folgenden spezifizieren. Paralle hierzu erarbeiten wir exemplarisch das klassische Resultat $\P\neq\NP$ relativ zu einem (generischen) Orakel \parencite{baker_relativizations_1975}.
Besonders berücksichtig wurde, dass die Erarbeitung der Ergebnisse zu generischen Orakel ohne größeres Vorwissen erfolgt, und insbesondere sind alle Beweise frei von Topologie.
Wie üblich identifizieren wir Wörter aus $\Sigma^*$ mit Zahlen aus $\omega$ und andersherum.
Orakel/Mengen beschreiben wir wie üblich auch mittels ihrer (totalen) charakteristischen Funktion $\omega\to\{0,1\}$.

\begin{definition}\begin{thmenum}
    \item Eine \emph{Bedingung} ist eine partielle Funktion von $\omega \to \{0,1\}$ mit endlichem Definitionsbereich.
        \item Zwei Bedingungen $\sigma,\tau$ nennen wir \emph{konsistent} wenn $\sigma\cup\tau$ auch eine Bedingung ist, d.h. $a\in\dom(\sigma)\cup\dom(\tau)\implies \sigma(a)=\tau(a)$.
    \item Eine Bedingung $\tau$ \emph{erweitert} eine Bedingung $\sigma$ ($\tau\succeq \sigma$) falls $\dom(\sigma)\subseteq\dom(\tau)$ und $\sigma(a)=\tau(a)$ für alle $a\in\dom(\sigma)$.
    Wenn $\sigma\neq\tau$ schreiben wir auch $\tau\succ\sigma$.
    \item Wir überführen diese Notation auch auf Teilmengen von $\omega$ welche wir als totale Funktionen von $\omega\to\{0,1\}$ identifizieren.
    Wir schreiben also $A\succ \sigma$ falls $A(a)=\sigma(a)$ für alle $a\in\dom(\sigma)$.
\end{thmenum}
\end{definition}
Die Intuition hinter dem Begriff „erweitert“ ist, dass $\tau\succeq \gamma$ das abschließende Orakel $G\succ\tau$ vollständiger spezifiziert als $\gamma$.

\begin{definition}\label{def:generizität}
    Ein \emph{Begriff der Generizität} $\mathcal G$ ist eine nichtleere Klasse an Bedingungen mit folgenden Eigenschaften:
    \begin{thmenum}
        %\item (Verzweigung.) Für alle $\gamma\in\mathcal G$ existieren mindestens zwei Bedingungen $\tau_1, \tau_2\in\mathcal G$ mit $\tau_1,\tau_2\succ \gamma$ und $\tau_1\neq\tau_2$.
        \item\label{def:generizität-ext} (Generizität.) Für alle $\gamma\in\mathcal G$, alle $a\in \omega\setminus\dom(\gamma)$ existiert eine Bedingung $\gamma'\in\mathcal G$ mit $\gamma'\succ \gamma$ mit $a\in\dom(\gamma')$.
        \item\label{def:generizität-grundlegend} (Grundlegend.) Sind $\sigma_1, \sigma_2\in\mathcal G$ konsistent, dann ist auch $\sigma_1\cup\sigma_2\in\mathcal G$.
    \end{thmenum}
    Die Bedingungen $\gamma\in \mathcal G$ nennen wir auch $\mathcal G$-\emph{Bedingungen}.
\end{definition}

Ein einfacher Begriff der Generizität ist beispielsweise die \emph{Cohen}-Generizität, welche \emph{alle} Bedingungen (also finite partielle Funktionen) in einer Menge zusammenfasst.
Dieser Begriff der Generizität ist für unser BGS-Beispiel ausreichend.

Ein $\mathcal G$-generisches Orakel ist -- intuitiv gesprochen -- das Ergebnis einer unendlich fortführenden stufenweisen Erweiterung einer Startbedingung, wobei sukzessiv alle möglichen erdenklichen „Eigenschaften“ abgearbeitet und erfüllt -- \emph{„erzwungen“} -- werden, welche überhaupt erzwungen werden können. (Im Rahmen der BGS-Konstruktion wäre eine solche Eigenschaft beispielsweise „$M_i$ entscheidet nicht die NP-Zeugensprache $L(O)$“.)
Hierzu definieren wir formal, was mit „Eigenschaften“ und „erzwingen“ gemeint ist.

Sei im Folgenden $\mathcal G$ ein beliebiger aber fester Begriff von Generizität.
\begin{definition}[Relativierte Peano-Arithmetik]
    \begin{enumerate}
        \item Sei $\mathcal L_{\mathrm{PA}}[X]$ die Erweiterung der Sprache der Peano-Arithmetik ($=$, $+$, $\times$, $S$, $0$), mit einem zusätzlichen unären Prädikatsymbol $X$.
Ohne Beschränkung sind die einzigen logischen Operatoren $\neg, \lor, \exists$.
Für $n\in\omega$ bezeichnen wir mit $\overline{n}$ den Term $\underbrace{SS\cdots S}_{n}0$ in $\mathcal L_{\mathrm{PA}}[X]$. 
        \item Sei $\mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ die Menge der Sätze in $\mathcal L_{\mathrm{PA}}[X]$.
        \item Für $A\subseteq\omega$ sei $\omega[A]$ die Erweiterung des Standardmodells der Arithmetik für die Sprache $\mathcal L_{\mathrm{PA}}[X]$ in welcher das Prädikat $X$ durch (totale Funktion) $A$ interpretiert wird, das ist, der Satz $X(\overline{n})$ ist wahr genau dann wenn $A(n)=1$.
            Für einen Satz $\phi\in\mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ meint $\phi\vDash \omega[A]$ wie üblich, dass die Struktur $\omega[A]$ die Formel $\phi$ erfüllt (im Rahmen der üblichen Definition von Wahrheit/Erfüllung).
    \end{enumerate}
\end{definition}
Die Sätze $\phi\in\mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ entsprechen genau unseren oben intuitiven „Eigenschaften“.
Wir wollen, dass das abschließend konstruierte generische Orakel $G$ alle für uns relevanten Sätze $\phi\in\mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ erfüllt, in dem Sinn dass $\omega[G]\vDash \phi$.
Sei für die BGS-Konstruktion z.B.
\[ A_i : (\exists n)[M^X_i(0^n)=0 \leftrightarrow (\exists x)[|x|=n\land X(x)]] \]
eine Familie an Sätzen aus $\phi\in\mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$. (Nur) in diesem Kontext meinen wir mit $\{M_i\}_{i\in\omega}$ eine vollständige Aufzählung der deterministischen Polymomialzeit-Orakel-Turing-Maschinen.
Wir wünschen uns nun vom enstprechenden generischen Orakel $G$, dass 
\[ \omega[G] \vDash A_i \text{ für alle $i\in\omega$} \]
denn dann folgt
\[ \omega[G] \not\vDash „\P^X=\NP^X“, \]
oder weniger formell geschrieben, $\P\neq\NP$ relativ zu $G$.

Zur technischen Umsetzung führen wir den Begriff des Erzwingens bzw. Forcing ein.
Diese soll uns als eine „vorläufige Approximation an Wahrheit“ dienen.
Die $\mathcal G$-Forcing-Relation $\Vdash$ auf $\mathcal G\times \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$  wird durch eine einfache Rekursion über die Struktur von Formeln definiert, die im Wesentlichen Tarskis Definition von Wahrheit entspricht, außer im Fall der Negation.  Im Fall der Negation können wir die Definition grob so verstehen, dass $\neg\phi$ erzwungen wird, wenn wir $\phi$ niemals durch Verfeinerung des Orakels erzwingen können.

\begin{definition}[Forcing-Relation]
Die Variablen $\gamma$ und $\tau$ erstrecken sich über $\mathcal G$. Es gilt:
\begin{align*}
    \gamma\Vdash\phi &\iff \text{$\phi$ atomar, $X$ kommt nicht in $\phi$ vor, und $\omega\vDash\phi$},\\
    \gamma\Vdash X(\overline n)&\iff(\forall A\succ\gamma).A(n)=1,\\
    \gamma\Vdash \phi\lor\psi &\iff\gamma\Vdash\phi\text{ oder } \gamma\Vdash \psi,\\
    \gamma\Vdash(\exists x)\phi &\iff \text{es existiert ein $a\in\omega$ sodass } \gamma\Vdash \phi[x/\overline{a}],\\
    \gamma\Vdash \neg\phi &\iff (\forall \tau\succeq \gamma).\,\tau\not\Vdash\phi.
\end{align*}
\end{definition}

Es ergeben sich schon aus dieser Definition drei kleine Beobachtungen, welche Forcing mit Wahrheit in Verknüpfung bringen:
\begin{observation}
    \begin{thmenum}
    \item \label{obs:forcing-extension} Gilt $\gamma\Vdash\phi$ und $\sigma\succeq \gamma$, dann gilt auch $\sigma\Vdash \phi$.
    \item \label{obs:forcing-by-universaity} Wenn $(\forall A\succ \gamma).\omega[A]\vDash\phi$, dann gilt $\gamma\Vdash\phi$.
    \item Wenn $\gamma\Vdash\phi$ dann gilt $\gamma\Vdash\neg\neg\phi$.
    \end{thmenum}
\end{observation}
\begin{proof}
    Jeweils Induktion über Formeln.
\end{proof}

\begin{definition}
    Wir schreiben $G\Vdash \phi$ wenn ein $\gamma\in \mathcal G$ existiert mit $G\succ \gamma$ und $\gamma\Vdash\phi$.
\end{definition}

Wir können jetzt die intuitive Definition eines generischen Orakels umsetzen. Ein generisches Orakel erfüllt alle Sätze $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ für welche der der Begriff der Generizität „stark genug“ ist, diese zu erfüllen. Für jeden Satz $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt also intuitiv „Murphy's law“: entweder $\phi$ ist durch $G$ erzwungen ($G\Vdash \phi$), oder $\phi$ konnte ohnehin nie in der Konstruktion erzwungen werden ($G\Vdash \neg\phi$).
Nach der Definition müssen wir noch eine Verbindung zwischen Erzwingen und Wahrheit aufbauen.

\begin{definition}
    Eine Menge $G\subseteq\omega$ ist \emph{$\mathcal G$-generisch} wenn folgende Eigenschaften erfüllt sind:
    \begin{thmenum}
        %\item Für alle $\sigma_1, \sigma_2\in \mathcal G$ gilt: wenn $G\succ \sigma_1, \sigma_2$ (also insb. auch konsistent), dann existiert auch eine Bedingung $\tau\in\mathcal G$ sodass $G\succ\tau\succeq\sigma_1\cup\sigma_2$.
        \item\label{def:genorakel-forcing} Für jeden Satz $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt $G\Vdash \phi\lor\neg\phi$, es existiert also ein $\gamma\in\mathcal G$ mit $G\succ \gamma$ und $\gamma\Vdash \phi\lor\neg\phi$.

        \item\label{def:genorakel-vollst} Für alle $n\in\omega$ existiert ein $\gamma\in\mathcal G$ mit $G\succ\gamma$ und $n\in\dom(\gamma)$.
    \end{thmenum}
\end{definition}

\begin{lemma}[Existenz von generischen Mengen]\label{lemma:generics-existieren}
    Für jeden Begriff der Generizität $\mathcal G$, jedes $\gamma\in\mathcal G$ existiert eine $\mathcal G$-generische Menge $G\succ \gamma$.
    (Da $\mathcal G$ nichtleer, existiert also immer eine $\mathcal G$-generische Menge.)
\end{lemma}
\begin{proof}
    Sei $\{\phi_i\}_{i\in\omega}$ eine Aufzählung aller Sätze in $\mathcal L_{\mathrm{PA}}[X]$. 
    Starte mit $\gamma_{-1}=\gamma$. Für jedes $i\geq 0$, gegeben $\gamma_{i-1}$, wähle ein $\sigma\in\mathcal G$ mit $\sigma\succeq\gamma_{i-1}$ und sodass $\sigma \Vdash \phi_i\lor\neg\phi_i$. Dieses $\sigma$ existiert: angenommen kein $\sigma\in\mathcal G$, $\sigma\succeq\gamma_{i-1}$ existiert mit $\sigma\Vdash \phi_i$. Dann gilt nach Definition $\gamma_{i-1}\Vdash\neg\phi_i$; setze $\sigma=\gamma_{i-1}$.

    Falls $i\not\in\dom(\sigma)$, setze $\gamma_i\in\mathcal G$ mit $\gamma_i\succ\sigma$ und $i\in\dom(\gamma_i)$. Diese existiert nach \ref{def:generizität-ext}.
    Andernfalls, setze $\gamma_i=\sigma$.
    In beiden Fällen haben wir $\gamma_i\Vdash \phi_i\lor\neg\phi_i$.

    Wir definieren nun
    \[ G(n) = \gamma_n(n). \]
    Wir haben immer $n\in\dom(\gamma_n)$ (sogar $0,1,\dots, n\in\dom(\gamma_n)$) und damit ist $G$ wohldefiniert.
    Ferner gilt $G\succ\gamma_i$ für alle $i$: angenommen $G\not\succ\gamma_i$, dann existiert ein $k\in\dom(\gamma_i)$ und $\gamma_i(k)\neq G(k)=\gamma_k(k)$.
    Gleichzeitig ist aber $k\in\dom(\gamma_k)$ und entweder $\gamma_i\preceq \gamma_k$ oder $\gamma_k\preceq \gamma_i$. In beiden Fällen gilt $\gamma_i(k)=\gamma_k(k)$; Widerspruch zu oben.
    Also gilt \ref{def:genorakel-forcing}.

    Damit gilt auch \ref{def:genorakel-vollst}: Für beliebiges $n\in\omega$ existiert $\gamma_n\in\mathcal G$ mit $G\succ \gamma_n$ und $n\in\dom(\gamma_n)$.
    %Die Eigenschaft (1) folgt unmittelbar aus Grundlegendheit bzw. 2(2).
\end{proof}

\begin{lemma}[Erzwingen ist Wahrheit]\label{lemma:forcing-is-truth}
    Sei $G$ eine $\mathcal G$-generische Menge. 
    Für alle $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt:
    $G\Vdash \phi$ genau dann wenn $\omega[G]\vDash \phi$.
\end{lemma}
\begin{proof}
    Induktion über die Struktur der Formeln. Variablen $\gamma, \gamma', \tau$ gehen über $\mathcal G$. Variable $A$ geht über $\{0,1\}^{\omega}$.
    \begin{itemize}
        \item Lemma klar wenn $\phi$ atomar ist und $X$ nicht in $\phi$ vorkommt.
        \item Falls $\phi=X(\overline n)$ dann haben wir
            \begin{align*}
                G\Vdash X(\overline n) &\iff (\exists \gamma, \gamma\prec G).\,\gamma\Vdash X(\overline n)\\
                             &\iff (\exists \gamma, \gamma\prec G)(\forall A\succ \gamma),\, A(n)=1\\
                             &\iff G(n)=1 \\
                             &\iff \omega[G]\vDash X(\overline n),
            \end{align*}
            wobei die ersten zwei Äquivalenzen aus Definition folgen.
            %Ebenso
            %\begin{align*}
                %G\not\Vdash X(\overline n) &\implies (\forall \gamma', \gamma'\prec G).\,\gamma'\not\Vdash X(\overline n)\\
                                           %%&\implies (\exists \gamma, \gamma\prec G).\,\gamma\Vdash \neg X(\overline n)\\
                                           %%&\implies (\exists \tau,\tau\prec G).\,n\in\dom(\tau)\land \tau\not\Vdash X(\overline n)\\
                                           %%&\implies G(n)=0 \implies \omega[G]\vDash \neg X(\overline n). 
                                           %&\implies (\forall \gamma',\gamma'\prec G).\,n\not\in\dom(\gamma')\lor \gamma'(n)=0\\
                                           %&\implies (\exists \tau,\tau\prec G).\,\tau(n)=0\\
                                           %&\implies \tau(n)=G(n)=0 \implies \omega[G]\vDash \neg X(\overline n). 
            %\end{align*}
            %Zweite Implikation ist Definition.
            Rückrichtung dritter Äquivalenz folgt aus der Existenz eines $\gamma\prec G$ mit $n\in\dom(\gamma)$ nach \ref{def:genorakel-vollst}.
        \item Lemma klar für Disjunktionen und Existenzquantor: Induktionsannahme verwenden.
        \item Für Negationen gilt: 
            \begin{align*}
                G\not\Vdash \neg\phi &\implies (\forall \gamma', \gamma'\prec G).\,\gamma'\not\Vdash \neg\phi\\
                                     &\implies (\exists \gamma, \gamma\prec G).\,\gamma\Vdash \phi\\
                                     &\implies G\Vdash\phi \implies \omega[G]\Vdash \phi.
            \end{align*}
            Die zweite Implikation gilt, denn für ein $\gamma\in \mathcal G, \gamma\prec G$ gilt nach Definition \ref{def:genorakel-forcing} dass $\gamma\Vdash \phi\lor \neg \phi$.
            Wenn also nach Voraussetzung für alle solche $\gamma'$ schon $\gamma'\not\Vdash \neg\phi$, dann muss $\gamma\Vdash \phi$.

            Für die andere Richtung gilt:
            \begin{align*}
                G\Vdash \neg\phi &\implies (\exists \gamma, \gamma\prec G).\,\gamma\Vdash \neg\phi\\
                                     &\implies (\forall \gamma', \gamma'\prec G).\,\gamma'\not\Vdash \phi\\
                                     &\implies G\not\Vdash\phi \implies \omega[G]\not\Vdash \phi.
            \end{align*}
            Um die zweite Implikation zu sehen, nimm ann dass eine $\mathcal G$-Bedingung $\gamma'\prec G$ existiert mit $\gamma'\Vdash\phi$.
            %Dann gilt $\gamma, \gamma'\prec G$ und nach Definition 4(1) existiert eine $\mathcal G$-Bedingung $\tau$ mit $\gamma\cup\gamma'\preceq\tau\prec G$.
            Dann gilt $\gamma, \gamma'\prec G$ und die $\mathcal G$-Bedingungen $\gamma, \gamma'$ sind konsistent.
            Nach Definition \ref{def:generizität-grundlegend} ist also $\tau=\gamma\cup \gamma'$ ist auch eine $\mathcal G$-Bedingung und es gilt sogar $\tau\prec G$.
            Da $\tau\succeq\gamma'$ und $\gamma'\Vdash\phi$ haben wir nach Beobachtung \ref{obs:forcing-extension} auch $\tau\Vdash\phi$.
            Genauso haben wir dann aber auch $\tau\succeq\gamma$ und damit $\tau\Vdash \neg\phi$. Aus Letzterm folgt insbesondere $\tau\not\Vdash\phi$; Widerspruch zu Ersterem. Letzte Implikation ist Induktionsannahme. \qedhere
    \end{itemize}
\end{proof}

Die bisherigen Ergebnisse sind in dieser Form nicht sonderlich nützlich. (Wir wissen erstmal nur dass $G\Vdash \phi\lor\neg\phi$, also nach vorigem Satz $\omega[G] \vDash \phi\lor\neg\phi$ -- eine Trivialität.)
Es ist erst mal unklar, ob für gegebenen Satz $\phi$ die Konstruktion $G\Vdash \phi$ oder $G\Vdash\neg\phi$ erzwungen hat, also für welchen Satz $\phi$ der gewählte Begriff der Generizität „stark genug“ war, um $\phi$ zu erzwingen.  Konkret für die BGS-Konstruktion: haben wir $G\Vdash A_i$ für alle $i\in\omega$?

Wir könnten jetzt die Konstruktion aus Satz \ref{lemma:generics-existieren} präzisieren. (Beim genauen Beobachten stellen wir z.B. fest dass $\gamma_i\Vdash\phi_i$ genau dann wenn wir die vorhergehende Bedingung $\gamma_{i-1}$ entsprechend so erweitern konnten um $\phi_i$ zu erzwingen.)
Stattdessen können wir aber auch auf Eigenschaften unserer bisherigen Definitionen aufbauen, um folgende „extensionale“ Charakterisierung zu formuieren, für welche Sätze $\phi$ auch $G\Vdash \phi$ (und damit $\omega[G]\vDash\phi$) gilt. Damit abstrahieren wir von der konkreten Konstruktion.
%Hierzu konkretisieren wir auch die f
%Wir werden sehen dass für $G\Vdash\phi$ es ausreicht zu zeigen, dass die Menge $\{\gamma\in\mathcal G\mid \gamma\Vdash\phi \}$ der $\phi$ erzwingenden $\mathcal G$-Bedingungen \emph{dicht in} unserem Begriff der Generizität $\mathcal G$ ist -- das ist die formale Umsetzung von „stark genug um $\phi$ zu erzwingen“.


\begin{lemma}\label{lemma:single-negation-contradicts}
    Für alle $\gamma\in\mathcal G$ und alle $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt:
    \[ \gamma\Vdash\neg\phi \iff (\forall\text{$\mathcal G$-generischen $G\succ\gamma$}).\, \omega[G]\not\vDash \phi. \]
    In anderen Worten: $\gamma\Vdash\neg\phi$ genau dann wenn $\phi$ unter allen generischen Erweiterungenen von $\gamma$ als falsch interpretiert wird.
\end{lemma}
\begin{proof}
    Sei $\gamma\Vdash\neg\phi$. Das bedeutet dass für alle $\mathcal G$-Bedingungen $\tau$ mit $\tau\succeq\gamma$ auch $\tau\not\Vdash \phi$ gilt.
    Nimm jetzt an dass eine $\mathcal G$-generische Menge $G\succ\gamma$ existiert mit $\omega[G]\vDash\phi$.
    Nach Lemma \ref{lemma:forcing-is-truth} gilt $G\Vdash\phi$, nach Definition existiert ein $\sigma\prec G$ mit $\sigma\Vdash\phi$.

    Nun sind $\gamma$ und $\sigma$ konsistent, gilt ja $\sigma,\gamma\prec G$.
    Nach Definition \ref{def:generizität-grundlegend} ist also auch $\tau'=\gamma\cup\sigma\in\mathcal G$ und wir haben $\tau'\succeq\gamma$, nach Beobachtung \ref{obs:forcing-extension} also $\tau'\Vdash\phi$; Widerspruch zu oben.

    Für die andere Richtung sei $\gamma\not\Vdash\neg\phi$. Dann existiert eine Bedingung $\tau$ mit $\tau\succeq\gamma$ und $\tau\Vdash\phi$.
    Nach Lemma \ref{lemma:generics-existieren} existiert eine $\mathcal G$-generische Menge $G\succ \tau$. Nach Lemma \ref{lemma:forcing-is-truth} gilt $\omega[G]\vDash\phi$.
\end{proof}

Beachte dass $\omega[G]\not\vDash\neg\phi$ genau dann wenn $\omega[G]\vDash\phi$. Wir haben dadurch
\begin{corollary}\label{cor:double-negation-truth}
    Für alle $\gamma\in\mathcal G$ und alle $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt:
    $\gamma\Vdash\neg\neg\phi$ genau dann wenn $\omega[G]\vDash\phi$ für alle $\mathcal G$-generischen $G\succ\gamma$.
\end{corollary}

Wir formulieren nur die konkrete formale Übersetzung von „stark genug um $\phi$ zu erzwingen“:
Für einen festen Begriff von Generizität $\mathcal G$ und einen festen Satz $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ sagen wir dass \emph{$\mathcal G$ stark genug ist, um $\phi$ zu erzwingen} wenn für jede $\mathcal G$-Bedingung $\gamma$ ein eine weitere $\mathcal G$-Bedingung $\tau$ existiert mit $\tau\succeq \gamma$ und $\tau\Vdash\phi$.
Wir sehen, dass diese Aussage sogar äquivalent zur Aussage „$\gamma\Vdash\neg\neg\phi$ für alle $\mathcal G$-Bedingungen $\gamma$ ist.

\begin{observation}
$(\forall \gamma\in\mathcal G).\gamma\Vdash\neg\neg\phi$ $\iff$ $\mathcal G$ ist stark genug, um $\phi$ zu erzwingen.
\end{observation}
%\begin{proof}
%Wir haben nach Definition
%\[ \gamma\Vdash\neg\neg\phi \iff (\forall\sigma\in\mathcal G, \gamma\preceq\sigma)(\exists \tau\in\mathcal G,\sigma\preceq\tau).\,\tau\Vdash\phi. \]
%Angenommen $(\forall \gamma\in\mathcal G).\gamma\Vdash\neg\neg\phi$. Dann existiert für festes $\gamma\in \mathcal G$ auch ein $\tau\succeq\gamma$ mit $\tau\Vdash\phi$; also $\mathcal G$ stark genug um $\phi$ zu erzwingen.

%Für die andere Richtung nimm an dass $\mathcal G$ stark genug ist um $\phi$ zu erzwingen. Sei $\gamma\in\mathcal G$ beliebig. Es gilt die rechte Seite der oben genannten Äquivalenz: für festes $\sigma\in\mathcal G, \sigma\succeq\gamma$ existiert dann nach Annahme ein $\tau\in\mathcal G$, $\tau\succeq \sigma$ mit $\tau\Vdash\phi$. Es gilt also $\gamma\Vdash\neg\neg\phi$. 
%\end{proof}

\begin{corollary}\label{corollary:strong-enough-generic-truth}
    Für alle $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[X])$ gilt:
    Ist $\mathcal G$ stark genug um $\phi$ zu erzwingen, also zur Erinnerung
    \[ (\forall \gamma\in\mathcal G)(\exists \tau\in\mathcal G, \gamma\preceq\tau).\,\tau\Vdash\phi,\text{ bzw. } (\forall\gamma\in\mathcal G).\,\gamma\Vdash\neg\neg\phi, \]
    dann ist $\omega[G]\vDash\phi$  für alle $\mathcal G$-generischen Mengen $G$, 
    d.h. unter allen $\mathcal G$-generischen Mengen wird der Satz $\phi$ als wahr interpretiert.
\end{corollary}
\begin{proof}
    Sei $G$ eine beliebige $\mathcal G$-generische Menge.
    Es existiert immer eine Bedingung $\sigma\in\mathcal G$ mit $G\succ \sigma$; das folgt schon aus Definition \ref{def:genorakel-vollst}.
    Nach vorigem Korollar \ref{cor:double-negation-truth} gilt dann $\omega[G]\vDash \phi$.
\end{proof}

In unserem BGS-Beispiel sehen wir, dass die Cohen-Generizität stark genug ist, um alle $A_i$ zu erzwingen. Zur Erinnerung:
\[ A_i : (\exists n)[M_i^X(0^n)=0 \leftrightarrow (\exists x)[|x|=n\land X(x)]] \]
Sei hierfür im Folgenden $\mathcal G$ der Begriff der Cohen-Generizität (d.h. alle endlichen partiellen Funktionen).
Sei nun $\gamma\in\mathcal G$ beliebig.
Wir müssen nun ein $\tau\in\mathcal G$ angeben, welches $\gamma$ erweitert und $\tau\Vdash A_i$.
Zunächst wählen wir ein $n\in\omega$ sodass $\gamma$ keine Wörter der Länge $n$ definiert, und sodass $2^n>p_i(n)$.
Definiere $A\succ\gamma$ mit
\[ A(x) = \begin{cases} \gamma(x) & \text{wenn $x\in\dom(\gamma)$}\\ 0 & \text{sonst}. \end{cases} \]
Die Berechnung $M_i^A(0^n)$ ist definiert.
Tatsächlich können wir nun eine partielle Funktion $\alpha\prec A$ finden, sodass $\dom(\alpha)$ genau mit Orakelfragen dieses Rechenwegs übereinstimmt.
Dann ist leicht zu sehen: für jedes Orakel $B\succ\alpha$ gilt $M_i^B(0^n)=M_i^A(0^n)$.
Im Übrigen ist $\alpha,\gamma\prec A$ und damit sind $\alpha$ und $\gamma$ kompatibel.

Ist nun $M_i^A(0^n)=1$, dann setze
\[ \tau(x) =\begin{cases} \gamma(x) & \text{für $x\in\dom(\gamma)$}\\\alpha(x) & \text{für $x\in\dom(\alpha)$}\\0&\text{für $x\in\Sigma^n$}\\\text{undef.} & \text{sonst}.\end{cases} \]
Dann ist $\tau$ offensichtlich eine Cohen-Bedingung, und es gilt für alle $B\succ \tau$ dass auch $B\succ\alpha$, also auch $\omega[B] \vDash M_i^B(0^n)=1$.
Trotzdem gilt $\omega[B] \not\vDash (\exists x)[|x|=n\land X(x)]$.
Wir haben also
\[ (\forall B\succ \tau) \omega[G] \vDash A_i \]
und nach Beobachtung \ref{obs:forcing-by-universaity} haben wir $\tau\Vdash A_i$.

Symmetrisch falls $M_i^A(0^n)=0$. Sei $a\in \Sigma^n\setminus\dom(\alpha)$. Dieses existiert da $|\dom(\alpha)|\leq p_i(n)<2^n=|\Sigma^n|$. Setze nun
\[ \tau(x) =\begin{cases} \gamma(x) & \text{für $x\in\dom(\gamma)$}\\\alpha(x) & \text{für $x\in\dom(\alpha)$}\\1&\text{für $x=a$}\\0&\text{für $x\in\Sigma^n$, $x\neq a$}\\\text{undef.} & \text{sonst}.\end{cases} \]
Wieder ist $\tau$ eine Cohen-Bedingung, und es gilt für alle $B\succ \tau$ dass $\omega[B] \vDash M_i^B(0^n)=0$.
Trotzdem gilt $\omega[B] \vDash (\exists x)[|x|=n\land X(x)]$ und damit
\[ (\forall B\succ \tau) \omega[G] \vDash A_i, \text{ bzw.} \tau\Vdash A_i. \]

Wir wissen also nun, dass Cohen-Generizität stark genug ist, um alle $A_i$ zu erzwingen. Damit gilt nach Korollar \ref{corollary:strong-enough-generic-truth} schon mal das $\omega[G]\vDash A_i$ für alle Cohen-generische $G$, alle $i\in\omega$.

Sei nun ein $G$ ein beliebiges Cohen-generisches Orakel $G$. Wir zeigen nun dass $\P^G\neq\NP^G$. Angenommen $\P^G=\NP^G$, dann wird die Menge
\[ L(G) = \{ 0^n \mid n\in\omega, \text{ex. $x\in\Sigma^n$ mit $x\in G$} \} \in\NP^G \]
auch in $\P^G$ entschieden.
Dann existiert eine deterministische Polyzeitmaschine $M_i$ mit $L(M_i^G)=L(G)$.
Gleichzeitig haben wir $\omega[G]\vDash A_i$, also existiert in $n\in\omega$ sodass $M_i^G(0^n)$ ablehnt genau dann wenn ein Wort der Länge $n$ in $G$ liegt, bzw. $0^n\in L(G)$. 
Damit $L(M_i^G)\neq L(G)$; Widerspruch zur Annahme und es gilt $\P^G\neq\NP^G$. (Oder eben dass kein solches generisches $G$ existieren kann -- das aber ist ausgeschlossen nach Lemma \ref{lemma:generics-existieren}.)

\subsection{Relativierte Orakelkonstruktion}

Die oben beschriebenen Definitionen und Ergebnisse bezüglich Forcing können einfach relativiert werden. Sei $B\subseteq \omega$. Forcing und Wahrheit relativ zu $B$ definieren wir wie im unrelativierten Fall, aber erweitern die Sprache $\mathcal L_{\mathrm{PA}}[X]$ und das Standardmodell $\omega$ um ein zweiteres unäres Prädikat $B$ zu $\mathcal L_{\mathrm{PA}}[B,X]$ bzw. $\omega^B$ mit Prädikat $B$ interpretiert über Menge $B$. Dann können wir z.B. über „$\mathcal G$-generisch relativ zu $B$“ sprechen.
Insbesondere überträgt sich das Hauptresultat vom vorigen Abschnitt: Ist $\mathcal G$ stark genug um den Satz $\phi\in \mathrm{sent}(\mathcal L_{\mathrm{PA}}[B,X])$ zu erzwingen, dann ist $\omega^B[G]\vDash \phi$ für alle $\mathcal G$-generischen Mengen $G$ (welche auch existieren).

Alle folgenden Orakelkonstruktionen und Resultate, sowie die vorige BGS-Konstruktion, relativieren auf ein beliebiges zweites $B\subseteq\omega$.
Mit dieser Erkenntnis lassen sich leichter komplexere Orakelkonstruktionen definieren, welche im Wesentlichen durch Kombination mehrerer Orakel entstehen. Ein Beispiel ist hier die klassische Konstruktion von \citeauthor{baker_relativizations_1975} eines Orakels relativ zu dem $\P=\NP\cap\coNP\neq\NP$: hierbei wird ein PSPACE-vollständiges Orakel $B$ und ein zweites Orakel $A$ kombiniert; in der Originalfassung zu $A\cup B$. (Das Orakel $A$ trennt $\P$ von $\NP$, ist aer so „einfach“ dass ein Maschinenpaar aus $\NP\cap\coNP$ eine relevante Portion von $A$ entscheiden kann und dann mittels PSPACE-vollständigem $B$ abfragen kann, ob entsprechende Eingabe akzeptiert wird.) Wir werden im Folgenden etwas Ähnliches mittels \emph{Rerelativierungen} umsetzen.

Wir erweitern die Definition einer Orakel-Turing-Maschine $M^A$ auf eine \emph{2-Orakel-Turing-Maschine} $M^{A,B}$, welche anstelle eines Fragezustands einen zusätzlichen zweiten ausgezeichneten Fragezustand bekommt. (Erster Fragezustand fragt $q\in A$ ab, zweiter fragt $q\in B$ ab.)
Aussagen können also nicht nur auf \emph{ein} Orakel $A$ relativiert werden, sondern auch auf \emph{zwei} Orakel $(A,B)$.
Mit „Relativierung von Orakelkonstruktionen“ meine ich beispielsweise: 
\begin{quote}
    Hat $\UP^A$ keine vollständige Menge, dann hat auch $\UP^{A,B}$ keine vollständige Menge (Klasse definiert über 2-Orakel-Turing-Maschinen), und dann hat auch $\UP^{A\oplus B}$ keine vollständige Menge.
\end{quote}

Methodisch laufen die Orakelkonstruktionen durch Blackbox-Simulationen ab. Deshalb relativieren diese Konstruktionen:
%haben wir $\omega[G] \vDash \phi$, dann haben wir auch $\omega^B[G] \vDash \phi'$, wobei $\phi'$ aus $\phi$ hervorgeht wenn alle Orakel-Turing-Maschinen mit 2-Orakel-Turing-Maschinen ausgetauscht wurden.
haben wir beispielsweise die relativierte Aussage \begin{quote}$\omega[A]\vDash „\UP^X$ hat keine vollständige Menge“\end{quote}  dann gilt auch die \emph{Re-}Relativierung \begin{quote}$\omega^B[A]\vDash „\UP^{X,B}$ hat keine vollständige Menge“.\end{quote}
Eine auf zwei Orakel relativierte Klasse, wie z.B. $\UP^{A,B}$, kann nun mittels des Join-Operators $\oplus$ definiert als
\[ A\oplus B = \{0x\mid x\in A\}\cup\{1x\mid x\in B\} \] 
auch mittels \emph{einem} kombinierten Orakel $A\oplus B$ erfasst werden. Wir haben z.B.
\[ \UP^{A,B} = \UP^{A\oplus B}, \]
da jede „unambigous“ 2-Orakel-Turing-Maschien relativ zu $(A,B)$ durch eine „unambigous“ 1-Orakel-Turing-Maschine relativ zu $A\oplus B$ effektiv simuliert werden kann, und umgekehrt.
In unserem Beispiel hatten wir dass $\UP^{A,B}$ keine vollständige Menge hat, also hat auch $\UP^{A\oplus B}$ keine vollständige Menge.


%Außerdem können zwei unäre Prädikate in arithmetischen Formel in ein einziges Prädikat überführt werden, mittels des Join-Operators $\oplus$: 
%\[ A\oplus B = \{0x\mid x\in A\}\cup\{1x\mid x\in B\}. \]
%Gegeben Formel $\phi$ über $\mathcal L_{\mathrm{PA}}[X,B]$ können wir effektiv eine Formel $\psi$ über $\mathcal L_{\mathrm{PA}}[X]$ finden sodass für alle $A,B\in\omega$ gilt:
%\[ \omega^B[A] \vDash \phi \text{ genau dann wenn } \omega[A\oplus B]\vDash \psi. \]

\subsection{Anwendung: Orakel relativ zu diesem $\hUP$ und $Q$ gilt}

In diesem Abschnitt wollen wir das Orakel $O_1$ mit dem bisher präsentierten Framework rekonstruieren, und zeigen dass relativ zu einem generischen Orakel (bezüglich einem Begriff von Generizität welcher im Folgenden definiert wird) keine Menge vollständig für $\UP$ ist, und die Aussage $Q$ gilt. Zur Erinnerung: $Q$ sagt aus dass für alle (Poly-)Maschinen $M$ mit $L(M)=\Sigma^*$ eine Funktion $g\in\FP$ existiert sodass $g(x)$ ein akzeptierender Rechenweg von $M(x)$ ist.
In diesem Kontext meinen wir mit $\{M_i\}_{i\in\omega}$ eine vollständige Aufzählung der nichtdeterministischen Polymomialzeit-Orakel-Turing-Maschinen.
Wir nenne eine Berechnung $M_i^\sigma(x)$ \emph{relativ zu einer Bedingung $\sigma$ definiert}, wenn $M_i$ auf eingabe $x$ hält, hierbei sämtliche Orakelfragen in $\dom(\sigma)$ liegen und dabei entsprechend $\sigma$ beantwortet werden.
Entsprechend können wir Aussagen wie „$M_i^\sigma(x)$ akzeptiert auf zwei Rechenwegen“ formuieren.
Klar ist, dass sich solche Aussagen relativ zu $\sigma$ auf Orakel $A\succ \sigma$ übertragen, d.h. wir hätten z.B. aus obiger aussage dass auch $M_i^A(x)$ auf zwei Rechenwegen akzeptiert, für alle $A\succ\sigma$, und zwar immer mit den gleichen Orakelfragen $Q\subseteq \dom(\sigma)$.

In der klassischen Konstruktion haben wir mit einem PSPACE-vollständigen Orakel $A$ gestartet, dieses mit weiteren Wörtern $B$ augmentiert, sodass relativ zu $A\cup B$ einerseits $\hUP$, andererseits war $B$ so einfach, dass eine totale Maschine $M$ relevante Portionen von $B$ rekonstruieren kann. Dann kann mit dem PSPACE-vollständigen $A$ auch ein akzeptierender Rechenweg von $M(x)$ bestimmt werden.

Definiere die Funktion $\tower$ mit \[ \tower(0)=2, \quad \tower(k+1)=2^{2^{\tower(k)}}. \]
Definiere polynomialzeitberechenbare und -invertierbare Familie $\{H_{i}\}_{i\in\omega}$, \[ H_i\subseteq\{ \tower(k) \mid k\in\omega \}, \]wobei
alle Mengen der Familie paarweise disjunkt sind.
%Wir nennen ein $n\in\omega$ eine \emph{Tower-Länge der Stufe $k$} wenn $\tower(k)=n$.
Wir nenenn eine Länge $n\in\omega$ \emph{erlaubt} wenn ein $k\in\omega$ existiert mit $n=\tower(k)$, ansonsten \emph{verboten}.
Wir nennen eine Bedingung (bzw. Menge) $\sigma\subseteq \omega$ \emph{lückenhaft} wenn $\sigma(x)=1$ impliziert dass $x$ eine erlaubte Länge hat.
Definiere folgende Familie an Zeugensprachen $\{L_{i}(A) \}_{i,j\in\omega}$ abhängig von $A\subseteq\omega$:
\begin{gather*}
    L_{i}(A) = \{ 0^n \mid n\in H_{i,j}, \text{ es existiert ein $x\in\Sigma^n$ mit $x\in A$} \}
\end{gather*}
Wir haben $L_{i}(A)\in\UP^A$ wenn kein $n\in H_{i,j}$ existiert dass $x, y\in A$ für zwei verschiedene $x,y\in\Sigma^n$.

Das folgende Lemma setzt den zweiten, „algorithmischen“ Teil der Orakelkonstruktion um. Wie in der Literatur zu Forcing üblich, formulieren wir die Aussage mit Annahme $\P=\PSPACE$ (und sprechen erst mal nicht von einem PSPACE-vollständigen Orakel), weil die Aussage ohnehin auf ein zweites Orakel relativiert.

\begin{lemma}[vgl. \cite{fortnow_separability_2002}]\label{thm:q-algorithmus}
    Angenommen $\P=\PSPACE$ und sei $S$ ein dünnes und lückenhaftes Orakel. %, d.h. $|S\cap\Sigma^n|\leq s(n)$ für ein Polynom $s$.
    Nimm auch an dass für alle Maschinen $M_j$ und hinreichend lange $z$ gilt: wenn $M_j^G(z)$ akzeptiert, dann wird auch $M_j^T(z)$ akzeptieren, und das für jedes $T\subseteq G$ welches mit $G$ auf allen Wörtern der Länge $<\tower(k)$ übereinstimmt, wobei $k\in\omega$ maximal sodass $\tower(k)\leq p_j(|z|)$.
    (In anderen Worten: $G$ und $T$ stimmen bis zur (exklusive) höchsten abfragbaren Stufe erlaubter Länge überein.)
    %Ab hinreichend langen Eingaben $z$ wird auch $M_j^T(x)$ akzeptieren, wobei $T\subseteq S$ mit $S$ auf allen Wörtern der Länge $< |x|$ übereinstimmt.
    %existiert eine Länge $n$ sodass $L(M_j^T)=\Sigma^*$ für alle $T\subseteq S$ die mit $S$ auf allen Wörtern der Länge $\leq n$ übereinstimmen.

    Dann gilt $Q$ relativ zu $S$: zu jeder Maschine $M_j$ mit $L(M_j^S)=\Sigma^*$ existiert ein $g\in\FP^S$ sodass, für alle $x$, die Ausgabe $f(x)$ ein akzeptierender Rechenweg von $M_j(x)$ ist. 
\end{lemma}
\begin{proof}
    Sei $M_j$ mit $L(M_j^S)=\Sigma^*$ gegeben, und sei nun $n$ die oben spezifizierte Längenschranke.
    %Wir werden im Folgenden nur hinreichend lange Eingaben $z$ betrachten für welche $|z|\geq n$ und ein eindeutiges $k\in\omega$ existiert mit
    %\[ \tower(k-1) \leq \log|x| \leq \tower(k). \]
    %Sei nun $T_0=S\cap\Sigma^{< n}$. 
    %Klar ist, dass $T_0$ mit $S$ auf $\Sigma^{< n}$ übereinstimmt, und nach Voraussetzung akzeptiert auch $M_j^{T_0}(x)$.
    %Es gilt sogar für alle $T$ mit $T_0\subseteq T \subseteq S$ dass $M_j^{T}(x)$ akzeptiert.

    Sei $z\in\Sigma^*$ eine Eingabe, und $k\in\omega$ die wie oben spezifizierte größte Zahl sodass $\tower(k)\leq p_j(|z|)$. Wir können $k$ aus $z$ effizient (in abh. von $|z|$) berechnen und können daher ohne Beschränkung diese Zahl als dem Algorithmus gegeben ansehen.
    Wir werden im Folgenden nur hinreichend lange Eingaben $z$ betrachten für welche $|z|\geq n$ und 
    \[ \tower(k-1) \leq \log|z| \leq \tower(k). \]
    Wir werden die in der Behauptung vorausgesetzten  Eigenschaft ausnutzen und und iterativ eine Menge $T\subseteq S$ an Orakelwörtern aufbauen, welche für die Berechnung $M_j^S(x)$ relevant ist, bis wir alle solche relevaten Wörter gefunden haben. Wir starten hierbei mit der Menge $T_0=\Sigma^{<\tower(k)}$. (Wir zeigen später dass diese in $\P^S$ berechnet werden kann.)

    Da uns $T$ vorliegt, können wir sogar diese Orakelwerte in $M_j$ hineincodieren, sodass $M_j'(x)$ äquivalent arbeitet, aber ohne Orakelfragen auskommt. Und da $\P=\PSPACE$ können wir in $\FP$ auch einen akzeptierenden Rechenweg von $M_j'(x)$ bestimmen.

    \noindent
    \SetKwFor{Loop}{repeat}{}{end}
    \begin{algorithm}[H]
        $T_0\gets \bigcup_{i=0}^{k-1} S\cap\Sigma^{\tower(i)}$\;
        $T\gets T_0$\;
        \Loop{}{
            Sei $\alpha$ ein akzeptierender Rechenweg auf $M_j^{T}(x)$ und $Q$ die Menge an Orakelfragen\;
            \eIf{existiert eine Frage $q\in Q$ für die $q\in S$ aber $q\not\in T$}
            {
                $T\gets T \cup \{q\}$\;
            }
            {
                \Return{$\alpha$}
            }
        }
    \end{algorithm}

    Korrektheit: Es ist klar dss der in  Zeile 1 berechnete Term tatsächlich $T_0=S\cap\Sigma^{<\tower(k)}$ entspricht, da die ausreicht die erlaubten Längen abzufragen. Beobachte nun die Invariante dass $T_0\subseteq T\subseteq S$; damit existiert dann auch ein akzeptierender Rechenweg auf $M_j^{T}(x)$ nach Voraussetzung, und Zeile 4 ist wohldefiniert.

    Terminiert nun der Algorithmus mit einem Rechenweg $\alpha$, wissen wir auch dass für alle Orakelfragen $q\in Q$ entweder $q\in T$ gilt oder $q\not\in S$ gilt.
    Damit stimmt $T$ mit $S$ auf $Q$ überein, und auch $M_j^O(x)$ akzeptiert mit Rechenweg $\alpha$.

    Laufzeit: Wir zeigen dass der Algorithmus in polynomiell beschränkter deterministischer Zeit (abhängig von $|x|$) arbeitet, ohne Beschränkung aber nur für Eingaben die entsprechend der obigen Einschränkungen lang genug sind. Wie bereits argumentiert können wir $k$ als gegeben verstehen.
    Zeile 1 macht für jede der $O(|z|)$ Teilmengen $S\cap\Sigma^{\tower(i)}$ höchstens $O(|z|)$ viele Queries der Länge $O(|x|)$ denn wir haben ja $\tower(i)\leq \log|z|$.

    Wir zeigen, dass der Algorithmus nach höchstens polynomiell vielen Iterationen terminiert.
    Für jede Orakelfrage $q\in Q$ gilt, dass $|q|\leq p_j(|x|)$.
    Zusammen mit o.g. Invariante gilt $T\subseteq S\cap\Sigma^{\leq p_j(|x|)}$.
    %Da aber $S$ dünn gilt $|T|\leq p_j(|x|)\cdot s(p_j(|x|))$, i.e. beschränkt durch ein Polynom abh von $|x|$.
    Nun aber ist $S$ dünn, also kann $T$ nur polynomiell viele Elemente (abh. von $|z|$) enthalten.

    Zeile 4 kann damit auch in polynomiell beschränkter deterministischer Zeit berechnet werden. Wie oben skizziert kann die Berechnung in deterministisch polynomieller Zeit abh. von $|z|$ und $\ell(T)$ simuliert werden.
\end{proof}

Wir definieren nun unseren Begriff der Generizität:
\begin{definition}\label{def:upc}
    Eine Bedingung $\gamma$ ist eine $\mathbf{UPC}$-Bedingung, falls
    \begin{thmenum}
        \item $\dom(\gamma)=\Sigma^{\leq n}$ für ein $n\in\omega$, und
        \item\label{def:upc-sparsity} für alle $m\leq n$ gilt: $|\gamma\cap\Sigma^m|\leq 2$ falls $m\in H_i$ für ein $i\in\omega$, sonst $|\gamma\cap\Sigma^m|=0$.
        \item\label{def:upc-generizität-zeugensprache} für alle $i\in\omega$ gilt: wenn ein $m\in H_i,m\leq n$ existiert mit $|\gamma\cap\Sigma^m|=2$, dann existiert eine Eingabe $y$ sodass $M_i^\gamma(y)$ auf zwei Rechenwegen akzeptiert. Dabei stellt die Berechnung nur Fragen der Länge $\leq 2^m$.
    \end{thmenum}
    Der Begriff der Generizität $\mathbf{UPC}$ ist nun die Menge aller $\mathbf{UPC}$-Bedingungen.
\end{definition}
Es ist leicht zu sehen, dass $\mathbf{UPC}$ tatsächlich ein Begriff der Generizität im Sinne der Definition \ref{def:generizität} ist.
%Insbesondere ist $\epsilon$, die nirgends definierte Funktion, eine $\mathbf{UPC}$-Bedingung.
Die Eigenschaften von $\mathbf{UPC}$-Bedingungen übertragen sich auf $\mathbf{UPC}$-generische Orakel (routinierte Anwendung von Definition \ref{def:generizität-ext}):
\begin{property}\label{prop:upc-orakel}
    Sei $G$ ein $\mathbf{UPC}$-generisches Orakel.
    \begin{thmenum}[start=2]
        \item\label{def:upc-orakel-sparsity} für alle $m\in\omega$ gilt: $|G\cap\Sigma^m|\leq 2$ falls $m\in H_i$ für ein $i\in\omega$, sonst $|G\cap\Sigma^m|=0$.
        \item\label{def:upc-orakel-generizität-zeugensprache} für alle $i\in\omega$ gilt: wenn ein $m\in H_i$ existiert mit $|G\cap\Sigma^m|=2$, dann existiert eine Eingabe $y$ sodass $M_i^G(y)$ auf zwei Rechenwegen akzeptiert. Dabei stellt die Berechnung nur Fragen der Länge $\leq 2^m$.
    \end{thmenum}
\end{property}

Wir wollen nun folgende Aussagen erzwingen:
\[ R_{i,r}\colon \text{„$M_i^X$ akz. ein $x$ auf zwei Rechenwegen“} \lor \neg„L_{i}(X)\leqmpp L(M_i^X)\text{ via }T^X_r“. \]
Hierfür zeigen wir, dass unser Begriff der Generizität stark genug ist, um alle $R_{i,r}$ zu erzwingen, also $\gamma\Vdash\neg\neg R_{i,r}$ für alle $\gamma\in\mathbf{UPC}$.
Dann sind wir auch schon mit dem UP-Teil unserer Orakelkonstruktion fertig.
Beachte wie alle folgenden Aussagen relativieren.

\begin{claim}
    Angenommen $\gamma\Vdash\neg\neg  R_{i,r}$ für alle $\gamma\in\mathbf{UPC}$.
    Dann existiert keine vollständige Menge für $\UP$ relativ zu jedem $\mathbf{UPC}$-generischem Orakel $G$.
\end{claim}
\begin{proof}
    Sei $G$ ein beliebiges $\mathbf{UPC}$-generisches Orakel.
    Angenommen es existiert eine vollständige Menge für $\UP^G$, welche durch $N^G_i$ entschieden wird.
    Insbesondere wird $N^G_i$ keine Eingabe auf zwei Rechenwegen akzeptieren.

    Wir haben $L_i(G)\not\leqmpp L(N^G_i)$; wir zielen auf einen Widerspruch und nehmen an, es existiert eine Reduktionsfunktion $T_r^G$.
    %Es gilt $\epsilon\in\mathbf{UPC}$ und nach Voraussetzung gilt $\epsilon\Vdash\neg\neg  R_{i,r}$.
    Es gibt ein $\gamma\in\mathbf{UPC}$ mit $G\succ\gamma$ (z.B. via Definition \ref{def:genorakel-vollst}); nach Voraussetzung gilt $\gamma\Vdash\neg\neg  R_{i,r}$.
    Nach Korollar \ref{cor:double-negation-truth} gilt also insbesondere für unser $G\succ\gamma$ dass $\omega[G] \vDash \phi_{i, r}$.
    Da nach Annahme aber $\omega[G] \not\vDash \text{„$M_i^X$ akz. ein $x$ auf zwei Rechenwegen“}$ haben wir
    \[ \omega[G] \vDash  \neg„L_{i}(X)\leqmpp L(M_i^X)\text{ via }T^X_r“. \]
    Das bedeutet aber genau dass $T^G_r$ eben nicht die Reduktion von $L_{i}(G)$ auf $L(M_i^G)$ leistet; Widerspruch wie gewünscht.

    Wir zeigen nun dass $L_i(G)\in\UP^G$. Dann sind wir auch schon fertig, denn dann ist $L(M_i^G)$ nicht vollständig.
    Angenommen $L_i(G)\not\in\UP^G$. Dann existiert ein $m\in H_i$ und $|G\cap \Sigma^m|= 2$.
    %Nach Definition \ref{def:genorakel-vollst} existiert ein $\sigma\in\mathbf{UPC}$ mit $G\succ \sigma$ und $a,b\in\dom(\sigma)$.
    %Nach Definition~5(1) existiert dann sogar ein $\tau\in\mathbf{UPC}$ mit $\gamma\cup\sigma\succeq \tau\succ G$.
    %Insbesondere $a,b\in\dom(\tau)$.
    %Insbesondere gilt $\sigma(a)=\sigma(b)=1$ (ansonsten $G\not\succ\sigma$).
    %Also gilt nach Definition \ref{def:upc-generizität-zeugensprache} dass eine Eingabe $z$ existiert sodass $M_i^\sigma(z)$ auf zwei Rechenwegen akzeptiert. 
    %Also gilt auch für $G\succ\sigma$ dass $M_i^G(z)$ auf zwei Rechenwegen akzeptiert.
    Dann gilt mit Eigenschaft \ref{def:upc-orakel-generizität-zeugensprache} sofort, dass auch $M_i^G(y)$ auf zwei Rechenwegen akzeptiert.
    Widerspruch zur Wahl von $M_i$.
\end{proof}

Wir zeigen nun wie angekündigt, dass unser Begriff der Generizität stark genug ist, alle $R_{i,r}$ zu erzwingen.
\begin{claim}
    Sei $\gamma\in\mathbf{UPC}$, $i,r\in\omega$ beliebig. Es gilt $\gamma\Vdash\neg\neg   R_{i,r}$.
\end{claim}
\begin{proof}
    Sei $\gamma\in\mathbf{UPC}$ beliebig. Wir zeigen dass ein $\tau\in\mathbf{UPC}, \tau\succeq \gamma$ existiert mit $\tau\Vdash\phi$;
    das ist ausreichend um $\gamma\Vdash\neg\neg   R_{i,r}$ zu zeigen.

    Wähle ein $n\in H_i$ hinreichend groß sodass $\gamma$ kein Wort der Länge $n$ definiert,
    und sodass $2^n>p_i(p_r(n))$.
    Definiere nun für $S\subseteq\Sigma^n$ die Bedingung $\sigma_S$ mit
    \[ \sigma_S(x)  =\begin{cases}
    \gamma(x) & \text{falls $x\in\dom(\gamma)$},\\
    S(x) & \text{falls $|x|=n$},\\
    0 & \text{falls $n<|x|\leq 2^n$},\\
    \text{undef.} & \text{sonst}.
    \end{cases}
    \]
    Wir haben $\sigma_S\succeq \gamma$.
    Es gilt $\sigma_\emptyset\in\mathbf{UPC}$ und $\sigma_{\{a\}}\in\mathbf{UPC}$ für alle $a\in \Sigma^n$:
    (i) Offenbar $\dom(\sigma_S)=\Sigma^{\leq p_i(p_r(n))}$.
    (ii) Wenn $\sigma_S(x)=1,x\not\in\dom(\gamma)$ dann nach Definition $x\in S$ und damit $|x|=n\in H_i$.
    Auch (iii) ist nur verletzt wenn verschiedene $a,b\in\dom(\sigma_S)\setminus\dom(\gamma)$ existieren mit $\sigma_S(a)=\sigma_S(b)=1$, dann aber $a,b\in S$ aber wir haben $S=\emptyset$ oder $S=\{a\}$.

    Der weitere Beweis erfolgt nun in Fallunterscheidung. Nehme für den ersten Fall an dass
    \[ \sigma_\emptyset \Vdash \neg„L_{i}(X)\leqmpp L(M_i^X)\text{ via }T^X_r“ \]
    oder für ein $a\in\Sigma^n$
    \[ \sigma_{\{a\}} \Vdash \neg„L_{i}(X)\leqmpp L(M_i^X)\text{ via }T^X_r“. \]
    Dann sind wir fertig: für eines dieser $\sigma_S$ gilt $\sigma_S\Vdash   R_{i,r}$ und setze $\tau=\sigma_S$.

    Für den anderen Fall gilt 
    \[ \sigma_\emptyset \not\Vdash \neg„L_{i}(X)\leqmpp L(M_i^X)\text{ via }T^X_r“ \text{ und }\sigma_{\{a\}} \not\Vdash \neg„L_{i}(X)\leqmpp L(M_i^X)\text{ via }T^X_r“ \]
    für alle $a\in\Sigma^n$.
    Wir wollen hieraus ableiten dass ein $\tau\succeq\gamma$ existiert sodass
    \[ \tau\Vdash (\exists z)[\text{„$M_i^X(z)$ akz. auf zwei Rechenwegen“}] \text{ und damit } \tau\Vdash  R_{i,r}. \]

    Nach Annahme und Lemma 8 existiert ein $A\succ\sigma_\emptyset\succeq \gamma$ mit $\omega[A] \vDash „L_{i}(X)\leqmpp L(M_i^X)\text{ via }T^X_r“$.
    Da $0^n\not\in L_i(A)$ gilt also $N^A_i(T_r^A(0^n))=0$.
    Also existiert ein kleinstes $\alpha\prec A$ sodass auch $N^\alpha_i(T_r^\alpha(0^n))=0$ definiert (fixiere die Orakelfragen); in anderen Worten
    \begin{equation}
        N^B_i(T_r^B(0^n))=0 \text{ für alle }B\succ\alpha.\label{eq:up-rejects}
    \end{equation}
    Beobachte dass $\alpha$ und $\sigma_\emptyset$ (und damit auch $\gamma$) kompatibel sind.
    Insbesondere gilt $\max(\dom(\alpha))\leq p_i(p_r(n))$ und damit $\dom(\alpha)\subseteq 2^{p_i(p_r(n))}=\dom(\sigma_\emptyset)$ also auch $\alpha\preceq \sigma_\emptyset$.

    Auf gleiche Weise sehen wir, für je ein $a\in\Sigma^n$, ein kleinstes $\beta_a$ existiert sodass $M_i(T_r(0^n))=1$ relativ zu $\beta_a$ ($\beta_a$ fixiert alle Orakelfragen), also wieder
    \begin{equation}
        N^B_i(T_r^B(0^n))=1 \text{ für alle $B\succ\beta_a$ mit Orakelfragen $\dom(\beta_a)$}.\label{eq:up-accepts}
    \end{equation}
    %Beobachte dass $\beta_a$ und $\sigma_{\{a\}}$ (und damit auch $\gamma$) kompatibel sind.
    Wieder gilt $\dom(\beta_a)\subseteq 2^{p_i(p_r(n))}$, und $\alpha\preceq \sigma_{\{a\}}$ und sogar $|\dom(\beta_a)|\leq p_i(p_r(n))$.

    Ein kombinatorisches Standardargument zeigt aus Leterem dass nun zwei unterschiedliche $a,b\in \Sigma^n$ existieren mit $a\not\in \dom(\beta_b)$, $b\not\in \dom(\beta_a)$. Fixiere diese zwei $a,b$.
    Wir zeigen nun dass $\sigma_{\{a,b\}} \succeq \beta_a$ und $\sigma_{\{a,b\}} \succeq \beta_b$.
    Für ersteres erinnern wir uns daran dass $\beta_a\preceq\sigma_{\{a\}}$, sowie
    \[ \dom(\beta_a)\subseteq \dom(\sigma_{\{a\}})=\dom(\sigma_{\{a,b\}}). \]
    Dass $\sigma_{\{a,b\}}$ also den Definitionsbereich von $\beta_a$ erweitert haben wir damit also gezeigt. Wir müssen nun noch zeigen, dass für $z\in\dom(\beta_a)$ die Funktionen $\beta_a$ und $\sigma_{\{a,b\}}$ gleiche Bilder haben: wir haben
    \[ \beta_a(z)=\sigma_{\{a\}}(z)=\sigma_{\{a,b\}}(z), \]
    erste Gleichung Kompatiblität, zweite Gleichung klar aus Definition da $z\neq b$ nach Wahl von $z\in\dom(\beta_a)$ und Wahl von $\beta_a$ mit $b\not\in \beta_a$.
    Zweite Aussage $\sigma_{\{a,b\}} \succeq \beta_b$ geht analog.

    Wenden wir nun (\ref{eq:up-accepts}) je einmal mit $\beta_a$ und mit $\beta_b$ an sehen wir, dass
    für alle $C\succ \sigma_{\{a,b\}}$ die Berechnung $N^C_i(T^C_r(0^n))=1$ auf zwei Rechenwegen akzeptiert, je eine mit Orakelfragen $\dom(\beta_a)$ und eine mit Orakelfragen $\dom(\beta_b)$. Wir zeigen später dass diese zwei Rechenwege nicht gleich sind. Damit haben wir dann 
    \[ (\forall C\succ \sigma_{\{a,b\}}).\quad\omega[C]\vDash(\exists z)[\text{„$M_i^X(z)$ akz. auf zwei Rechenwegen“}], \]
    (der implizite $\exists$-Quantor ist erfüllt für Eingabe $z=T_r^X(0^n)$)
    nach Beobachtung \ref{obs:forcing-by-universaity} also
    \[ \sigma_{\{a,b\}} \Vdash(\exists z)[\text{„$M_i^X(z)$ akz. auf zwei Rechenwegen“}] \]
    und damit ist mit $\tau=\sigma_{\{a,b\}}$ auch $\tau\Vdash   R_{i,r}$ wie gewünscht.

    Wir zeigen nun dass (für jedes festes $C$) die beiden oberen Rechenwege nicht gleich sind. 
    Wir erreichen das, in dem wir $a\in\dom(\beta_a)$ zeigen, denn nach Wahl gilt $a\not\in\dom(\beta_b)$ und die zwei Rechenwege stellen unterscheidliche Orakelfragen.

    Um ersteres nun zu zeigen nimm an dass auch $a\not\in\dom(\beta_a)$.
    Unter dieser Annahme sind $\beta_a$ und $\alpha$ kompatibel:
    Wir erinnern uns dass 
    \[ \alpha\preceq\sigma_\emptyset, \quad \beta_a\preceq\sigma_{\{a\}}. \]
    Sei $z\in\dom(\alpha)\cap\dom(\beta_a)$. Es gilt insbesondere $z\neq a$ und damit
    \[ \alpha(z)=\sigma_\emptyset(z)=\sigma_{\{a\}}=\beta_a(z), \]
    wobei zweite Gleichung klar aus Definition von $\sigma$ da $z\neq a$.
    Wähle nun ein beliebiges Orakel $B\succ\alpha\cup\beta_a$.
    Wir haben nun 
    \[ M_i^B(T_r^B(0^n))=0 \text{ nach (\ref{eq:up-rejects}), und } M_i^B(T_r^B(0^n))=1 \text{ nach (\ref{eq:up-accepts}).} \]
    Widerspruch, also gilt $a\not\in\dom(\beta_a)$ und die obigen zwei Rechenwege können nicht gleich sein, wie gewünscht.
\end{proof}

Jedes $\mathbf{UPC}$-generischem Orakel $G$ erfüllt die in Lemma \ref{thm:q-algorithmus} genannte Voraussetzung:
\begin{claim}
    Sei $G$ ein $\mathbf{UPC}$-generischem Orakel.
    Das Orakel $G$ ist dünn, es ist lückenhaft, und für alle $M_j$ und hinreichend lange $z$ gilt: wenn $M_j^G(z)$ akzeptiert, dann wird auch $M_j^T(z)$ akzeptieren, und das für jedes $T\subseteq G$ welches mit $G$ auf allen Wörtern der Länge $<\tower(k)$ übereinstimmt, wobei $k\in\omega$ maximal sodass $\tower(k)\leq p_j(|z|)$.
\end{claim}
\begin{proof}
    Dünnheit und Lückenhaftigkeit folgen direkt aus Eigenschaft \ref{def:upc-orakel-sparsity}.
    Wir argumentieren nun für die zweite Teilaussage. Sei $M_j$ eine feste Maschine.
    Betrachte Aussage $Q_j$ mit
    \[ Q_j: \text{„$M_j^X$ akzeptiert alle Eingaben“}. \]
    Es gilt nach Lemma \ref{def:genorakel-forcing} dass ein $\gamma\in \mathbf{UPC}$ existiert mit $G\succ \gamma$ und $\gamma\Vdash \neg Q_j\lor \neg\neg Q_j$.
    Da $\gamma$ eine $\mathbf{UPC}$-Bedingung ist existiert ein $n\in\omega$ sodass $\dom(\gamma)=\Sigma^{\leq n}$. Fixiere dieses $n$.


    Wir betrachten nun nur noch Eingaben $z$, welche hinreichend lang sind sodass $\tower(k-1)\geq n$ (wobei wie in der Aussage der Behauptung das $k$ maximal ist sodass $\tower(k)\leq p_j(|z|)$. % und höchstens ein $k\in\omega$ existiert mit 
    %\begin{equation} \tower(k) \leq p_j(|z|) < 2^{\tower(k)}. \end{equation}
    Sei nun ein solches $z$ gegeben und entsprechendes $T\subseteq G$ gegeben.
    Wir setzen im Folgenden voraus dass $M_j^G(z)$ akzeptiert und wollen zeigen dass auch $M_j^T(z)$ akzeptiert.

    Wir erinnern uns dass entweder $\gamma\Vdash\neg Q_j$ oder $\gamma\Vdash\neg\neg Q_j$.
    Im ersteren Fall gilt nach Lemma \ref{lemma:single-negation-contradicts} insbesondere für unser vorliegendes $\mathbf{UPC}$-generisches $G$ die Aussage $\omega[G] \not\vDash Q_j$.
    Also lehnt $M_j^G(z)$ für eine geeignete Eingabe $z$ ab; das widerspricht der oben genannten Voraussetzung.

    Es gilt also $\gamma\Vdash\neg\neg Q_j$. Dann aber haben wir nach Korollar \ref{cor:double-negation-truth} die Aussage dass
    \begin{equation} (\forall \text{$\mathbf{UPC}$-generischen $G'\succ \gamma$}). \omega[G'] \vDash \text{„$M_j^X(z)$ akzeptiert“}.\label{eq:force-q}) \end{equation}
    Wir zielen nun auf einen Widerspruch ab und nehmen an, dass $M_j^T(z)$ ablehnt.
    Dann existiert auch ein minimales $\alpha$ sodass $M_j^\alpha(z)$ ablehnt, insb. mit $\dom(\alpha)\subseteq\Sigma^{\leq p_j(|z|)}$. Im Folgenden wollen wir nun ein $\mathbf{UPC}$-generisches $G'\succ \gamma,\alpha$ konstruieren, denn dann lehnt $M_j^{G'}(z)$ ab und wir erhalten den Widerspruch zu (\ref{eq:force-q}).

    Sei $\tau=T\cap \Sigma^{<\tower(k+1)}$ die Einschränkung der totalen Funktion $G$ auf die Wörter der Länge $< \tower(k+1)$.
    Es ist unmittelbar klar dass $\alpha\preceq\tau$. (Alle Wörter in $\dom(\alpha)$ haben Länge $\leq p_j(|z|)$ und diese sind $<\tower(k+1)$, denn andernfalls $\tower(k+1)\leq p_j(|z|)$ was der Wahl von $k$ widerspricht.)

    Nach Definition von $T$ stimmt $\tau$ mit $G$ auf allen Wörtern der Länge $<\tower(k)$ überein.
    Damit ist klar dass $\gamma\preceq \tau$. (Für alle Wörter $x\in\dom(\gamma)$ gilt $|x|\leq n\leq \tower(k-1)<\tower(k)$, also stimmen $S$ und $T$ auf $x$ überein und es gilt $\gamma(x)=S(x)=T(x)=\tau(x)$.)
    
    Wir wollen nun zeigen dass $\tau$ eine $\mathbf{UPC}$-generische Bedingung ist, dann existiert nach Lemma \ref{lemma:generics-existieren} auch ein $\mathbf{UPC}$-generisches Orakel $G'\succ \tau\succeq \gamma,\alpha$ und $M_j^{G'}(z)$ lehnt ab wie gewünscht.
    Hierfür gehen wir die Eigenschaften der Definition \ref{def:upc} durch: (i) klar, ist ja $\dom(\tau)=\Sigma^{<\tower(k+1)}$.
    (ii) ebenso klar, denn für alle $m<\tower(k+1)$ gilt $|\tau\cap\Sigma^m|=|T\cap\Sigma^m|\leq |G\cap\Sigma^m|$ und wende Eigenschaft \ref{def:upc-orakel-sparsity} ab.

    Für (iii), betrachte ein $i\in\omega$ und $m\in H_i$ mit $m<\tower(k+1)$. Damit ist $m=\tower(k')$ für ein $k'\leq k$. Sei $|\tau\cap\Sigma^m|=2$.
    Dann gilt auch $|G\cap\Sigma^m|=2$ ($\tau$ stimmt mit $T$ auf Wörtern auf $\Sigma^m$ überein und $T\subseteq G$).
    Nach Eigenschaft \ref{def:upc-orakel-generizität-zeugensprache} existiert also eine Eingabe $y$ sodass ein $\beta\prec G$ existiert, wo $M_i^\beta(y)$ mit zwei Rechenwegen akzeptiert, und $\dom(\beta)\subseteq\Sigma^{\leq 2^m}$.

    Wir zeigen nun $\beta\preceq \tau$, denn dann akeptiert auch $M_i^\tau(y)$ auf zwei Rechenwegen und wir haben die gewünschte Eigenschaft der $\mathbf{UPC}$-Definition \ref{def:upc-generizität-zeugensprache} gezeigt.
    Klar ist schon mal dass $\dom(\beta)\subseteq\dom(\tau)$. (Für alle $x\in\dom(\beta)$ gilt $|x|\leq 2^m=2^{\tower(k')}<\tower(k+1)$ also $x\in\dom(\tau)$.)

    Gilt $k'<k$ gilt auch $2^m<2^{\tower(k')}<\tower(k)$, dann stimmen je $\beta$ und $\tau$ mit $G$ auf $\Sigma^{\leq 2^m}$ überein und wir haben sofort dass $\beta$ und $\tau$ kompatibel sind; in diesem Fall $\beta\preceq \tau$ gezeigt.

    Gilt $k'=k$ dann gilt wie oben nach Konstruktion $2=|T\cap\Sigma^m|=|G\cap\Sigma^m|$ und da $T\subseteq G$ stimmen $T$ und $G$ auf Wörtern der Länge $m=\tower(k)$ überein.
    Zusammen mit Voraussetzung ergibt sich, dass dann $T$ und $G$ auf Wörtern der Länge $<\tower(k+1)$ übereinstimmen.
    Also gilt $\tau\succ G$ und nach Wahl $\beta\succ G$; wir haben dass $\beta$ und $\tau$ kompatibel sind und haben $\beta\preceq\tau$ gezeigt.

    Das schließt den Beweis ab.
\end{proof}

Nun können wir abschließend alles zusammenführen.
\begin{theorem}
    Es existiert ein Orakel relativ zu diesem $\UP$ keine vollständigen Mengen hat, aber auch Aussage $Q$ gilt.

    Insbesondere gilt das für alle Orakel der Form $G\oplus A$ wobei $G$ ein $\mathbf{UPC}$-generisches Orakel ist, und $A$ ein $\PSPACE$-vollständiges Orakel.
\end{theorem}
\begin{proof}
    Klar ist, dass solche Orakel $G$ und $A$ existieren.
    %Sei $G$ ein $\mathbf{UPC}$-generisches Orakel. % (Dies exisitiert nach Lemma \ref{lemma:generics-existieren}.)
    Kombiniert man Behauptung \ref{} und \ref{} ergibt sich, dass $\UP$ relativ zu $G$ keine vollständige Menge hat.
    Nachdem die Behauptungen relativieren gilt auch, dass $\UP$ relativ zu $G\oplus A$ keine vollständige Menge hat, und das für alle Orakel $A$.

    Kombiniert man Behauptung \ref{} und Lemma \ref{} und rerelativiert man auf $A$ ergibt sich, dass die Aussage $Q$ relativ zu $G\oplus A$ gilt, \emph{unter Voraussetzung} dass $\P^A=\PSPACE^A$.
    Aber diese Voraussetzung ist durch ein PSPACE-vollständiges $A$ ja genau erfüllt.
\end{proof}


\printbibliography[heading=subbibliography]

\endrefsection

\end{document}
